# -*- coding: utf-8 -*-
"""
Created on Tue Oct 16 10:19:30 2018

@author: stu
"""

# -*- coding: utf-8 -*-
"""
Created on Tue Sep  4 10:40:50 2018

@author: stu
"""

import keyword
keyword.kwlist 

x=10
x
print(x)
type(x)

a = 1
a = a +1
a +=1

a = a-1
a -=1
print(a)

a = a*1
a *=1

a = a/2
a /=2

a = a//2
a //= 2

f = 10.12 #부동소숫점(float)
type(f)

f = 10.4e3 #지수표현 10.4*10**
type(f)

x = 1
y = 2
y > x
y >= x
y <= x
y == x
y != x


2 > 1 and 3 > 2
2 > 1 or 3 >2
not 1 > 2  # and or not 


[문제1] x,y 변수에 있는 값을 기준으로 수행한 결과 입니다. 
x 와 y 변수에 어떤 값이 있어야 하나요.
또한 결과값이 나오기 위해서 어떤 계산식을 만들어야 하는지 계산식을 만들어 보세요.

#result_1~result_8 단순연산자 
result_1 =  7
result_2 =  3
result_3 =  -3
result_4 =  10
result_5 =  0.4
result_6 =  0
result_7 =  2
result_8 =  32
#result_9 복합연산자
result_9 =  7.0
result_10 =  -21
result_11 =  50
result_12 =  29

x= 5
y= 2

result_1= x+y 
print(result_1)
result_2 =x-y 
print(result_2)
result_3 =y-x
print(result_3)
result_4 = x*y
print(result_4)
result_5 = y/x
print(result_5)
result_6 = y//x
print(result_6)
result_7 = y%x
print(result_7) 
result_8 = y**x 
print(result_8)

result_9 = result_5* x + x 
print(result_9)
result_10 = (x+y) * (y-x)
print(result_10)
result_11 = (x*y) * x
print(result_11)
result_12 = x**y+y**y
print(result_12)

result_9 = result_5*x + x
print(result_9)
result_10 = result_1 * result_3
print(result_10)
result_11 = result_4 * x
print(result_11)
result_12 =x**y+y**y
print(result_12)

print("result_1=", result_1)

#변수확인
dir() #선언된 변수 확인
locals()
del(x) #선언된 변수 삭제


문자열 
'대한민국'
"짝짝짝"
"""대한민국
짝짝짝"""


\n
print("오늘 하루도 \n 행복하자")

\t
print("오늘 하루도 \t 행복하자")
print("잘하자\t 파이썬")

\0 #공백문자
print("잘하자\0파이썬")

\\ #표시
print("잘하자\0파이썬\\R")

\\
print("잘하자\'파이썬\'")
print("잘하자'파이썬'")

x = '김현정'
y = '파이썬 개발자'
type(x)
x+y #문자+문자 연결연산자

# 문자에서 *(곱)은 반복연산자(복제)
(x+y)*2

print('='*15)
print("hello world")
print("="*15)


# 포맷팅 코드: %s(문자 포맷) , 들어가야할 값 %( , )
name = "제임스"
music = "클래식"

print("안녕하세요. {}입니다. 즐겨듣는 음악은 {}입니다.".format(name, music))
print("안녕하세요. %s입니다. 즐겨듣는 음악은 %s입니다." %(name, music))

# 포맷팅 코드: %d (정수 포맷)
x = 996
y = 8
result = x % y
print("{}를 {}나누면 {}가 나머지 입니다.".format(x,y,result))

print("%d를 %d 나누면 %d가 나머지 입니다." %(x,y,result))

result1= x//y
result2 = x%y
print("%d를 %d 나누면 %d는 몫이고 %d 나머지입니다." %(x, y, result1, result2))

# divmod
result1, result2 = divmod(x,y)
print("%d를 %d 나누면 %d는 몫이고 %d 나머지입니다." %(x, y, result1, result2))

# %f는 실수를 나타내주는 포맷팅 코드 
print("원주율은 %d 입니다." %3.14159)
print("원주율은 {}입니다.".format(3.14159))
print("원주율은 %f 입니다." %3.14159)

#인덱싱 & 슬라이싱
x = "행복한 하루를 보내자" 
len(x)
x[:]
x[0]
x[1]
x[-1] 
x[0:3] #x[시작요소번호:끝요소번호-1]
x[3:]
x[4:6]
x[4:-5]
x[::2]
x[1:7:2]
x[5::2]
x[::-1]


#
[문제_2] v_str 변수에 이 문자열을 입력하세요. 


v_str = "시간은 멈추지 않습니다. 하루를 유익하게 살아야합니다."

len(v_str)

1. "시간은 멈추지 않습니다." 만 출력해주세요

v_str[0:13]



2. "하루를 유익하게 살아야합니다." 만 출력해주세요

v_str[14:30]
v_str[14::]


3. "살아야합니다."  만 출력해주세요

v_str[-7::]



4. "시추니루하야"  이 글자만 출력해주세요.

v_str[0:30:5]



5. "시간은 멈추지 않습니다. 하루를 유익하게" 만 출력해주세요.

v_str[0:-7]


6. v_str 문자열을 뒤순으로 출력해 주세요.

v_str[::-1]



##
[문제3] R과 달리 인덱스를 바로 변환하지 못하므로 조각조각 내어 문제를 풀어야 한다. 

>>> x = '파리썬'
>>> x
'파리썬'

인덱스를 이용해서 리 -> 이로 변환하세요.
 
x = '파리썬'
x=x[0]+'이'+x[2]
x
      

#문자함수: 함수앞에 변수의 이름이 꼭 와야 한다. 
#replace함수
x = '파리썬'
x.replace('리','이') #함수 미리보기로는 파이썬으로 수정가능 했으나 다시 x를 출력하면 파리썬으로 나오니 변수를 다시 지정해줘야 한다. 
x
x = x.replace('리','이')
x

#startswith: 원본 문자열이 매개변수로 입력한 문자열로 시작되는지를 판단
x = 'hello world'

x.startswith('h')
x.startswith('H')

#endswith: 원본 문자열이 매개변수로 입력한 문자열로 끝나는지를 판단
x.endswith('d')
x.endswith('D')
x.endswith('ld')

#find: 원본 문자열안에 매개변수로 입력한 문자열이 존재하는 위치를 앞에서부터 찾는다. 만약 존재하지 않으면 -1로 나온다.(0이 인덱스를 가지기 때문에)
x.find('w')
x.find('world')
x.find('W')

#count: 원본 문자열 안에 매개변수로 입력한 문자열이 몇번 나오는지에 대한 건수 
x.count('l')

#upper: 원본 문자열을 대문자로 변환 
x.upper()

#lower: 원본 문자열을 소문자로 변환
x.lower()

#capitalize: 원본 문자열을 첫글자를 대문자 변환
x.capitalize()

#title: 단어마다 첫글자를 대문자로 변환
x.title()

# swapcase: 문자끼리 스위칭을 하고 싶을 때
s = "HELLO, world"

s.swapcase()

#center: 원본 문자열을 지정한 공간에서 중앙에 배치 
s.center(20)

#ljust: 원본문자열을 지정한 공간에서 왼쪽에서 배치
s.ljust(20)

#rjust: 원본문자열을 지정한 공간에서 오른쪽에 배치
s.rjust(20)


# 공백제거 함수 
x = '                        hello      '
#strip: 원본문자열 양쪽에 공백을 제거
x.strip()

#lstrip: 원본문자열 왼쪽에 공백을 제거 
x.lstrip()

#rstrip: 원본문자열 왼쪽에 공백을 제거 
x.rstrip()

# strip응용하여 문자제거
x = 'helloh'
#strip: 원본문자열 양쪽에 문자를 제거
x.strip('h')

#lstrip: 원본문자열 왼쪽에 문자를 제거 
x.lstrip('h')

#rstrip: 원본문자열 왼쪽에 문자을 제거 
x.rstrip('h')

#is.alpha: 원본 문자열이 숫자, 기호를 제외한 알파벳, 한글로 이루어졌는지 확인
x = 'hello'
y = 'hello2018'
z = '안녕하세요'

x.isalpha()
y.isalpha()
z.isalpha()

#isalnum(): 원본 문자열이 알파벳, 숫자로 이루어져 있는지 확인 (And 조건이 아닌 OR조건에 해당 )
x.isalnum()
y.isalnum()
z.isalnum()

#isnumeric: 원본 문자열이 수로만 이루어져 있는지 확인 
x.isnumeric()
y.isnumeric()
z.isnumeric()

d = '2018'
d.isnumeric()

#replace: 원본문자열에서 어떤 문자열을 찾아서 새로운 문자열로 변경
x.replace('hello', 'python')


#find: 있으면 인덱스 번호를 return해주고, 없으면 -1의 값으로 return한다. 
x.find('o')
x.find('O')
#index: 있으면 인덱스 번호를 return해주고, 없으면 오류를 냄 
#index: 원본 문자열안에 매개변수로 입력한 문자열이 존재하는 위치를 앞에서부터 찾는다. 없으면 오류
x.index('o')
x.index('O')
#rfind: 원본문자열안에 매개변수로 입력한 문자열이 존재하는 위치를 뒤에서 부터 찾는다 (lfind는 없다.); 뒤에서부터 스캔하느냐 앞에서 부터 스캔하느냐가 다름 
x.rfind('o')

# in 연산자를 이용해서 문자열의 존재여부를 확인
'o' in x

#split: comma를 기준으로 x를 split 하고 싶을 때 사용 
x = 'hello, world'
x.split(',')

#' ' .join: 매개변수에 ' '가 사이에 기입됨 
# join: 원본 글자 사이에 특정한 문자열을 추가한다. 
x = 'abc'
x = ','.join(x)


###############################################################
a = 'a b c d e f g' 변수에 문자열이 들어 있습니다. 다음을 수행하세요.

a = 'a b c d e f g'
[문제4] a 변수에 있는 문자의 갯수를  구하세요.
len(a)

[문제5] a 변수에 공백문자 갯수를 구하세요.
a.count(' ')


[문제6] a 변수 안에 있는 공백문자를 제외한 갯수를 구하세요.
len(a)-a.count(' ')


[문제7] a 변수에 있는 공백문자를 제거한 후 b 변수에 넣어주세요
b = a.replace(' ','')
b


[문제8] a 변수에 있는 문자를 분리한 후 c 변수에 넣어주세요.
c = a.split(' ')

[문제9] c 변수에 있는 문자를 합쳐서 자신의 변수에 다시 넣어주세요.
c = ','.join(c)
c

###############################################################
아래와 같은 문자데이터가 있습니다. 
url = 'http://www.python.org'


[문제10] http:// 제거한 후 url 변수에 넣어 주세요.
url = url.replace('http://','')
url
url = url.lstrip('htttp://')

url

[문제11] url변수에 있는 문자 데이터에 '.'을 기준으로 분리하세요.
url = url.split('.')
url

[문제12] url변수에 있는 문자데이터를 www.python.org 모양으로 만드세요.
url='.'.join(url)
url

[문제13] url변수에 있는 문자데이터를 대문자로 변환하세요.
url.upper()

[문제14] url변수에 있는 문자데이터를 소문자로 변환하세요.
url.lower()



#input: 
x=input()

1234

y=input()

1234

x+y
Out[309]: '12341234'

type(x)

int(x)+int(y)



################################################################3
■ R의 자료형
1. Vector: 같은 데이터 타입을 갖는 1차원배열구조
2. Matrix: 같은 데이터 타입을 갖는 2차원배열구조
3. Array: 같은 데이터 타입을 갖는 다차원배열구조
4. List: 서로 다른 데이터 타입을 갖는 벡터들을 저장하거나 또다른 list를 저장하는 구조
5. Data.frame: 서로 다른 데이터 타입을 갖는 컬럼으로 이루어져 2차원 배열구조 (table)

■ Python의 자료형
1. List
- 서로 다른 데이터 타입을 갖는 1차원 배열 (vector구조, 그러나 서로 다른 데이터 타입을 가짐)
- 데이터의 목록을 다루는 자료형
- [ ]

x= [10,20,30]
x
len(x)
type(x)


#리스트 인덱싱
x[0]
x[-1]

#리스트 슬라이싱 [시작:끝-1]
x[0:2] #0번요소, 1번요소 보기
x[1:]  #1번요소 부터 다 보기
x[:-1]
x[-1:]

#리스트 값 수정
x[0] = 100
x[1:3] = [200, 300]
x

# append: 리스트변수 끝에 값을 추가
x.append(400)
x

# extend: 리스트변수와 리스트변수를 이어붙이기
# extend: 기존 리스트 변수에 다른 리스트 변수를 이어 붙이는 방법
x1 = [600,700]
x1

x.extend(x1)
x

#insert: 인덱스를 사용하여 특정 위치에 값을 추가
x.insert(4, 500)
x

# +를 이용해서 리스트변수 결합하는 방법 
x2 = [800, 900, 1000]
x = x + x2
x

x = [100, 200, 300, 400, 500, 600, 700, 800, 900, 1000]
#리스트변수에 있는 값 중에 마지막값을 제거하는 방법(인덱스 번호를 쓰지 않으면 제일 뒤에 있는 것이 제거 된다.)
x.pop()
x
x.pop(4)
x

#리스트 인덱스 값을 삭제하는 방법
del x[3]
x


#len, find, index 비교하기
drink=['콜라', '사이다', '환타', '콜라', '사이다', '콜라']
len(drink)
drink.count('콜라')
drink.find('콜라')  #오류
drink.index('콜라') #첫번째 ‘콜라’만 찾아줌
drink.index('콜라',1)  #1번방부터 ‘콜라’를 찾아줌
drink.index('콜라',4)  #4번방부터 ‘콜라’를 찾아줌

#리스트 변수에 값을 기준으로 삭제
drink.remove('콜라')
drink


# -*- coding: utf-8 -*-
"""
Created on Wed Sep  5 09:54:25 2018

@author: stu
"""

##문제
[문제17] day 변수에 20180905를 입력하세요. 화면 출력은 2018년 09월 05일 출력하세요.

day = "20180905"
print(day[0:4]+'년\0'+day[4:6]+'월\0'+day[6:]+'일')


day = "20180905"
print(day[0:4]+'년 '+day[4:6]+'월 '+day[6:]+'일')


####자료형########중첩리트스
x =[]
type(x)
x = [1,2,3,['a','b','c'], 4, 5]
x[2:5]
x[3]
x[3][0]
x[3][0:2]
x[3][-1]
x[3][2]
x[3].append('d')
x[3]
del x[3][3]
x[3]
x[3][0]=x[3][0].upper()
x[3][1]=x[3][1].upper()
x[3][2]=x[3][2].upper()

x[0]=x[0]*10    #[0]번 인덱스에는 숫자이기 때문에 곱이되고
x
x[3][0]=x[3][0]*2  #[3][0]의 인덱스는 문자이기 때문에 복제가 된다. 
x

# 리스트변수에 값을 다 지운다.
x.clear()
x

#리스트 내의 값을 기준으로 정렬 기본값은 오르참순 
x=[1,5,3,4,2]
x.sort()
x.sort(reverse=True)  #python에서 True도 대소문자 구문을 한다. 
x

#reverse: 리스트 인덱스 순서를 반대로 뒤집을 때 사용 
x=[1,5,3,4,2]
x.reverse()

#sorted: 정렬해서 미리보기
x = sorted(x)
x
x = sorted(x, reverse=True)
x

##문제 18~25
food 변수 아래와 같이 데이터가 들어 있습니다.food변수를 생성하시고 문제를 풀어보세요.

>>> food[0]
['김밥', '라면', '오뎅']
>>> food[1]
['비빔밥', '김치찌게']
>>> food[2]
['자장면', '짬뽕']

[문제18]  1번 index에 청국장 추가 하세요
food = [['김밥', '라면', '오뎅'],['비빔밥', '김치찌게'],['자장면', '짬뽕']]
food[0].append('청국장')
food[0]

[문제19] 2번 index에 탕수육 추가하세요.
food[2].append('탕수육')
food[2]

[문제20] 0번 index에 있는 오뎅 삭제하세요.
del food[0][2]
food[0]
 
#쌤답: food[0].remove('오뎅')

[문제21] 0번 index에 튀김, 튀김, 떡복이 한꺼번에 추가하세요
food1=['튀김','튀김','떡볶이']
food[0]+food1



[문제22] 2번 index에 2번 위치에 유산슬 추가하세요
food[2].insert(2,'유산슬')
food[2]
#쌤답: food[2].insert(2, '유산슬')

[문제23] 튀김 갯수를 세어주세요
food.count('튀김')
food


[문제24] 0번 index만 정렬해주세요# 인덱스 번호를 표현하지 않을 경우, 전체 중에 요소별로 0번 값을 기준으로 정렬한 값으로 표현하게 된다. 
food[0].sort
food[0]

[문제25] 0번 index에 마지막 데이터 삭제하세요
del food[0][-1]
food[0]

#쌤답: food[0].pop()

#중첩 리스트에서 len에 변수값을 바로 넣을 경우 전체값이 아니라 인덱스 갯수를 추출한다. 
len(food)

len(food[0])

len(food[2])


######자료형 #########tuple
리스트자료형과 똑같다. 차이점은 수정, 삭제, 추가 안된다.  cf. 상수처럼 사용되기 때문에 빠르게 처리된다. 
리스트[], 튜플()

list1=[]
type(list1)
tuple1=()
type(tuple1)
tuple2 = 10
type(tuple2)
tuple3 = (1,)
type(tuple3)
tuple4=(1,2,3,4)
type(tuple4)
tuple5=(1,2,3,('a','b'))
tuple5[3][0]
#튜플 변수 값을 수정하려면 오류
tuple5[0]=10

#튜플 변수 값을 삭제하려면 오류
del tuple5[0]

#튜플 변수 값을 추가 하려면 오류
tuple5.append(4)

# tuple을 연산하면 tuple로 결과가 나온다. 따라서 tuple에 변수를 추가하고 싶으면 tuple 자료형을 만들어 추가하면 된다.  
# 이때 사실은 tuple은 추가의 개념이 아니라 새로운 것이 만들어지는 것이다. 

x = (1,2,3)
id(x)
y = (4,5,6)
z = x + y
z
type(z)

# tuple은 append 대신 다음과 같이 추가할 수 있다. (새로운 x를 만들 수 있다.)
x = x +(4,)
x
id(x)
type(x) 

x.index(3)
x.count(1)

# sorted: sort를 하면서 type이 list로 바뀌게 된다. 
x =(2,3,4,1)
x.sort
type(x)
z =sorted(x)
type(z)
z


######자료형 ##■ dictionary
■ dictionary
- key를 가지고 value을 확인하는 자료형 
- {} 중괄호 사용 
- 예시)
key         value
이름        홍길동
전화번호    0101234568
주소        경기도

dic = {'이름':'홍길동', '전화번호':'01012345678','주소':'경기도'}
dic

type(dic)

dic['이름']

sports={'축구':'메시', '농구':'커리','야구':'박찬호'}

sports['축구']
#새로운 key -value값 넣기
sports['컬링']='김영미'
sports['컬링']=['김은정','김경애','김영미','김선영','김초희']
sports

#key값만 보기
sports.keys()
#value값만 보기
sports.values()
#key, value전체 다보기
sports.items()

sports['농구']
sports.get('농구')

#없는 key-value를 none으로 추출하기
sports['봅슬레이']
sports.get('봅슬레이')

# 키 값에 있는지 없는 지 확인 
'컬링' in sports.keys()
'봅슬레이' in sports.keys()

# value 값에 있는지 없는지 확인
'메시' in sports.values()
'호날두' in sports.values()
['김은정', '김경애', '김영미', '김선영', '김초희'] in sports.values()

del sports['야구']
sports

sports['축구']=[]
sports

sports.clear()
sports

sports={'축구':'메시', '농구':'커리','야구':'박찬호'}

x= sports.values()
x
type(x)

x=list(x)
type(x)


######### 자료형 ■ set(집합)
■ set(집합)
List type하고 비슷하다. 차이점은 index가 없다.

x = {1,1,1,2,3,2,3}
x
type(x)

y={2,3,4,5}
 
#합집합
x.union(y)
x|y

#교집합
x.intersection(y)
x&y

#차집합
x.difference(y)
x-y

y.difference(x)
y-x

# x에 있는 원소
1 in x
6 in x

# 인덱스가 없어서 오류
x[0]

#x에 있는 값 제거하기
#집합 변수에 값을 삭제
x.remove(1)
# 집합변수에 값을 입력
x.add(1) 
# 집합변수에 여러개의 값을 추가할 때
x.update([5,6,7])
x

####
a = []
b = ()
c = {}
s = set()
type(a)
type(b)
type(c)
type(s)



###자료형 ■ bool
■ bool
-참(True), 거짓(False)를 나타내는 자료형
-python에서는 대소문자 잘 구분지어서 나타내줘야한다. 
 
x = True
type(x)
y = False
type(y)

x == y
1 == 1
2 > 1
1 != 2

not 1
not -1
not 0
not None

#True 표현방법
bool(1)
bool(-1)
bool('python')
bool([1,2,3])
bool((1,2,3))
bool({1,2})

#False 표현방법
bool(0)
bool([])
bool(())
bool({})
bool(None)
bool('')


####### 조건문
■ if문 
if 조건문:
    수행해야할 문
    
if 1:
    print('참')
    print('오늘 하루도 행복하자')
    
if 0:
    print('참')
    print('오늘 하루도 행복하자')
else:
    print('거짓')
    print('그냥 사는거지 뭐...')

x = []
if x:
    print('참')
    print('오늘 하루도 행복하자')
else:
    print('거짓')
    print('그냥 사는거지 뭐...')

    
# x의 값이 참이면 참을 수행하고, 아니면 거짓을 수행함     
x = 1
if x==1:
    print('참')
    print('오늘 하루도 행복하자')
else:
    print('거짓')
    print('그냥 사는거지 뭐...')
    
#
x = 0
if x > 10 and 1/x :
    print('x는 10보다 크다')
else:
    print('x는 10보다 작다')
    
# x = 0
if 1/x and x>10 :
    print('x는 10보다 크다')
else:
    print('x는 10보다 작다')
 
if x > 10 & 1/x :    
    print('x는 10보다 크다')
else:
    print('x는 10보다 작다')
 
x= 0
if x < 10 or 1/x :    
    print('x는 10보다 크다')
else:
    print('x는 10보다 작다')

x= 0
if 1/x or x < 10:    
    print('x는 10보다 크다')
else:
    print('x는 10보다 작다')
    
    
x= 0
if x < 10 | 1/x :    
    print('x는 10보다 크다')
else:
    print('x는 10보다 작다')


#python에서는 elseif는 elif이다. 
score = 88

if 90 <= score <= 100:
    print('A')
elif 80 <= score <= 90:
    print('B')
elif 70 <= score <= 80:
    print('C')
elif 60 <= score <= 70:
    print('D')    
else:
    print('F')
    
    
# 문제
[문제26] 숫자를 입력값으로 받아서 짝수인지 홀수인지를 출력하는 프로그램을 만드세요.
x = input()

415
type(x)

if int(x)%2 ==1 :
    print('홀수')
else:
    print('짝수')
    
#쌤답
a = int(input('숫자를 입력하세요: ' ))
if a%2 == 0 :
    print('짝수')
else: 
    print('홀수')

[문제27]한글, alphabet만 입력받아야 합니다. 
        만약에 다른 문자가 들어 오면 "한글, alphabet 이외의 문자가 포함되어 있습니다." 라는 문구가 출력해야 하고 아니면 입력받은 문자를 출력하세요.

if x.isalpha():
    print(x)
else:
    print("한글, alphabet 이외의 문자가 포함되어 있습니다.")    


# 쌤답 - 공백문자가 있으면 false로 받는다.
a = input('문자를 입력하세요:')
if a.isalpha():
    print(a)
else: 
    print("한글, alphabet 이외의 문자가 포함되어 있습니다.")
    
[문제28] 숫자를 입력값으로 받습니다. 
   만약 숫자가 이외의 값이 들어 오면 "숫자 이외의 문자가 포함되어 있습니다." 아니면 숫자 출력하세요.

if x.isnumeric():
    print(x)
else:
    print("숫자 이외의 문자가 포함되어 있습니다.")    

#쌤답 
if a.isnumeric():
    print(a)
else: 
    print("숫자 이외의 문자가 포함되어 있습니다.")
    
    
#######################3
리스트 형일 때: False
x = [1,2]
y = [2,1]

if x == y:
    print('참')
else:
    print('거짓')

set형일 때: True    
x = {1,2}
y = {2,1}

if x == y:
    print('참')
else:
    print('거짓')


#################################
▣ 반복문
■ while문
조건이 참인동안에 while문을 반복해서 수행한다.

while 조건문:
    반복수행해야할 문장

# 문제
[문제29] 1부터 100까지 합을 구하세요. #반복 횟수가 중요하다. -> count 알고리즘 필요 # 그 안에서 1씩 증가하는 로직을 구현해야 한다. count 변수의 값을 어디엔가 누적 개념으로 놓아두고 반영해야 한다. 

i = 0   #count변수
result = 0  #누적합을 더하는 변수
while i <= 100:
    result +=i     # result = result + i 
    i +=1          # i= i +1
print(result)
    
i = 0   #count변수
result = 0  #누적합을 더하는 변수
while i <= 100:
    result +=i     # result = result + i 
    i +=1          # i= i +1
print(result)      # print를 들여쓰기 하면 각각의 result값을 출력한다.  
    
    
[문제30]단을 입력값으로 받아서 구구단을 출력하세요. 

dan = int(input('단을 입력해주세요: '))

i = 1
while i < 10:
    print('{}*{}={}'.format(dan,i,dan*i))
    i += 1
    

i = 1
while i < 10:
    print('%s*%s=%s'%(dan,i,dan*i))
    i += 1



# -*- coding: utf-8 -*-
"""
Created on Thu Sep  6 09:46:43 2018

@author: stu
"""
# loop 문에서 (while, if) 
break와 continue를 사용한다. 


#break: 무한loop에 빠져버리는 상황을 피하기 위해 사용
# break: 종료하는 보조제어문
i = 0
while 1:
    if i > 10:
        break
    else:    
        i += 1
        print('반복하는 값:%d'%i)

#cf. 무한 loop에 빠짐
i = 0
while 1:
    i += 1
    print('반복하는 값:%d'%i)
    
# 10, 9, 8, 7, .. 반복을 피하기 위해 break를 걸음 
i = 10
while 1: 
    print('반복하는 값: %d' %i)
    i -= 1
    if i == 0: 
        break       

#cf. 무한 loop에 빠짐
i = 10 
while 1:
    print('반복하는 값: %d'%i)
    i -= 1
    
# not i 를 사용하여 true를 만들어 break 걸기 
i = 10
while 1: 
    print('반복하는 값: %d' %i)
    i -= 1
    if not i: 
        break

# continue문은 while문으로 돌아가게 하는 문 
i = 0 
while i < 10:
    i += 1
    if i%2 == 0:  #짝수는 수행하지 않고 계속 while문을 수행하겠음
        continue
    print(i)


################
[문제30] 1부터 100까지의 3의 배수를 출력, 합을 구하세요. while문을 이용하세요.

#답1: 리소스를 많이 잡아 먹음 
i = 0
result = 0
while i < 100:
    i += 1 
    if i%3 == 0:
        print(i)
        result += i
        
print(result)

#답2: break가 없으면 102까지 출력될 수 있다. 
i = 0
result = 0
while i < 100:
    i += 3
    if i > 100:
        break
    else:
        print(i)
        result += i
        
print(result)


[문제31] 조건이 없는 상태에서 1부터 10까지 3,5를 제외한 합을 구하세요.
continue문, break문을 이용하세요.

# 조건이 없는 상태에서 : while 문에서  true를 생각하기 

i = 0
sum = 0

while True:
    i += 1
    if i == 3 or i == 5:
        continue
    if i > 10:
        break
    sum += i 

print(sum)    


[문제32] 리스트 변수에 18,2,3,1,4,5,7,8,9,10,11,15,16 값이 들어 있습니다. 짝수만 합을 구하세요.

i=0
x = [18,2,3,1,4,5,7,8,9,10,11,15,16]
result = 0

while i < len(x):
    if x[i]%2 == 0: 
        result += x[i]
    i += 1
    
print(result)

# 쌤답 
x = [18,2,3,1,4,5,7,8,9,10,11,15,16]
i=0
sum = 0 
while i < len(x):
    if x[i]%2 == 0:
        sum += x[i]
    i += 1

print(sum)


## 구구단을 만들면 subloop 구조로 풀어야 하기 때문에 while문 안에 while 문을 넣어야 함 
[문제33] 구구단을 생성하세요
   
i = 1
j = 1

while i <9:
    i += 1
    print ('---''{}''단---'.format(i))
    while j <= 9:
        print('%s * %s = %s'%(i,j,i*j))
        j += 1
    if j == 10:
       j = 1 
         

#하빈이 씬박한 답 ㅋ center와 /n
i=1
j=1

while i<9:
    i+=1
    x='*%d단*'%i
    print('\n %s'%x.center(6))
    
    while j<=9:
        print('{} * {} = {} '.format(i,j,i*j))
        j+=1
        if j==10:
            j=1
            break


# if 문으로 j를 리셋해줄 필요 없이 메인 while문에서 다시 선언해 주면 된다.
while i<9:
    i+=1
    j=1
    x='*%s단*'%i
    y=x.center(8)
    print('\n %s'%y)
    
    while j<=9:
        print('{} * {} = {} '.format(i,j,i*j))
        j+=1

        
#쌤답 
v_num = 2
while v_num <= 9:
    count = 1
    p_num = 0
    print ('-- %d단 --' %v_num)
    while count <= 9:
        p_num = v_num * count 
        print(v_num, '*', count, '=', p_num)
        count = count + 1 
    v_num = v_num + 1 


while v_nume <=9:
    count = 1
    p_num = 0
    print ('-- %d단 --' %v_num)
    while count <= 9:
        p_num = v_num* count
        print (v_num, '*', count, '=', p_num)
        count = count +1 
    v_num = v_num + 1 
                

####### 오후 시간 #########
[문제34] 리스트 변수에 12,3,21,4,5,7,33,2,18,9,10,31,15,16 값이 들어 있습니다. 최대값을 구하세요.
x = [12,3,21,4,5,7,33,2,18,9,10,31,15,16]
i = 0
j = 0

while not i:
    j+1
    if x[i]-x[j] > 0:
        print(x[i])
    else:
       x[i]-x[j] < 0: 
        i+=1
        print(x[i])
    

큰수-작은수 양수
else 작은수-큰수 음수 

#쌤답1 - 오류 
x = [12,3,21,4,5,7,33,2,18,9,10,31,15,16]
i = 1 
max = x[0]

while i < len(x):
    if max > x[i]:
        max = x[i]
        i +=1

print(max)
  
# 쌤답 2 - 잉? 답이 이상함 
x = [12,3,21,4,5,7,33,2,18,9,10,31,15,16]
i = 0
max = x[0]
cn =len(x)
while i < cn:
    i += 1
    if i == cn:
        break
    else:
        if max < x[i]:
            max = x[i]
        i += 1

print(max)


# 쌤답 3
x = [12,3,21,4,5,7,33,2,18,9,10,31,15,16]
i = 0
max = x[0]
cn =len(x)
while i < cn:
    if max < x[i]:
        max = x[i]
    i += 1 

print(max)


[문제35] 리스트 변수에 12,3,21,4,5,7,33,2,18,9,10,31,15,16 값이 들어 있습니다. 최소값을 구하세요.
x = [12,3,21,4,5,7,33,2,18,9,10,31,15,16]
i = 1 
min = x[0]
while i < len(x):
    if min > x[i]:
        min = x[i]
        
    i += 1

print(min)    

#########################
■ for 문
for 반복변수 in (리스트, 튜플, 문자열):
    반복수행해야할 문장 

for i in [1,2,3,4,5]:
    print(i)

x = [1,2,3,4,5]
for i in x:
    print(i)


x = (1,2,3,4,5)
for i in x:
    print(i)
    
for i in ['a','b','c']:
    print(i)
    
x = ['sql', 'plsql', 'r', 'python']
for i in x:
    print(i)
    
for i in '대한민국':
    print(i)

x = [(1,2), (3,4), (5,6)]    
for (a, b) in x:
    print(a+b)


#############################################333
[문제36] 학생들의 점수가 90,55,63,78,80 점이 있습니다.
60점 이상이면 합격, 60점 미만이면 불합격 출력해 주세요.

x = [90,55,63,78,80]
for i in x:
    if i >= 60:
        print ('합격')
    else:
        i < 60
        print('불합격')

######################################################
■ range 
range(시작점, 끝점-1, 간격)
list(range(1,11,1))
list(range(0,101,1))
list(range(0,101,5))
range 시작점을 쓰지 않으면 0부터 시작한다. 



for i in range(1,11):
    print(i)

for i in range(1,11,2):
    print(i)

[문제37] 1부터 100까지 합을 구하세요.(for 이용)

result =0
for i in range(1,101):
   result += i
print(result) 



[문제38] 1부터 10까지 출력하세요. 단 4, 8은 제외(for 이용)??

for i in range(1,11):   
    if i != 4 and i != 8:
        print(i)

#쌤답
for i in range(1,11):
    if i == 4 or i == 8:
        continue
    print(i)


[문제39] 화면과 같이 출력하세요.(for 이용)

가로의 숫자를 입력하세요 : 5
세로의 숫자를 입력하세요 : 5
★ ★ ★ ★ ★ 
★ ★ ★ ★ ★ 
★ ★ ★ ★ ★ 
★ ★ ★ ★ ★ 
★ ★ ★ ★ ★ 

for i in range(1,6):
    print('★'*5)

#쌤답    
a = int(input('가로의 숫자를 입력하세요: '))
b = int(input('세로의 숫자를 입력하세요: '))
for i in range(b):
    print('★'*a)

   
[문제40] 구구단을 출력하세요.(for 이용)

for i in range(2,10):
    print('\n---',i,'단---')
    for j in range(1,10):
        print('%s * %s = %s'%(i,j,i*j))

#쌤답
for i in range(2,10):
    print("---{}단---".format(i))
    for j in range (1,10):
        print("{} * {} = {}".format(i, j, i*j))

    
        
[문제41] 구구단을 만드세요. 

2단에서 9단까지만 입력하세요, [0은 구구단 전부를 출력합니다.]: 

    # 내 답 다시 확인해보기 
x = input()
range(2,10)

for i in range(2,10):
    if int(x)==0:
        print('\n---',i,'단---')
        for j in range(1,10):
            print('%s * %s = %s'%(i,j,i*j))
    else: 
        print('%s * %s = %s'%(x,i,int(x)*i))


if int(x)==0:
    for i in range(2,10):
        print('\n---',i,'단---')
        for j in range(2,10):
            print('%s * %s = %s'%(i,j,i*j))
elif 2 <= int(x) <= 9:
    print('\n---',x,'단---')
    for j in range(2,10):
        print('%s * %s = %s' %(x,j,int(x),j))


# 쌤답
m = int(input('2단에서 9단까지만 입력하세요. [0은 구구단 전부를 출력합니다.]: '))

if m == 0:
    for i in range(1,10):
        print("---{}단---".format(i))
        for a in range (1,10):
            print(i, "x", a, "=", i*a)
elif 2 <= m <= 9:
    print("---{}단---".format(m))            
    for i in range(1, 10):
        print(m, "x", i, "=", m*i)
        
   
     
[문제42]lst 변수에 a,b,c,d값이 있습니다. for문을 이용하여 아래화면과 같이 출력하세요.


0번 a값이 있습니다.
1번 b값이 있습니다.
2번 c값이 있습니다.
3번 d값이 있습니다.


lst = ['a','b', 'c', 'd']
for i in range(len(lst)):
    print('{}번 {}값이 있습니다.'.format(i,lst[i]))

#별도의 method 
for i, name in enumerate(lst):
    print('{}번 {}값이 있습니다.'.format(i, name))

■ enumerate: list변수 안에 인덱스와 인덱스 값을 바로 리턴해 주는 method 
(range처럼 나오기 때문에 객체형식으로 나온다. 인자값 두개(인덱스, 인덱스값)을 리턴해준다.)


#################
[문제43] 1부터 9까지 x 리스트 변수에 입력하세요.
y변수는 x 변수의 값을 2곱한 값으로 입력해주세요.

x = list(range(1,10,1))
# x= range(1,10) 만 써도 됨
y = []
for i in x:
   y.append(2*i)
y    

    
[문제44] apple, banana, orange 리스트 변수에 값을 입력하시고
         이 값들의 길이를 출력해주세요.

x = ['apple', 'banana', 'orange']
result=0

# 문제를 잘못 이해했네요... 전체 문자숫자를 구하는 줄~
for i in range(len(x)):
    result += len(x[i])
print(result)


for i in range(len(x)):
    print(len(x[i]))



#쌤답
for i in x:
    print (len(i))

[문제45] 변수에 아래와 같이 들어 있습니다. 아래처럼 결과를 출력하세요.

lst1 = [1,2,3]
lst2 = [4,5,6]

출력결과

[4, 5, 6, 8, 10, 12, 12, 15, 18]


lst3=[]

for i in lst1:
    for j in lst2:
        lst3.append(i*j)
     
lst3

#쌤답
for x in lst1:
    for y in lst2:
        print(x*y, end=',')

#end: option으로 사용 가능

lst3=[]

for x in lst1:
    for y in lst2:
        lst3.append(x*y)
     
lst3



###########################################################
#다르게 풀기
[문제43] 1부터 9까지 x 리스트 변수에 입력하세요.
y변수는 x 변수의 값을 2곱한 값으로 입력해주세요.

x = list(range(1,10,1))
# x= range(1,10) 만 써도 됨
y = []
for i in x:
   y.append(2*i)
y    
###################################

■ 리스트 내장객체 
(문제 43번과 관련하여 기존에 리스트 변수를 정의하고, append하지 않고 바로 값을 얻어내는 방법)
[ 표현식  for 반복변수 in 반복가능한 객체]
z = [ i*2 for i in x]
z

# 리스트 내장객체를 통해 문제 44번, 45번풀기 
[문제44] apple, banana, orange 리스트 변수에 값을 입력하시고
         이 값들의 길이를 출력해주세요.

x = ['apple', 'banana', 'orange']

[len(i) for i in x]


[문제45] 변수에 아래와 같이 들어 있습니다. 아래처럼 결과를 출력하세요.

lst1 = [1,2,3]
lst2 = [4,5,6]

출력결과

[4, 5, 6, 8, 10, 12, 12, 15, 18]

lst3 = [i*j for i in lst1 for j in lst2] #for i in lst1 : main for문 / for j in lst2: subfor 문 

################################################ 
[문제 46] 1부터 100까지 값중에 짝수만 x변수에 입력해주세요. 
#1번방법
x = []
for i in range(1,101):
    if i%2 == 0:
        x.append(i)

#2번방법: 리스트 내장객체 안에 if문도 내장할 수 있다. 
z=[i for i in range(1,101) if i%2==0]
z


# -*- coding: utf-8 -*-
"""
Created on Fri Sep  7 09:46:23 2018

@author: stu
"""

###################################################################################
[문제47] 튜플변수에 사과, 귤, 오렌지, 배, 포도, 바나나, 자몽, 키위, 딸기, 블루베리, 망고를 입력하시고 
과일이름중에 세글자 이상인 과일만  fruit_lst변수에 입력해주세요.

fruit_lst=()

fruit = ('사과', '귤', '오렌지', '배', '포도', '바나나', '자몽', '키위', '딸기', '블루베리', '망고')

#답1: tuple로 했을 때 
for i in fruit:
    if len(i) >= 3:
        fruit_lst = fruit_lst+(i,)
#답2:
fruit_lst= [i for i in fruit if len(i) >= 3]


#쌤답1
fruit = ('사과', '귤', '오렌지', '배', '포도', '바나나', '자몽', '키위', '딸기', '블루베리', '망고')
fruit_lst = []
for i in fruit:
    if len(i) >= 3:
        fruit_lst.append(i)
print(fruit_lst)

#쌤답2
fruit_lst2 = [i for i in fruit if len(i) >=3]
print(fruit_lst2)


[문제48] 과일판매 현황을 dictionary 변수로 생성하세요. 과일 이름을 키로 하고 수량은 값으로 표현한후
과일이름만 대문자로 출력해주세요.

   
apple  100 , banana  300, orange  300

dictionary = {'apple':'100' , 'banana':'300', 'orange':'300'}
for i in dictionary.keys():
    print(i.upper())

# 쌤답1
dic = {'apple':'100' , 'banana':'300', 'orange':'300'}
for i in dic.keys():
    print(i.upper(), end=',')

# 쌤답2
for i,v in dic.items():
    print(i.upper()+':'+str(v), end=',\0') #format문자 코드를 쓰지 않고 변수에 있는 문자를 붙여서 출력할 경우, 문자와 숫자가 같이 출력 될수 없다. 따라서 현재 문자와 숫자 이기때문에 오류가 난다. 따라서 str(v)를 해서 string으로 변형해야 한다. 

# 쌤답 3
[i.upper() for i in dic.keys()]


# 쌤답 4
[[i.upper(), v] for i, v in dic.items()] # dictionary 모양처럼 해야 오류가 나지 않는다. [i.upeer(), v]


###### 
cf.dictionary형은 빈도수 체크할 때 많이 사용한다. R처럼 table을 만들 수 없기 때문에 dictionary를 이용하여 빈도수를 만들어야 한다. 

▣ 함수
- 기능의 프로그램
- 반복되는 코드를 하나로 묶어서 처리하는 방법 
cf. class: 함수를 모아 놓은 것, /plsql: package는 class와 비슷한 개념으로 함수를 모아 놓은 것을 의미함, 유지,관리,보수가 편리, 오버로드 기능을 지원 

def 함수이름(인수, 인수, 인수...):
    수행할 문장....(수행해야할 로직)
    
    [return 값]
    
        #plsql에서 retrun은 의무적이었지만, r과 python은 return값은 option이다.
        #python의 return문은 종료의 의미 
        #즉, return을 쓰게 되면 값이 없는 return문을 종료하는 의미이다. 
    

예시)
# 예시 1   
함수이름()
    
def message():
    print('오늘 하루도 행복하자')


message()

#예시2
def message(x): #x로 입력값을 만듦
    print('%s 화이팅'%(x))

message('홍창식')

#예시 3
def message():
    print("매일 행복하자")
    return "happy"

word = message()
print(word)


################################################################
[문제49] 함수에 두개의 숫자를 입력값으로 받아서 값을 비교하는 프로그램을 작성하세요.(출력하는 형식으로 만들기) 
#인수값 x, y를 넣었을 때 비교하는 프로그램 

#답1
def num_compare(x,y):
    if x - y == 0:
        print('x와 y는 같다')
    elif x - y > 0:
        print('x가 y보다 크다')
    elif x - y < 0:
        print('x가 y보다 작다')

num_compare(10,5)

#답2 
def num_compare(x,y):  
    if x>y:
        print('{}가 {}보다 크다'.format(x,y))
    elif x<y:
        print('{}가 {}보다 작다'.format(x,y))
    else:
        x==y
        print('{}와 {}는 같다'.format(x,y))


[문제50] 두 인수값을 받아서 합한 값을 리턴해주는 sum함수를 생성하세요.

def sum(x,y):
    return x+y

z = sum(1,2)
z
 
################################################################
■ 함수에서의 가변 인수값: * 
가변으로 변하는 인수값을 어떻게 처리할까? cf.plsql: 가변값을 받을 수 있는 record 변수를 넣어서 package에 넣어 수행함
sum(1,2,3,4,5)
sum(1,2,3) 

형식)
def 함수이름(*인수):
    수행할 문장 

예시) 인수(형식매개변수) x는 가변으로 사용할 수 있음 / x개가 여러개 들어갈 경우 for문을 생각해야 한다. for i in 반복해야할 list변수 
def sum(*x):
    total = 0   #누적되어야 할 값을 넣어야 할 변수가 필요하니 local변수를 선언한다. 
    for i in x:
        total += i
    return total

z=sum(1,2,3,4,5)
print(z)
sum(1,2,3)


################################################################
[문제51]
cal('sum', 1,2,3,4,5)
cal('multiply',1,2,3,4,5)

def cal(arg1, *arg2):    #크게 보면 두개의 인수, arg1에는 sum과 multiply만 들어오고(문자만 들어오고), arg2는 가변으로 받을 경우, arg2앞에 *을 넣어주면 된다.
    if arg1 == 'sum':
        total = 0
        for i in arg2:
            total += i
        return total
    elif arg1 == 'multiply':
        total = 1
        for i in arg2:
            total *= i 
        return total

#쌤답 
def cal(arg1, *arg2):    #크게 보면 두개의 인수, arg1에는 sum과 multiply만 들어오고(문자만 들어오고), arg2는 가변으로 받을 경우, arg2앞에 *을 넣어주면 된다.
    if arg1 == 'sum':
        total = 0
        for i in arg2:
            total += i
    elif arg1 == 'multiply':
        total = 1
        for i in arg2:
            total *= i 
    return total

#쌤답: 혹시 문자열을 대문자로 쓰거나 그럴 경우, lower로 바꿔주어 if에서 비교하는 것이 좋다. 문자값 비교시 주의합시다! 
def cal(arg1, *arg2):    #크게 보면 두개의 인수, arg1에는 sum과 multiply만 들어오고(문자만 들어오고), arg2는 가변으로 받을 경우, arg2앞에 *을 넣어주면 된다.
    if arg1.lower() == 'sum':
        total = 0
        for i in arg2:
            total += i
    elif arg1.lower() == 'multiply':
        total = 1
        for i in arg2:
            total *= i 
    return total

cal('SUM', 1,2,3)


##############################################################################################
[문제52] 여러 숫자를 인수값으로 받아서 합과 평균을 출력하는 aggF함수를 생성하세요.

aggF(1,2,3,4,5,6,7,8,9,10)
  
합 :  55
평균 : 5.5 

def aggF(*x):
    result = 0
    for i in x :
        result += i
    print('합 : ',result)
    print('평균 : ',result/len(x))

##############################################################################################
▣ return문: 


■ #리턴문은 여러 번 쓸 수 있되, 첫번째 return문만 수행하고 끝남
def f1(x,y):
    return x+y
    return x*y

z = f1(2,3)
print(z)

■ 여러 번의 return문을 쓰려면 ,(콤마)를 이용해서 return하고자 하는 값을 연결

def f1(x,y):
    return x+y, x*y

sum, mul = f1(2,3)
print(sum, mul)


# [문제52]을 return으로 풀기 
[문제52] 여러 숫자를 인수값으로 받아서 합과 평균을 출력하는 aggF함수를 생성하세요.

aggF(1,2,3,4,5,6,7,8,9,10)
  
합 :  55
평균 : 5.5 

def aggF(*arg):
    total = 0
    for i in arg:
        total = total+i
    avg = total/len(arg)
    print('sum=%dm avg=%0.2f'%(total, avg))   #format문자 소숫점 제어하기: %0.2f 소수 2번째 자리까지 표시하기 
    return total, avg

sum, avg = aggF(1,2,3,4,5,6,7,8,9,10)
print(sum, avg)


■ 값이 없는 return문은 종료 시킴
def f2(x,y):
    if y == 0:
        return
    print(x/y, " 값 입니다.")

f2(4,2)
f2(4,0) #값이 없는 return문은 종료임


■ 형식매개변수에 기본값 지정 가능    

def f3(name, age, gender='M'):      #gender라는 매개변수에 M이라는 기본값 지정 
    print("이름은 ", name)
    print("나이는 ", age)
    if gender == 'M':
        print("남자")
    else:
        print("여자")

# 원래 형식매개변수에 맞게 매개변수를 넣어야 하는데 넣지 않으면 오류가 발생하지만 기본값을 지정하여 오류를 피할 수 있다.
f3("홍길동", 30)                   #gender값을 입력하지 않으면 기본으로 M
f3("송하빈", 20, "F")

■ 전역변수(global): 프로그램이 종료될때까지 어디서든지 사용할 수 있는 변수(일반적으로 기존에 사용했던 변수들이 global변수에 해당한다.)
■ 지역변수(local): 함수 안에서만 사용하는 변수 

#x: global variable
x = 10

#x: local variable: 이 함수 안에서만 쓰이기 때문에
def f4(x):      # x는 매개변수: f4에서만 사용되는 매개변수 
    print("x 변수 값은", x)     #
    x = 20      #여기서 x는 local 변수
    print("x 변수 값은", x)

f4(x)                           #매개변수, 로컬변수 출력
print(x)                        #10출력(global variable)

#함수 밖에 있는 global 변수(x=10)를 함수안에서 global 키워드를 사용해서 global 변수 값을 x=20으로 변경하는 것 
x = 10
def f5(arg):
    global x                  #global 키워드를 이용해 함수 안에서 global 변수를 바꿔 사용함
    x = 20                    #여기서 x는 global 변수가 된다. 
    print('x 변수 값은', x)

f5(x)
print(x)

#############################################################################
[문제53] 입력값을 누적해서 더하는 함수를 작성하세요.

>>> print(add(2))
2

>>> print(add(8))
10

result = 0
def add(x):
    global result
    result += x
    return result
    
print(add(2))
print(add(8))

#쌤답 
total = 0
def add(arg):
    glbal total
    total += arg
    return total

print(add(2))
print(add(8))

dir()

del total

[문제54] 아래와 같이 변수에 값이 들어 있습니다. 
exchang함수에 x변수에 값을 넣으면 y로 변환하는 함수를 만드세요.

x = ["귀도","반","로섬"]
y = ["Guido","van", "Rossum"]

# 문제를 잘못 이해함.... ;;;
y = []
def exchange(x):
    for i in x: 
        if i == "귀도":
            y.append("Guido")
        elif i == "반":
            y.append("van")
        elif i == "로섬":
            y.append("Rossum")
        

exchange(x)
print(x)

#쌤답   - 문제 이해를 위한 설명 먼저 보고 비교하기와 답을 비교하기
x = ["귀도","반","로섬"]
y = ["Guido","van", "Rossum"]

def exchange(x):
    x = x[:]
    for i in range(len(x)):
        x[i] = y[i]
    print(x)

exchange(x)
print(x)
print(y)

# 비교하기
x = ["귀도","반","로섬"]
y = ["Guido","van", "Rossum"]

def exchange(x):
    x = x
    for i in range(len(x)):
        x[i] = y[i]
    print(x)

exchange(x)
print(x)    # x = x[:]를 안하기 때문에 x[i] = y[i]로 했을 때 y[i]로 반환된 값이 x[i]로 들어가기 때문에 print(x)에서 x가 아닌 y값으로 나오는 것임
print(y)

#54문제 이해를 위해 
◆ copy: 메모리가 같은 (주소값이 같은) 복제: b
a = [1,2,3]
b = a               #변수에 copy를 하면 메모리를 함께 사용하기 때문에 a.append(4)를 한 다음 print(a,b)를 하게 되면 b값도 a값에 4가 붙은 값까지 함께 출력된다. 

print(a,b)
print(id(a),id(b))  #메모리 주소 출력값; 메모리 주소 출력값이 같기 때문에 똑같이 사용하는 것임 
#print(id(a),id(b))
121778376 121778376

a.append(4)     
# print(a,b)
print(id(a),id(b))
[1, 2, 3, 4] [1, 2, 3, 4]
121778376 121778376

◆ deepcopy를 하는 방법(1): 물리적으로 다른 복제: c
c = a[:]            #복제를 하되 물리적으로 복제(따로 복제)하기 위해서는 c = a[:] 를 이용해야 한다. 즉, a에서 인덱싱 전체를 보겠다는 :(콜론)을 사용하여 복제해야 물리적으로 다르게 복제한다. 이래야 바깥쪽에 있는 변수에 영향을 주지 않는다.
print(a,b,c)
print(id(a),id(b),id(c))
#print(a,b,c)
print(id(a),id(b),id(c))
[1, 2, 3, 4] [1, 2, 3, 4] [1, 2, 3, 4]
121778376 121778376 121781000

a.append(5)
print(a,b,c)
print(id(a),id(b),id(c))
#print(a,b,c)
print(id(a),id(b),id(c))
[1, 2, 3, 4, 5] [1, 2, 3, 4, 5] [1, 2, 3, 4]
121778376 121778376 121781000

◆ deepcopy를 하는 방법(2): 물리적으로 다른 복제: d
import copy

d = copy.deepcopy(a)
print(id(a),id(d))
#print(id(a),id(d))
121778376 152096968

a.append(6)
print(a,d)
#print(a,d)
[1, 2, 3, 4, 5, 6] [1, 2, 3, 4, 5]

 
◆ 인덱스에 있는 값을 복제할 때 메모리 주소는 달라진다. 
a = [1,2,3]
b = a[0]    #변수를 0번 인덱스에 있는 값으로 b를 만들라고 했기 때문에 b가 a의 모든 값을 가져가지 않기 때문에 a와 b의 메모리 주소가 다르게 나온다. 
print(id(a),id(b))

#print(id(a),id(b))
152108552 1616276544

#############################################################################
[문제55]약수를 구하는 divisor 함수를 생성하세요.

1이상의 숫자를 입력하세요: 100
[100, 50, 25, 20, 10, 5, 4, 2, 1]

#내답
x = int(input("1이상의 숫자를 입력하세요: "))
def divisor(x):
    x2 = x
    x1 = [] 
    #x1.append(x) --- 나의 오류 
    while x > 0:
        if x2%x == 0:
            x1.append(x)
        x -= 1
    return(sorted(x1))

print(divisor(x))     


# 쌤답 
print("어떤 정수를 나누어 떨어지게 하는, 0이 아닌 정수이다. 음의 정수도 약수가 되지만 일반적으로 양의 약수만 다룬다")

#답1
num1 = int(input("1이상의 숫자를 입력하세요: ") )

def divisor(num1):
    for i in range(1,num1+1):
        if(num1%i == 0):
            print(i,end=" ")
            
divisor(num1)

#답2: 반으로 값을 나누어 약수 구하기
num1 = int(input("1이상의 숫자를 입력하세요: "))

def divisor(num1):
    num2 = int(num1/2)
    num3 = []
    num3.append(num1)
    while num2 >= 1:
        if num1 % num2 == 0:
            num3.append(num2)
        num2 -= 1
    return(sorted(num3))    
    #return(sorted(num3,reverse=False))
 
print(divisor(num1))


# -*- coding: utf-8 -*-
"""
Created on Mon Sep 10 09:45:21 2018

@author: stu
"""

[문제56] 여러 값을 동일한 변수에 순차적으로 저장할수 있는 용도의 변수 타입과 부호는 ?
list, []

[문제57] x 리스트 변수에 1, 3, 5, 7, 9 를 입력하세요
x = [1,3,5,7,9]  


[문제58] x 변수에 타입을 확인하세요.
type(x)


[문제59] x변수에 첫번째값을 확인해주세요
x[0]

[문제60] x변수에 제일뒤에 값을 확인해주세요
x[-1] 
x[len(x)-1]

[문제61] x변수에 10를 제일 뒤에 추가해주세요.
x.append(10)
x

[문제62] x변수에 있는 값들중에 10을 삭제해주세요
x.remove(10)
#x.pop()
x


[문제63] x변수에 1번색인위치에 2를 입력하세요.
x.insert(1,2)   #1번색인 위치에 2를 추가 입력 
#x[1]=2 변환임 
x

[문제64] x변수에 1번색인값을 제거해주세요.
x
x.pop(1)
#del x[1]
x


[문제65] x 변수에 첫번째 부터  세번째까지 값을 출력해주세요.
x[0:3]   
x[:3]

[문제66] x 변수에 제일뒤에서 두개 값을 출력해주세요.
x[-2:]
#x[len(x)-2:len(x)]


[문제67] x 변수를 y변수에 대입한 후 y변수에 11을 추가한 후 x값도 확인 한 후 분석해주세요.
x
y = x
y
y.append(11)
x

id(x), id(y) #메모리를 같이 참조하고 있음 / #메모리를 다르게 참조할 경우, :(콜론)을 사용하든지 deepcopy를 사용해야함 


[문제68] x변수를 z변수에 복사하지만 고유한 변수로 생성해주시고 z변수에 13을 추가 해주세요.
z = []
z = x[:]
#z[:] = x
id(z), id(x)
z.append(13)
z

[문제69] 
    x = [1,2,3]
    y = [4,5,6]
    y변수에 값을 x 변수에 넣어주세요.

id(x)
id(y)

x.extend(y)
x    #x변수의 메모리는 달라지지 않는다.
id(x)

#x=x+y     #x변수의 메모리가 달라
x
    
[문제70] x 변수에 1번 인덱스의 값을 제거해주세요.
del x[1]
x

[문제71] x변수에 1번 부터 3번 인덱스를 제거해주세요.
del x[1:4]  
x

[문제72] 중첩리스트를 이용할때 첫번째 항목의 첫번째 항목의 값을 추출해주세요.
x = [[1,2,3],[4,5,6]]
x[0][0]
 

[문제73] 리스트형과 비슷하지만 요소의 값을 변경 할 수 없는 타입과 부호는 ?
tuple, ()

    
[문제74] 키, 값을 저장하는 데이터 타입과 부호는 ?
dictionary {} {'':''}   

#{}은 set형과 같다. set은 중복된 값을 제거해준다.(set: intersection, union, difference)
     
[문제75]  아래와 같은 내용을 변수에 입력해주세요. 변수이름은 dict

           이름 : '홍길동'
           나이 : 30
           직업 : '파이썬개발자'
           
dict = {'이름': '홍길동', '나이':'30', '직업':'파이썬개발자'}
dict
    
[문제76] dict변수 키를 출력하세요.
dict.keys()    


[문제77] dict변수 값을 출력하세요.
dict.values()


[문제78] dict변수의 키, 값을 출력해주세요.
dict.items()
 

[문제79] dict변수의 이름만 출력해주세요.
dict.get('이름')


[문제80] dict변수의 주소 = '서울' 추가해주세요
dict['주소']='서울'
dict
    
[문제81]  dict변수의 나이값을 32 수정하세요.
dict["나이"]=32
dict

#############################################################################################3
▣ 재귀호출
- 자기 자신을 다시 호출한다. 
- 함수 안에서 내 함수를 다시 호출 하는 과정 -> 반복문 필요
- 반복문 + stack 구조 

# que: 집어 넣는대로 들어가는 구조; 처음 들어간 것이 제일 먼저 나가는 구조
# push: stack 구조에 쌓아서 놓는 구조 
# stack구조: 제일 밑에 있는 것을 뽑아내고 싶어도 위에 있는 것부터 pop을 해야함(덜어내야함)

■ stack
FILO(First In Last Out): 제일 처음에 들어간 것이 나중에 나간다. :선입후출
LIFO(Last In First Out): 나중에 들어간 것이 제일 먼저 나간다.: 후입선출 

■ push: push 스택의 구조상 마지막 데이터 위치에 입력된다. 

■ pop: 마지막 데이터 위치에서 데이터를 꺼내는 작업(삭제)

■ 재귀호출의 구조  
-stack []
-push 하면 stack 변수에 값을 넣는다.
-pop 하면 stack 변수에 값을 삭제한다.

stack []
push(1)
push(2)
push(3)

pop(3)    #제일 마지막에 있는 것이 삭제 됨 
pop(2)
pop(1)


stack=[]
def push(n):
    global stack    #어디서나 stack을 사용할 수 있도록 global 변수로 만듦 
    stack.append(n)
    
def pop():
    global stack
    if len(stack)==0:
        return Non 
    return stack.pop()

push(1)    #1이 제일 먼저 들어감
push(2)    #1다음 2가 들어감
push(3)    #2다음 3이 들어감 

pop(3)


# stack을 que를 만들때  - 하노이탑 생각하기 : 새로운 변수를 만들어 stack을 하기 
3을 밑으로 들어가고 2가 그 다음, 1이 마지막으로 들어가게 된다. 

#일상생활에서 stack 알고리즘 
1) 하나의 페이지 안에 지금까지의 페이지가 쌓아였기 때문에 첫번째 페이지 부터 마지막 페이지를 보는 것
2) 문서작업에서 되돌리기 
3) 옷장정리 

#재귀호출: factorial (재귀함수로 쓰이고 있음)

▶ factorial 함수
n! = n * (n-1) * (n-2) *.........* 2 * 1
n! = n * (n-1)!

예시)
5! = 5*4*3*2*1
5! = 5*4!
   = 5*4*3!
   = 5*4*3*2!
   = 5*4*3*2*1!
   = 5*4*3*2*1
0! = 1

factorial 공리                         #함수식이 됨 
             n * factorial(n-1) n>=1   #조건 제어문이 됨 
fatoria(n) = 1                  n =0

- 재귀호출문을 통해서 fatorial 계산 가능     #프로그램이 simple하게 할 수 있음
- 그러나 반복문을 통해서 fatorial 계산 가능  #가끔 재귀함수를 사용하게 될 때 보다 반복문 사용이 더 나을 때도 있다. 
- 재귀호출: 반복문 + stack  
    -> 문제점: 반복문 때문에 무한 loop에 빠질 수 있는 위험이 있다. 
    -> 해결책: 따라서 끝내는 작업(끝내주는 시점)을 해야 한다! 
    

factorial 반복문  
def factorial(n):
    f = 1
    for i in range(n,0,-1):
        f *= i
    return f

factorial(5)
factorial(1)
factorial(0)


factorial 재귀호출
def factorial(n):
    if n == 1 or n == 0 :
        return 1
    return n * factorial(n-1) 


# factorial 재귀호출    
    왜 stack 구조가 될까?  #함수 구조이기 때문에 담아놔야하는 구조가 됨 (stack )
    factorial(5)        <push>: stack에 쌓아놓기 
    5 * facotrial(4)    #1) 곱셈은 상수일 때 가능, 그러나 facotrial(4)에 해당하는 값을 모른다. 할 수 없이 어딘가에 쌓아놔야 함. 
                        #2) factorial(4)는 4*factorial(3) -> factorial(3)을 쌓아 놓음
                        #3) factorial(3)는 3*factorail(2) -> factorial(2)을 쌓아 놓음
                        #4) factorial(2)는 2*factorial(1) -> factorial(1)을 쌓아 놓음
                        #3) factorial(1)는 1*factorail(0) -> factorial(0)을 쌓아 놓음
                        #4) factorial(0) 은 1                                         
                        #5) factorial(0) 은 1 -> 이 값을 받환 -> factorial(1)=1 
                        #6) factorial(1) 은 1 
                        <pop>: 계산
                        #4) f(0) = 1
                        #5) f(1)=1*f(0) 
                        #6) f(1)= 1
                        #7) f(2)=2*1
                        #8) f(3)=3*f(2)
                        #9) f(3)=3*2*1
                        #10) f(4)=4*f(3)
                        #11) f(4)=4*3*2*1
                        #12) f(5)=5*f(4)
                        #13) f(5)=5*4*3*2*1                        
                        

####################################################################################
공약수
18과 24의 공약수 
18 = [1, 2, 3, 6, 9, 18]
24 = [1, 2, 3, 4, 6, 8, 12, 24]
공약수: [1,2,3,6]
최대 공약수: 6

소인수분해
2 | 18   24
3 |  9   12
  -----------   
     3    4
최대공약수: 6
최소공배수: 2 * 3* 3 *4 


■ 유클리드 알고리즘
- 주어진 두 수 사이에 존재하는 최대공약수(GCD(Greatest Common Divisor))를 구하는 알고리즘 
1. 두 수 m, n(m > n) 입력으로 들어온다.
2. n이 0이라면 m을 출력하고 알고리즘은 종료 
3. m이 n으로 나누어 떨어지면, n을 출력하고(최대공약수) 알고리즘은 종료
4. 그렇지 않으면 m을 n으로 나눈 나머지를 새롭게 m에 대입하고 m과 n을 바꾸고 다시 3번으로 돌아간다.

[문제82] 최대공약수를 재귀함수로 구현해보세요.
def gcd(m, n):
    if n == 0 :
        return m
    elif m%n ==0:
        return n
    elif m%n != 0 :
        return gcd(n, m%n)
    
gcd(6,3)
gcd(24,18)

#아름이 답
def gcd(m, n):
    if n == 0 :
        return m
    elif m%n ==0:
        return n
    else:
        m= m%n
        return gcd(n,m)
######################
# 쌤답: 
def gcd(x,y):
    if (x<y):
        x, y = y, x    #switching: 기존의 x값을 y로, y값을 x로 바꾸는 방법
    while (y!=0):
        n = x%y
        x = y;
        y = n;
    return x

# 쌤답; 재귀호출 단계    
gcd(24,18)
    24%18 -> 6, x=18, y=6 (18,6)
    18%6 -> 0,  x=6, y=0 (6,0)


# 쌤답- 재귀호출 사용
def gcdFn(x,y):
    if y==0:
        return x
    return gcdFn(y, x%y)

    18%6  (6,0)  
    24%18 (18,6) ↑
24  18%24 (24,18)↑
gcdFn(18,24)     ↑


############################################################################
[문제83] stddev(2,3,1,7) 표준편차를 구하세요. stddev함수를 생성하세요.

평균 = 관측값의 합 / 데이터수
편차 = 관측값 - 평균
편차 제곱합 = (편차**2)+(편차**2)
분산 = 편차제곱합/데이터수(자유도)
표준편차 = math.sqrt(분산)

import math
math.sqrt(분산)

#method 안에 method 가능함 

def stddev(*x) :
    total = 0
    for i in x:
        total += i 
        avg =total/len(x)
        dev_total = 0
    for i in x:
        dev_total += ((i - avg)**2)
        dev = dev_total/len(x)
    return math.sqrt(dev)
            
        
# 쌤답 - method 안에 method 사용 가능 / 밖에서 method mean, variance를 사용할 수 없음 
def stddev(*arg):
    def mean ():
        return sum(arg)/len(arg)
    
    def variance(m):
        total = 0
        for i in arg: 
            total += (i-m)**2
        return total/(len(arg)-1)   #R에서도 자유도 n-1 
    v = variance(mean())
    return math.sqrt(v)


■ module만들기 
# ==> 계속 써야 하는 함수는 object 단위로 호출하여 사용하면 편리하다. 
# ==> 즉, script를 복사-붙여넣기를 하지 않고 file로 떨어뜨려 놓고 import하는 것이 편리하다. (object단위로 호출 가능)
# c:\python\stddev.py 로 stddev script를 object단위로 떨어뜨려 놓기 (메모장에 복사하기 붙여넣기)

# path가 걸려져 있는 것을 확인하기 
물리적인 directory를 사용할 수 있도록 path를 걸어야 한다. 
import sys
sys.path
# 내가 만든 directory를 path에 추가하기 
sys.path.append('c:\\python')
sys.path
# stddev 파일을 불러 들이기 
import stddev
# import된 것 확인하기 
dir()
# stddev: module 이름이 됨 
# module 사용하기 : module이름.method이름 
stddev.stddev(2,3,1,7)

#항상 module 이름을 사용하기 귀찮다면 파일이름 중에 stddev라는 모듈을 import해서 계속 사용한다는 의미
from stddev import *
stddev(2,3,1,7) #method만 사용하면 됨.

#내가 만든 directory에 path만들기 
import sys
sys.path.append('C:\\mypython')
sys.path

#잘못된 path 지우기
sys.path.remove('C:\\mypython')

#########################################
[문제84] stats 모듈에 평균, 분산, 표준편차함수를 사용할수 있는 프로그램을 생성하세요.

>>> import stats
>>> stats.mean(1,2,3,4,5)
3.0
>>> stats.variance(1,2,3,4,5)
2.5
>>> stats.stddev(1,2,3,4,5)
1.5811388300841898

#stats에 각 함수를 포함하도록 하기

########## c:\python\stats.py 답
import math

def mean (*arg):
    return sum(arg)/len(arg)

def variance(*arg):
    total = 0
    m = mean(*arg)
    for i in arg: 
        total += (i-m)**2
    return total/(len(arg)-1)


def stddev(*arg):
    return math.sqrt(variance(*arg))

#cf. 만약에 *arg 로 넣기 싫다면 
def mean(arg):
    return sum(arg)/len(arg)

가변형식일 때는 하나하나 인수값을 넣어야 한다. 
mean(1,2,3,4,5)

하지만 인수값을 가변형식으로 넣지 않을 경우 list형으로 전달해주거나 tuple형, dictionary형 으로 전달해 줘야한다. 
mean([1,2,3,4,5])
mean((1,2,3,4,5))
mean({1,2,3,4,5})


###############################    

import stats

stats.mean(1,2,3,4,5)

stats.variance(1,2,3,4,5)

stats.stddev(1,2,3,4,5)



# -*- coding: utf-8 -*-
"""
Created on Tue Sep 11 09:48:47 2018

@author: stu
"""

    
▣ 탐욕알고리즘
- 거리구하기
- 수강신청하기
- 화폐계산하기 

[문제85] 프로그램을 생성하세요.

액수입력 : 362
화폐단위를 입력하세요 : 100 50 1
1원 : 12개
50원 : 1개
100원 : 3개

    
#쌤답 
def coinGreedy(money, cash_type):
    cash_type.sort(reverse=True)  #cash_type이 1,50,100으로 입력됐을 때, 큰 단위로 먼저 나누기 위해서 reverse를 함
    remain = money                #remain이 money로 되어야 함
    res = {}                  
    for cash in cash_type:        #cash_type이 100,50,1
        dvmd = divmod(remain,cash)
        res[cash] = dvmd[0]       #res[cash]키에  dvdm[0]값을 넣음 
        remain = dvmd[1] 
    return res

money = int(input('액수입력 : '))
cash_type = [int(x) for x in input('화폐단위를 입력하세요 : ').split(' ')]
res = coinGreedy(money,cash_type)
for k,v in res.items():          #res.items 를 통해 key value를 확인할 수 있다 
    print('{0}원 : {1}개'.format(k,v))


#cf. 
    
import operator			# dictionary에 대한 정렬을 위해 필요한 moduel 

#키를 기준으로 오름차순 정리
for k,v in sorted(res.items(), key=operator.itemgetter(0)):    
    print('{0}원 : {1}개'.format(k,v))

#value를 기준으로 오름차순 정리
for k,v in sorted(res.items(), key=operator.itemgetter(1)):
    print('{0}원 : {1}개'.format(k,v))

#키를 기준으로 내림차순 정리
for k,v in sorted(res.items(), key=operator.itemgetter(0), reverse=True):
    print('{0}원 : {1}개'.format(k,v))

#value를 기준으로 내림차순 정리
for k,v in sorted(res.items(), key=operator.itemgetter(1), reverse=True):
    print('{0}원 : {1}개'.format(k,v))


#operator 모듈을 불러들인 다음 sorted(정렬에 대한 미리보기), dictionary에 대한 key와 value값을 정렬 

#itemgetter()
itemgetter(0) 여기서 0이 key를 의미
itemgetter(1) 여기서 1은 value절을 의미  


▣ exception처리
- try와 except가 필요하다. 
- exception: 미리 정의된 예상(오류이름)을 알아 놓는 것이 좋다.
def divide(x,y):
    return x/y

divide(10,2)
divide(10,0)
divide(10,'둘')

1)
try:
    z = divide(10,2)
    print(z)
except: 
    print("오류가 발생했습니다.")

2)
#오류 발생했지만 정상적으로 종료하고 메시지를 출력함 
try:
    z = divide(10,0)
    print(z)
except: 
    print("오류가 발생했습니다.")
    

cf. plsql exception이름을 만들어 exception을 처리함 / when others 절은 위에 exception처리에 걸리는 게 없을 때 사용
    1) 미리 정의된 예상(오류 이름), 2) 오류번호는 있는데 이름이 없을 때 이름을 붙여주고 처리, 3) user define- raise문을 만나는 즉시 exception처리 

cf. python에서는 오류 번호가 없음/ 대신 오류 이름은 있음: ZeroDivisionError, TypeError
    => exception처리를 하려면 exception이름을 알고 있어야 한다. 

3) type error 가 났을 때, 등 except가 발생할 때 logic을 하나씩 쓸 수 있음 
try:
    z = divide(10,2)
    print(z)
except TypeError:
    print("인수값을 숫자로 입력하세요.")
except ZeroDivisionError:
    print("0값으로 나눌 수 없습니다.")
except:
    print("오류가 발생했습니다.")
   
4) else: optional한 것으로 else:를 사용하면 except가 없으면 else를 처리하고 끝난다.
try:
    z = divide(10,2)
    print(z)
except TypeError:
    print("인수값을 숫자로 입력하세요.")
except ZeroDivisionError:
    print("0값으로 나눌 수 없습니다.")
except:
    print("오류가 발생했습니다.")
else: 
    print("결과: {0}".format(z)) #0:위치포인터로서 쓰지 않아도 된다.
    
5) finally: 오류가 나도 finally를 수행하고 종료 됨
try:
    z = divide(10,0)
    print(z)
except TypeError:
    print("인수값을 숫자로 입력하세요.")
except ZeroDivisionError:
    print("0값으로 나눌 수 없습니다.")
except:
    print("오류가 발생했습니다.")
else: 
    print("결과: {0}".format(z)) #0:위치포인터로서 쓰지 않아도 된다.   
finally: 
    print("프로그램종료")
    
6) raise exception: rasie절에 만든 오류를 유발 하기 위해서 raise exception(keyword)과 except exception as error(꼭 error를 사용하지 않아도 됨)를 사용 
def func(arg):
    try:
        if arg < 1 or arg > 10:
            raise Exception("유효하지 않는 숫자입니다.:{}".format(arg))
        else:
            print("입력한 수는 {})입니다.".format(arg))
    except Exception as error:
        print("오류가 발생했습니다.{}".format(error))

func(100)            
#as error부분이 raise exception으로 감 

    


################################################################################################
[문제86] 숫자를 입력값으로 받은 후 짝수인지 홀수 인지를 출력한후 그 숫자값을 기준으로
짝수면 짝수형식의 증가값으로 10개 출력, 홀수면 홀수형식의 증가값으로 10개 출력합니다.
만약에 숫자가 들어 오지 않으면 예외사항처리하세요.

숫자를 입력해주세요 : 10
짝수
10
12
14
16
18
20
22
24
26
28
>>> 

숫자를 입력해주세요 : 11
홀수
11
13
15
17
19
21
23
25
27
29

숫자를 입력해주세요 : 이십
invalid literal for int() with base 10: '이십'
숫자를 입력하세요
 

try:   
    number = int(input("숫자를 입력해주세요: "))
    if number%2 == 1:
        print("홀수")
    else: 
        print("짝수")
    count = 1
    while count <= 10:
        print(number)
        number += 2
        count += 1
except ValueError as error:
    print(error)
    print("숫자를 입력하세요")

# 무한루프 발생: number로만 변수를 설정하여 입력하니.... +2가 무한반복... 망... 
try:   
    number = int(input("숫자를 입력해주세요: "))
    if number%2 == 1:
        print("홀수")
    else: 
        print("짝수")
    while number <= (number+20):
        print(number)
        number += 2
except ValueError as error:
    print(error)
    print("숫자를 입력하세요")


#쌤답1
try:
    num = int(input("숫자를 입력해주세요 : "))
    if (num%2) ==0:
        print("짝수")
    else:
        print("홀수")
    count =1
    while count <= 10:
        print(num)
        num += 2
        count += 1
except ValueError as error:
    print(error)
    print('숫자를 입력하세요')

#쌤답2
try: 
    num = int(input("숫자를 입력해주세요 : "))
    if (num%2) ==0:
        print("짝수")
    else:
        print("홀수")
    count =1
    while count <= 10:
        print(num)
        num += 2
        count += 1
except Exception as error:
    print(error)
    print('숫자를 입력하세요')



■ 오류와 실제 오류 정보 파악하기 
lst = [1,2,3]

1)
try:
    print(lst[3])
except:
    print('오류가 발생했습니다.')
    
2) 실제 오류 정보 파악하기   
try:
    print(lst[3])
except Exception as error:
    print(error)

3)
try:
    print(lst[3])
except IndexError as error:
    print(error)
    

###################################################################################################################333
▣ 날짜 
datetime 패키지에서는 
날짜 시간을 제공하는 datetime class, 
날짜만 제공하는 date class, 
시간만 제공하는 time class, 
일수, 시간, 분, 초 구간제공하는 timedelta class

#datetime package
import datetime

#date에 today라는 method가 있음
datetime.date.today()
datetime.date.today().year
datetime.date.today().month
datetime.date.today().day

d=datetime.date.today()
d.year
d.month
d.day


#now moethod는 시, 분, 초도 나옴
datetime.datetime.now()
datetime.datetime.now().year
datetime.datetime.now().month
datetime.datetime.now().day
datetime.datetime.now().hour
datetime.datetime.now().minute
datetime.datetime.now().second

n = datetime.datetime.now()
n.year
n.microsecond   #백만분의 1초: 10**(-6) = μ
n.date()
n.time()
#weekday도 method이기 때문에 ()사용하기 
n.weekday()  0:월 ~ 6:일

cf. sql sysdate를 통해 to_character 해서 날짜를 뽑아냄

###########################################################################
[문제87] 오늘이 무슨 요일인지 출력해주세요
import datetime

days = ['월요일','화요일','수요일','목요일','금요일','토요일','일']
days[datetime.datetime.now().weekday()]

##########################################################################
#년도를 int로 뽑아냄
d = datetime.datetime.now()
type(d.year)


■ strftime: date -> char 
d.strftime('%Y %m %d %B')
d.strftime('%Y') #년도만 str(문자형식)으로 뽑아냄 
d.strftime('%x') #월/ 일/ 년도
d.strftime('%X') #시:분:초
d.strftime('%A') 
d.strftime('%a') 
d.strftime('%c') #날짜, 시간정보
d.strftime('%p')
d.strftime('%j') #누적날짜
d.strftime('%U') 
d.strftime('%W') 
type(d.strftime('%Y %m %d'))

%Y 년도 4자리
%m 달
%d 일
%B 영어 달 이름
%H 시간 24시간으로 환산
%I 시간 12시간으로 환산
%M 분
%S 초
%x 현재 날짜 정보 #월/ 일/ 년도
%X 현재 시간 #시:분:초
%A 요일
%a 요일(축약요일)
%c 날짜시간정보
%p AM, PM
%j 누적 날짜
%U 누적주 (일요일 시작)
%W 누적주 (월요일 시작)
%w 요일 (0~6)
%z 시간대 (+부호 시간대) #datetime.datetime.now()가 시간대를 가지고 있지 않기 때문에 지금 값이 return되지 않음 
d.strftime('%z') 

■ strptime: char -> date
datetime.datetime.strptime('2018-09-11 14:50:00','%Y-%m-%d %H:%M:%S')

d = datetime.date(2018, 9, 11)
t = datetime.time(14,52,00)

#날짜 정보와 시간정보를 합침 
datetime.datetime.combine(d,t)

#날짜정보 계산하기 
datetime.datetime(2018,5,24)-datetime.datetime(2018,11,22)

#날짜정보에 날짜더하기 계산
datetime.datetime(2018, 9, 11) + datetime.timedelta(days=72)

#
datetime.timedelta(days=72)
#초로 환산됨
datetime.timedelta(hours=1)
datetime.timedelta(minutes=1)

# 날짜정보 계산하기
datetime.datetime(2018, 9, 11) + datetime.timedelta(days=72, seconds=3600)

#현재날짜정보 return 
datetime.date.today()


##########################################################################
[문제88] 함수에 인수값으로 현재날짜, 일수 정보를 입력 받아서 더한 날짜정보를 리턴하는 next_day함수를 생성하세요.

#답
def next_day(x):
    return datetime.date.today()+ datetime.timedelta(days=x)

next_day(72)

#쌤답 
def next_day(arg1, arg2):
    return (arg1 + datetime.timedelta(days=arg2))
print(next_day(datetime.date.today(), 72))
##########################################################################


■ 구간계산: delta값에 대한 초단위 계산 
start = datetime.datetime.now()
end = datetime.datetime.now()
delta = end - start
delta.total_seconds()


##########################################################################
[문제89] 아래와 같은 결과가 출력될수 있도록 프로그램을 생성하세요


1에서 천만까지 짝수합, 홀수합 구합니다
1에서 천만까지 짝수합: 24999995000000
1에서 천만까지 홀수합: 25000000000000
처리시간 : 0:00:01.950003
처리시간 millisecond(1/1000)  : 1950ms

#답1
import datetime
start = datetime.datetime.now()
print('1에서 천만까지 짝수합, 홀수합 구합니다')
result_even = 0
result_odd = 0
i = 1
while  i <= 10000000:
    if i%2 == 0:
        result_even += i
        i += 1
    else:
        result_odd += i
        i += 1
print('1에서 천만까지 짝수합: %d'%result_even)
print('1에서 천만까지 홀수합: %d'%result_odd)
end = datetime.datetime.now()        
delta = end -start
delta.total_seconds()
print("처리시간 %d"%delta.total_seconds())
delta_ms = int(delta.total_seconds()*1000)
print("처리시간 millisecond(1/1000) : %dms"%delta_ms)



#답2
import datetime
start = datetime.datetime.now()
print('1에서 천만까지 짝수합, 홀수합 구합니다')
result_even = 0
result_odd = 0
for i in range(1,10000001):
    if i%2 == 0:
        result_even += i
    elif i%2 == 1:
        result_odd += i
print('1에서 천만까지 짝수합: %d'%result_even)
print('1에서 천만까지 홀수합: %d'%result_odd)
end = datetime.datetime.now()        
delta = end -start
delta.total_seconds()
print("처리시간 %d"%delta.total_seconds())
delta_ms = int(delta.total_seconds()*1000)
print("처리시간 millisecond(1/1000) : %dms"%delta_ms)



#쌤답
from datetime import datetime
start = datetime.now()
print('1에서 천만까지 짝수합, 홀수합 구합니다')
even_result = 0
odd_result = 0
for i in range(10000000):
    if i % 2 == 0:
        even_result += i
    else:
        odd_result += i
print('1에서 천만까지 짝수합: %d'%even_result)
print('1에서 천만까지 홀수합: %d'%odd_result)
end = datetime.now()
delta = end - start
print("처리시간 : ",delta)
delta_ms = int(delta.total_seconds() * 1000)
print("처리시간 millisecond(1/1000)  : %dms"%delta_ms)



##########################################################################
■ import time

1970년 1월 1일 0시 0분 0초를 기준으로 지난 시간을 초단위로 리턴해주는 함수
UTC(Universal Time Coordinated 세계협정표준시)를 이용해서 실수 형태로 반환

time.time()
time.localtime()
time.localtime().tm_year
time.localtime().tm_mon
time.localtime().tm_wday #현재요일(0~6)
time.localtime().tm_yday  #누적일수(1~365(366))
time.localtime().tm_isdst  #서머타임일 경우 1, 아닐경우 0, 모를경우 -1


time.gmtime()   #UTC 기준의 현재 시간 (local time)
time.asctime()
time.ctime()

■ time -> char : 
    strftime 여기에도 있지만 형식이 조금 다름 
time.strftime('%Y', time.localtime())
time.strftime('%Y %z', time.localtime())

■ time.sleep(2): 2초 간격으로 for문 돌리기 
for i in range(10):
    print(i)
    time.sleep(2)


▣ import calendar
import calendar
print(calendar.calendar(2018))
calendar.calendar(2018)

calendar.prcal(2019)

calendar.prmonth(2018,9)

calendar.weekday(2018,9,11)

calendar.monthrange(2018, 9)





# -*- coding: utf-8 -*-
"""
Created on Wed Sep 12 09:44:41 2018

@author: stu
"""

▣ 파일 입출력

■ 파일생성

■  파일객체 = open("c:/data/test.txt".mode)

■ mode
r : 읽기
w : 쓰기(파일 안에 원본 데이터는 지우고 작성된다.-overwrite)
a : 추가

■ 파일객체.close

f = open("c:/data/test.txt", "w")   #파일 객체 먼저 선언해야함 ex) f = open("물리적 위치정보", "모드정보")

for i in range(1,11):
    txt = "%d 오늘하루도 행복하자\n"%i
    f.write(txt)

f.close()

#test.txt 출력
1 오늘하루도 행복하자
2 오늘하루도 행복하자
3 오늘하루도 행복하자
4 오늘하루도 행복하자
5 오늘하루도 행복하자
6 오늘하루도 행복하자
7 오늘하루도 행복하자
8 오늘하루도 행복하자
9 오늘하루도 행복하자
10 오늘하루도 행복하자

#append
f = open("c:/data/test.txt", "a")   #파일 객체 먼저 선언해야함 ex) f = open("물리적 위치정보", "모드정보")

for i in range(11,21):
    txt = "%d 오늘하루도 행복하자\n"%i
    f.write(txt)

f.close()                           #꼭 파일을 닫아줘야함! (close작업을 안하면 계속 열려있음)

# text.txt 출력
1 오늘하루도 행복하자
2 오늘하루도 행복하자
3 오늘하루도 행복하자
4 오늘하루도 행복하자
5 오늘하루도 행복하자
6 오늘하루도 행복하자
7 오늘하루도 행복하자
8 오늘하루도 행복하자
9 오늘하루도 행복하자
10 오늘하루도 행복하자
11 오늘하루도 행복하자
12 오늘하루도 행복하자
13 오늘하루도 행복하자
14 오늘하루도 행복하자
15 오늘하루도 행복하자
16 오늘하루도 행복하자
17 오늘하루도 행복하자
18 오늘하루도 행복하자
19 오늘하루도 행복하자
20 오늘하루도 행복하자


▣ import os
■ 파일 존재 여부 확인
import os
os.path.exists("c:/data/test.txt")
# 존재하면 True, 존재하지 않으면 False

■ 파일 읽기
- readline(): 라인 하나씩 읽어들인다. 
#첫문장만 읽어들이기
file = open("c:/data/test.txt","r")
data = file.readline()
print(data)
file.close

#전체 문장을 읽어들이기
file = open("c:/data/test.txt","r")
while True:
    data = file.readline()      #더이상 파일에서 읽어올 라인이 없으면 None값을 리턴함 (None은 False임)
    if not data:    #not data: data가 없으면
        break
    print(data)
file.close()

#전체 문장 읽어들일 때 공백 줄 없애기
file = open("c:/data/test.txt","r")
while True:
    data = file.readline()
    if not data:    #not data: data가 없으면
        break
    print(data, end='') #end='': 공백줄 없애기
file.close()

#
- readlines(): 모든 라인을 읽어서 리스트에 저장  -> #변수는 리스트가 됨  -> 따라서 하나씩 하나씩 for문을 이용해서 읽어들여야 함 
file = open("c:/data/test.txt","r")
data = file.readlines()
print(data, end='')
file.close

# 
file = open("c:/data/test.txt","r")
data = file.readlines()
for i in data:
    print(i,end='')
file.close()

#
- read():파일전체를 문자열로 리턴한다.
file = open("c:/data/test.txt","r")
data = file.read()
print(data)
file.close

# cf. sql-  with문: 가상결과 집합을 테이블 모양으로 만들어 놓은 것, inline view(제약: 가상집합을 다시 호출할 때 사용이 안됨)

- with: close를 자동으로 하는 방법 
with open("c:/data/test.txt","w") as file:
    for i in range(1,101):
          txt = '%d 오늘하루도 행복하자\n'%i
          file.write(txt)


#
txt = ['야!! 가을이다', '오늘 하루 신나게 놀아보자']

with open('c:/data/test_new.txt','w') as file:
    for i in txt:
        file.write(i)

with open('c:/data/test_new.txt','w') as file:
    for i in txt:
        file.write(i+'\n')
        
with open('c:/data/test_new.txt','w') as file:
    for i in txt:
        file.write('{}\n'.format(i))
        
# 위의 파일을 읽기 모드로 만들기
with open('c:/data/test_new.txt','r') as file:    
    txt=file.readlines()
    for i in txt:
        print(i,end='')


▣import csv
# csv 파일: ,(comma)로 구분되어 있는 파일
import os
os.path.exists("c:/data/emp.csv")

import csv
file = open("c:/data/emp.csv.","r")
csv.reader(file)   #저장된 주소만 보이고 내용확인이 안됨 

# csv파일 읽어드리기 
emp_csv = csv.reader(file)
emp_csv

# 내용 확인을 위해서는 다음과 같이 for문을 사용해서 읽어들여야 한다. 
for emp_list in emp_csv:
    print(emp_list)


    
# dataframe이 아닌 list 값으로 출력된다. 
# next(emp_csv)를 통해 컬럼정보를 제거할 있다. 
file = open("c:/data/emp.csv","r")
emp_csv = csv.reader(file)
#next(emp_csv)
for emp_list in emp_csv:
    print(emp_list)
    
[문제90] emp.csv파일의 last_name, salary를 출력해주세요. 
# last name, salary 출력하기 
file = open("c:/data/emp.csv","r")
emp_csv = csv.reader(file)
next(emp_csv)
for emp_list in emp_csv:
    print(emp_list[2], emp_list[7])  #2번 인덱스 정보만 출력해 줌 

########################################################################
[문제91] last_name, last_name 길이를 출력해주세요.
file = open("c:/data/emp.csv", "r")
emp_csv = csv.reader(file)
next(emp_csv)
for emp_list in emp_csv:
    print(emp_list[2], len(emp_list[2]))
                     
[문제92] employee_id, last_name, salary*12 달 곱한값을 출력해주세요.
# 문자열이기 때문에 숫자형식으로 바꿔줘야 한다. int로 할 경우
file = open("c:/data/emp.csv", "r")
emp_csv = csv.reader(file)
next(emp_csv)
for emp_list in emp_csv:
    print(emp_list[0], emp_list[2], (int(emp_list[7])*12))
file.close()    

# 문자열이기 때문에 숫자형식으로 바꿔줘야 한다. 그러나 int할 때 소수점이 있으면 오류가 남으로 float을 사용해야 한다. 
file = open("c:/data/emp.csv", "r")
emp_csv = csv.reader(file)
next(emp_csv)
for emp_list in emp_csv:
    print(emp_list[0], emp_list[2], (float(emp_list[7])*12))
file.close()    

[문제93] last_name, commission_pct를 출력하는데 commission_pct값이 ''이면 0으로 출력해주세요.
#답1
file = open("c:/data/emp.csv", "r")
emp_csv = csv.reader(file)
next(emp_csv)
for emp_list in emp_csv:
    if emp_list[-3] =='':
        emp_list[-3] = 0
        print(emp_list[2], emp_list[-3])
    else: 
        print(emp_list[2], emp_list[-3])
file.close()  

#답2
file = open("c:/data/emp.csv", "r")
emp_csv = csv.reader(file)
next(emp_csv)
for emp_list in emp_csv:
    if emp_list[-3] =='':
        print(emp_list[2], emp_list[-3].replace('','0'))
    else: 
        print(emp_list[2], emp_list[-3])
file.close()  

#쌤답
def ifnull(var1, var2):
    if var1 =='':
        return var2
    return var1

file = open("c:/data/emp.csv", "r")
emp_csv = csv.reader(file)
next(emp_csv)
for emp_list in emp_csv:
    print(emp_list[2], ifnull(emp_list[8],0))
file.close()


[문제94] last_name을 대문자로 job_id 소문자로 출력해주세요.
file = open("c:/data/emp.csv","r")
emp_csv = csv.reader(file)
next(emp_csv)
for emp_list in emp_csv:
    print(emp_list[2].upper(), emp_list[6].lower())
file.close()

[문제95] last_name을 첫글자만 추출해서 소문자로 출력해주세요.
file = open("c:/data/emp.csv", "r")
emp_csv = csv.reader(file)
next(emp_csv)
for emp_list in emp_csv:
    print(emp_list[2][0].lower())
file.close()

[문제96] last_name을 두번째 부터 마지막까지만 추출해서 대문자로 출력해주세요.
#답1
file = open("c:/data/emp.csv","r")
emp_csv = csv.reader(file)
next(emp_csv)
for emp_list in emp_csv:
    print(emp_list[2][1:-1].upper())
file.close()

#답2
file = open("c:/data/emp.csv","r")
emp_csv = csv.reader(file)
next(emp_csv)
for emp_list in emp_csv:
    print(emp_list[2][1:].upper())
file.close()

[문제97] 이름을 입력하면 첫글자는 대문자 나머지는 소문자를 출력하는 initcap함수를 이용해서 이름을 출력하세요.
def initcap(x):
    return(x[0].upper()+x[1:].lower())    

   
initcap("kimhyunjung")

import csv
file = open("c:/data/emp.csv",'r')
emp_csv = csv.reader(file)
next(emp_csv)
for emp_list in emp_csv:
    print(initcap(emp_list[2]))
file.close()


[문제98] 이름을 입력하면 제일 뒤에 있는 철자는 대문자 앞의 문자는 소문자로 출력하는 talicap함수를 생성하세요. 
def tailcap(x):
    return(x[:-1].lower()+x[-1].upper())
    
tailcap("hyunjungKim")

import csv
file = open("c:/data/emp.csv",'r')
emp_csv = csv.reader(file)
next(emp_csv)
for emp_list in emp_csv:
    print(tailcap(emp_list[2]))
file.close()

[문제99] 이름과 급여를 출력하는데 급여를 출력할 때에 0대신 *를 출력하세요.
#답1
def zero(x):
    return(x.replace("0","*"))

import csv
file = open("c:/data/emp.csv",'r')
emp_csv = csv.reader(file)
next(emp_csv)
for emp_list in emp_csv:
    print(emp_list[2], zero(emp_list[7]))
file.close()

#답2
file = open("c:/data/emp.csv",'r')
emp_csv = csv.reader(file)
next(emp_csv)
for emp_list in emp_csv:
    print(emp_list[2], emp_list[7].replace("0","*"))
file.close()


[문제100] 이름, salary*12 + commission_pct결과를 출력해주세요. 

"""
def commission(x):
    if x == '':
        return x=0
    else:
        return x

import csv
file = open("c:/data/emp.csv",'r')
emp_csv = csv.reader(file)
next(emp_csv)
for emp_list in emp_csv:
    print(emp_list[2], float(emp_list[7]*12)+commission(float(emp_list[-3])))


file = open("c:/data/emp.csv", "r")
emp_csv = csv.reader(file)
next(emp_csv)
for emp_list in emp_csv:
    if emp_list[-3] =='':
        emp_list[-3] = 0
        print(emp_list[2], math.trunc(int(emp_list[7]*12))+(float(emp_list[-3])))
    else: 
        print(emp_list[2], math.trunc(int(emp_list[7]*12))+(float(emp_list[-3])))
file.close()  
"""

# 쌤답
import math
    
def ifnull(var1, var2):
    if var1 =='':
        return var2
    return var1

file = open("c:/data/emp.csv", "r")
emp_csv = csv.reader(file)
next(emp_csv)
for emp_list in emp_csv:
    print(emp_list[2], math.trunc(int(emp_list[7])*12+float(ifnull(emp_list[8],0))))
file.close()

#ifnull: nvl함수를 만듦
#trunc: sql의 trunc함수와 다름 
#round는 그냥 내장되어 있는 함수
#trunc: math라는 함수를 불러야 함 


[문제101] 이름, 입사한 요일(한글)을 출력해주세요.

import datetime

def day(x):
    days = ['월요일','화요일','수요일','목요일','금요일','토요일','일요일']
    return days[datetime.datetime.strptime(x,'%Y%m%d').weekday()]

file = open("c:/data/emp.csv", "r")
emp_csv = csv.reader(file)
next(emp_csv)
for emp_list in emp_csv:
    print(emp_list[2], day(emp_list[5]))
file.close()

#쌤답 :문자 -> 날짜 
import datetime
import csv
file = open("c:/data/emp.csv",'r')
days = ['월요일','화요일','수요일','목요일','금요일','토요일','일요일']
emp_csv = csv.reader(file)
next(emp_csv)
for emp_list in emp_csv:
    a = datetime.datetime.strptime(emp_list[5],'%Y%m%d')
    print(emp_list[1], days[a.weekday()])
file.close()

[문제102] 이름, 입사한 날짜부터 오늘까지 총 몇일 근무했는지 출력하세요. 

import datetime
import csv

def workdays(x):
    return datetime.datetime.today()-datetime.datetime.strptime(x, '%Y%m%d')

file = open("c:/data/emp.csv", "r")
emp_csv = csv.reader(file)
next(emp_csv)
for emp_list in emp_csv:
    print(emp_list[2], workdays(emp_list[5]).days)   #.days시간정보 없애기 
file.close()


#쌤답1
import datetime
import csv
file = open("c:/data/emp.csv",'r')
emp_csv =csv.reader(file)
next(emp_csv)
for emp_list in emp_csv:
    a = datetime.datetime.now()- datetime.datetime.strptime(emp_list[5],'%Y%m%d')
    print(emp_list[1], a.days)
file.close()

#cf. 날짜는 날짜의 모양을 만들어줘야 한다. now()는 datetime형식 today()는 date형식
#쌤답2
import datetime
import csv
file = open("c:/data/emp.csv",'r')
emp_csv =csv.reader(file)
next(emp_csv)
for emp_list in emp_csv:
    a = datetime.date.today()- datetime.datetime.strptime(emp_list[5],'%Y%m%d').date()  #날짜형식인 date형식을 맞추기
    print(emp_list[1], a.days)
file.close()


[문제103]오늘 부터 이번달 말일까지 몇일 남았는지 출력하세요.
import datetime 
import calendar

day = calendar.monthrange(2018, 9) 

day[1] - datetime.date.today().day

#쌤답
from datetime import date
from calendar import monthrange

monthrange(2018,9)[1]-date.today().day


[문제104] 사원번호가 100번 사원의 사원이름과 급여를 출력하세요.
import csv
file = open("c:/data/emp.csv",'r')
emp_csv =csv.reader(file)
next(emp_csv)
for emp_list in emp_csv:
    if emp_list[0] == "100":
        print(emp_list[1], emp_list[7])
file.close()

#쌤답
import csv

file = open("c:/data/emp.csv",'r')
emp_csv = csv.reader(file)
next(emp_csv)
for emp_list in emp_csv:
    if int(emp_list[0])==100:
        print(emp_list[2], emp_list[7])
file.close()
        
[문제105] 급여가 10000 이상인 사원들의 이름과 급여를 출력하세요.
import csv
file = open("c:/data/emp.csv",'r')
emp_csv =csv.reader(file)
next(emp_csv)
for emp_list in emp_csv:
    if int(emp_list[7]) >= 10000:        #where의 조건절    
        print(emp_list[1], emp_list[7])  #select 절의 column 
file.close()

#쌤답
import csv
file = open("c:/data/emp.csv",'r')
emp_csv =csv.reader(file)
next(emp_csv)
for emp_list in emp_csv:
    if float(emp_list[7]) >= 10000:        #where의 조건절    
        print(emp_list[2], emp_list[7])  #select 절의 column 
file.close()

[문제106] 2001-01-13일에 입사한 사원의 이름과 입사일을 출력하세요
#답1: 날짜형으로 비교
import csv
import datetime
file = open("c:/data/emp.csv",'r')
emp_csv =csv.reader(file)
next(emp_csv)
for emp_list in emp_csv:
    if datetime.datetime.strptime(emp_list[5],'%Y%m%d') == datetime.datetime.strptime('2001-01-13','%Y-%m-%d'):
        print(emp_list[1], emp_list[5])
file.close()

#답2: 문자형으로 비교
import csv
import datetime
file = open("c:/data/emp.csv",'r')
emp_csv =csv.reader(file)
next(emp_csv)
for emp_list in emp_csv:
    if emp_list[5] == "20010113":
        print(emp_list[1], emp_list[5])
file.close()

#쎔답
import csv
import time
file = open("c:/data/emp.csv",'r')
emp_csv =csv.reader(file)
next(emp_csv)
for emp_list in emp_csv:
    if time.strptime(emp_list[5],'%Y%m%d') == time.strptime('20010113','%Y%m%d'):
        print(emp_list[1], emp_list[5])
file.close()

#sql: to_date : 문자 -> 날짜

[문제107] 2002 년도에 입사한 사원들의 이름과 입사일을 출력하세요.
#답1
import csv
import datetime
file = open("c:/data/emp.csv",'r')
emp_csv =csv.reader(file)
next(emp_csv)
for emp_list in emp_csv:
    if datetime.datetime.strptime('2002-01-01', '%Y-%m-%d') <= datetime.datetime.strptime(emp_list[5],'%Y%m%d') < datetime.datetime.strptime('2003-01-01', '%Y-%m-%d'):
        print(emp_list[1], emp_list[5])
file.close()

#답2
import csv
file = open("c:/data/emp.csv",'r')
emp_csv =csv.reader(file)
next(emp_csv)
for emp_list in emp_csv:
    if int(emp_list[5][0:4])==2002:
        print(emp_list[1], emp_list[5])
file.close()

#쌤답1
import csv
file = open("c:/data/emp.csv",'r')
emp_csv =csv.reader(file)
next(emp_csv)
for emp_list in emp_csv:
    if emp_list[5][:4]=='2002':
        print(emp_list[2], emp_list[5])
file.close()

#쌤답2
import csv
import time

file = open("c:/data/emp.csv",'r')
emp_csv =csv.reader(file)
next(emp_csv)
for emp_list in emp_csv:
    if time.strptime(emp_list[5],'%Y%m%d').tm_year == time.strptime('2002', '%Y').tm_year:
        print(emp_list[2], emp_list[5])
file.close()


########################################################################

[문제108] job이 ST_CLERK 이고 월급 3000 이상인 사원들의 이름과 job, 급여 출력하세요
import csv
file = open("c:/data/emp.csv",'r')
emp_csv=csv.reader(file)
next(emp_csv)
for emp_list in emp_csv:
    if emp_list[6]=="ST_CLERK" and int(emp_list[7])>=3000:
        print(emp_list[2], emp_list[6], emp_list[7])


[문제109] 급여가 2500 에서 3000 사이인 사원들의 이름과 급여를 출력하세요
import csv
file = open("c:/data/emp.csv",'r')
emp_csv=csv.reader(file)
next(emp_csv)
for emp_list in emp_csv:
    if 2500 <= int(emp_list[7]) <= 3000:
        print(emp_list[2], emp_list[7])

#쌤답
file = open("c:/data/emp.csv",'r')
emp_csv=csv.reader(file)
next(emp_csv)
for emp_list in emp_csv:
    if 2500 <= float(emp_list[7]) and 3000>=float(emp_list[7]):
         print(emp_list[2], emp_list[7])   
    
[문제110] job AD_VP , AD_PRES 인 사원들의 이름과 월급과 직업을 출력하세요
import csv
file = open("c:/data/emp.csv",'r')
emp_csv=csv.reader(file)
next(emp_csv)
for emp_list in emp_csv:
    if emp_list[6] == "AD_VP" or emp_list[6]=="AD_PRES":
        print(emp_list[2], emp_list[7], emp_list[6])

#쌤답
import csv
file = open("c:/data/emp.csv",'r')
emp_csv=csv.reader(file)
next(emp_csv)
cn = 0
for emp_list in emp_csv:
    if emp_list[6] in ["AD_VP", "AD_PRES"]:
        print(emp_list[2], emp_list[7], emp_list[6])
        cn += 1
print ('총건수 %d'%cn)

[문제111] 직업이 AD_VP , AD_PRES 이 아닌 사원들의 이름과 월급과 직업을  출력하세요
import csv
file = open("c:/data/emp.csv",'r')
emp_csv=csv.reader(file)
next(emp_csv)
count = 0 
for emp_list in emp_csv:
    if emp_list[6] != "AD_VP" and emp_list[6] !="AD_PRES":
        print(emp_list[2], emp_list[7], emp_list[6])
        count +=1
print(count)

#쌤답
import csv
file = open("c:/data/emp.csv",'r')
emp_csv=csv.reader(file)
next(emp_csv)
cn = 0
for emp_list in emp_csv:
    if emp_list[6] not in ["AD_VP", "AD_PRES"]:
        print(emp_list[2], emp_list[7], emp_list[6])
        cn += 1
print ('총건수 %d'%cn)



# -*- coding: utf-8 -*-
"""
Created on Thu Sep 13 09:46:49 2018

@author: stu
"""
##############################################################################
import csv
file = open("c:/data/emp.csv","r")          
emp_csv = csv.reader(file)
for emp_list in emp_csv:
    print(emp_list)
    

[문제112] 커미션이 null 인 사원의 이름, 급여, 커미션을 출력하세요.
          전체 인원수, 커미션 null의 수, 비율도 출력하세요.

import csv
file = open("c:/data/emp.csv","r")          
emp_csv = csv.reader(file)
next(emp_csv)
cn_total = 0
cn_null = 0
for emp_list in emp_csv:
    cn_total += 1
    if emp_list[-3] == "":
        emp_list[-3] = 0
        print(emp_list[2], emp_list[7], emp_list[-3])
        cn_null += 1
ratio=round((cn_null/cn_total*100),2)

print('전체 인원수: ', cn_total,'명')
print('커미션 null의 수 :',cn_null,'명')
print('비율: ', ratio)


#쌤답
import csv
import math

import csv
file = open("c:/data/emp.csv","r")          
emp_csv = csv.reader(file)
next(emp_csv)
cn1 = 0
cn2 = 0
for emp_list in emp_csv:
    if emp_list[8] =='':
        print(emp_list[2], emp_list[7], emp_list[8])
        cn1 +=1
    cn2 += 1
print('전체 수: {}'.format(cn2))
print('조건의 수: {}'.format(cn1))
print('조건의 비율: {}'.format(math.trunc(cn1*100/cn2)))



[문제113]커미션이 null 이 아닌 사원들의 이름,급여,커미션을 출력하세요.
전체 인원수, 커미션 null의 수, 비율도 출력하세요.

import csv
file = open("c:/data/emp.csv","r")          
emp_csv = csv.reader(file)
next(emp_csv)
cn_total = 0
cn_null = 0
for emp_list in emp_csv:
    cn_total += 1
    if emp_list[-3] != "":
        print(emp_list[2], emp_list[7], emp_list[-3])
        cn_null += 1
ratio=round((cn_null/cn_total*100),2)

print('전체 인원수: ', cn_total,'명')
print('커미션 null의 수 :',cn_null,'명')
print('비율: ', ratio)


#쌤답
import csv
import math

import csv
file = open("c:/data/emp.csv","r")          
emp_csv = csv.reader(file)
next(emp_csv)
cn1 = 0
cn2 = 0
for emp_list in emp_csv:
    if emp_list[8] !='':
        print(emp_list[2], emp_list[7], emp_list[8])
        cn1 +=1
    cn2 += 1
print('전체 수: {}'.format(cn2))
print('조건의 수: {}'.format(cn1))
print('조건의 비율: {}'.format(math.trunc(cn1*100/cn2)))


[문제114] last_name의 첫번째 철자가 S 로 시작하는 사원들의 이름과 급여를 출력하세요.
전체 인원수, 커미션 null의 수, 비율도 출력하세요.

import csv
file = open("c:/data/emp.csv","r")          
emp_csv = csv.reader(file)
next(emp_csv)
cn_total = 0
cn_s = 0
for emp_list in emp_csv:
    cn_total += 1
    if emp_list[2][0].upper() == 'S':
        print(emp_list[2], emp_list[7])
        cn_s += 1
ratio=round((cn_s/cn_total*100),2)

print('전체 인원수: ', cn_total,'명')
print('last_name의 첫번째 철자가 S 로 시작하는 사원의 수 :',cn_s,'명')
print('비율: ', ratio)

#쌤답
import csv
import math

import csv
file = open("c:/data/emp.csv","r")          
emp_csv = csv.reader(file)
next(emp_csv)
cn1 = 0
cn2 = 0
for emp_list in emp_csv:
    if emp_list[2][0].upper() == 'S':
        print(emp_list[2], emp_list[7])
        cn1 +=1
    cn2 += 1
print('전체 수: {}'.format(cn2))
print('조건의 수: {}'.format(cn1))
print('조건의 비율: {}'.format(math.trunc(cn1*100/cn2)))


[문제115] last_name의 두번째 철자가 i 인 사원들의 이름과 월급을 출력하세요. 
전체 인원수, 커미션 null의 수, 비율도 출력하세요.

import csv
file = open("c:/data/emp.csv","r")          
emp_csv = csv.reader(file)
next(emp_csv)
cn_total = 0
cn_i = 0
for emp_list in emp_csv:
    cn_total += 1
    if emp_list[2][1].lower() == 'i':
        print(emp_list[2], emp_list[7])
        cn_i += 1
ratio=round((cn_i/cn_total*100),2)

print('전체 인원수: ', cn_total,'명')
print('last_name의 두번째 철자가 i 인 사원의 수 :',cn_i,'명')
print('비율: ', ratio)

#쌤답
import csv
import math

import csv
file = open("c:/data/emp.csv","r")          
emp_csv = csv.reader(file)
next(emp_csv)
cn1 = 0
cn2 = 0
for emp_list in emp_csv:
    if emp_list[2][1].lower() == 'i':
        print(emp_list[2], emp_list[7])
        cn1 +=1
    cn2 += 1
print('전체 수: {}'.format(cn2))
print('조건의 수: {}'.format(cn1))
print('조건의 비율: {}'.format(math.trunc(cn1*100/cn2)))


[문제116] 50번부서 사원들의 이름, 급여 출력하는데 이름을 오름차순으로 출력하세요.

#
import csv
file = open("c:/data/emp.csv","r")          
emp_csv = csv.reader(file)
next(emp_csv)
dept_50 = []

for emp_list in emp_csv:
    if emp_list[-1]=="50":
        dept_50.append('{},{}'.format(emp_list[2], emp_list[7]))
        
dept_50.sort()
print(dept_50)

# 쌤답
from operator import itemgetter #operator 모듈 제공

file = open("c:/data/emp.csv","r")          
emp_csv = csv.reader(file)
next(emp_csv)
emp_list = []
for i in emp_csv:
    if i[-1]=="50":
        emp_list.append(i)
        
emp_list_sorted = sorted(emp_list, reverse=False, key=itemgetter(2))  #sorted는 미리보기 #key=itemgetter(): list 정렬; method가 없다면 몇번 인덱스를 기준으로 할 것인지 만들면 된다.
for i in emp_list_sorted:
    print(i[2],i[7])



cf. 확인해보기: emp_list
cf. emp_list_sorted 
print(emp_list_sorted)

#쌤답 응용하기 method를 직접만들자! sort_check라는 함수를 만들어 key=itemgetter를 만들어 보기     
import csv
def sortCheck(data):
    return(data[2])            #sorted(emp_list, reverse=False, key=itemgetter(2))
    
file = open("c:/data/emp.csv","r")          
emp_csv = csv.reader(file)
next(emp_csv)
emp_list = []
for i in emp_csv:
    if i[-1]=="50":
        emp_list.append(i)

emp_list_sorted = sorted(emp_list, reverse=False, key= sortCheck)        

for i in emp_list_sorted:
    print(i[2],i[7])


#######################################################################
#쌤답 굳이 method를 위에 만들지 않고 key값에 람다함수로 만드려면?
▣ lambda(람다)함수
-이름이 없는 한줄짜리 함수
-가독성을 위해서

예시) 
# method
def f(x,y):
    return x*y

f(2,3)

# 한줄짜리 함수 
(lambda x,y: x*y)(2,3)

# 한줄짜리 함수 
f = lambda x,y: x*y    
f(2,3)        

#######################################################################
[문제116] 50번부서 사원들의 이름, 급여 출력하는데 이름을 오름차순으로 출력하세요.
# 람다함수 이용 
import csv
def sortCheck(data):
    return(data[2])            #sorted(emp_list, reverse=False, key=itemgetter(2))
    
file = open("c:/data/emp.csv","r")          
emp_csv = csv.reader(file)
next(emp_csv)
emp_list = []
for i in emp_csv:
    if i[-1]=="50":
        emp_list.append(i)

emp_list_sorted = sorted(emp_list, reverse=False, key=(lambda x:x[2]))        

for i in emp_list_sorted:
    print(i[2],i[7])




#이상해1
import csv
file = open("c:/data/emp.csv","r")          
emp_csv = csv.reader(file)
next(emp_csv)
dept_50 = []

for emp_list in emp_csv:
    if emp_list[-1]=="50":
        dept_50.extend([print(emp_list[2]),print(emp_list[7])])

#이상해2
import csv
file = open("c:/data/emp.csv","r")          
emp_csv = csv.reader(file)
next(emp_csv)
dept_50 = []
        
for emp_list in emp_csv:
    if emp_list[-1]=="50":
        dept_50.extend([print(emp_list[2], emp_list[7])])
        

[문제117] job이 ST_CLERK인 사원들의 이름과 입사일과 job을 출력하는데 가장 최근에 입사한 사원부터 출력하세요.
#람다함수 이용
import csv

file = open("c:/data/emp.csv",'r')
emp_csv = csv.reader(file)
next(emp_csv)
job_ST_CLERK = []

for i in emp_csv:
    if i[6] == "ST_CLERK":
        job_ST_CLERK.append(i)

job_sorted = sorted(job_ST_CLERK , reverse=True, key=(lambda x:x[5]))
   
for i in job_sorted:
    print(i[2],i[5],i[6])
    
# operator module이용 
import csv
from operator import itemgetter 

file = open("c:/data/emp.csv",'r')
emp_csv = csv.reader(file)
next(emp_csv)
job_ST_CLERK = []

for i in emp_csv:
    if i[6] == "ST_CLERK":
        job_ST_CLERK.append(i)
job_sorted = sorted(job_ST_CLERK , reverse=True, key=itemgetter(5))
for i in job_sorted:
    print(i[2],i[5],i[6])


[문제118] 부서별 급여의 총액을 구하세요.
import csv
file = open("c:/data/emp.csv",'r')
emp_csv = csv.reader(file)
next(emp_csv)

dept_sum={}

for emp_list in emp_csv:
    if emp_list[10] in dept_sum:
        dept_sum[emp_list[10]]=int(dept_sum[emp_list[10]])+int(emp_list[7])
    else:
        dept_sum[emp_list[10]]=int(emp_list[7])

for k,v in dept_sum.items():
    print(k,v)


[문제119] 부서별 급여의 총액을 구하세요. 부서별로 오름차순 정렬하세요. 

10 4400
20 19000
30 24900
40 6500
50 156400
60 28800
70 10000
80 304500
90 63040
100 51608
110 20308
non 7000


#119번
        
import csv
file = open("c:/data/emp.csv",'r')
emp_csv = csv.reader(file)
next(emp_csv)

dept_sum={}
for emp_list in emp_csv:
    if emp_list[10] in dept_sum:
        dept_sum[emp_list[10]]=int(dept_sum[emp_list[10]])+int(emp_list[7]) #key - value 값: 만약에 부서코드에 null이 없었으면 int로 바꿔 풀기 
    else:
        dept_sum[emp_list[10]]=int(emp_list[7])   # key - value값
        
def sortCheck(x):
    try:
        return int(x[0])   #key를 기준으로 하여 integer 바꾸기
    except:
        return 999         #na는 999가 되어 맨 밑으로 정렬됨 

dept_sum_sort = sorted(dept_sum.items(), reverse=False, key=sortCheck) #정렬시킨 key-value값 

for k, v in dept_sum_sort:
    if k=='':
        print('non',v)
    else: 
        print(k,v)
        
        
[문제120] 단어, 알파벳을 입력값으로 넣어서 단어 안에 알파벳 수를 출력하세요

<화면예>

wordF('happy','p')
2

def wordF(x,y):
    print(x.count(y))
    
def wordF(x,y):
    result = 0
    for i in range(len(x)):
        if x[i] ==y:
            result += 1 
    print(result)

#쌤답
def wordF(arg1, arg2):
    cn = 0
    for i in arg1:
        if i == arg2:
            cn += 1
    print(cn)
    

 [문제121] 단어를 입력값으로 넣어서 알파벳을 출력하는데 중복되는 알파벳은 하나만 출력하세요.

alphaF('happy')
['h', 'a', 'p', 'y']

alphaF('intelligence')
['i', 'n', 't', 'e', 'l', 'g', 'c']
   

def alphaF(x):
    list = []
    for i in range(len(x)):
        if x[i] not in list:
            list.append(x[i])
    print(list)        


#쌤답
def alphaF(arg):
    freq = []
    for c in arg:
        if c not in freq:   #freq에 없으면 append
            freq.append(c)
                            #freq에 있으면 if는 끝남 
    print(freq)


[문제122] 단어 철자의 빈도수를 출력하세요.


alphaF('intelligence')
{'i': 2, 'n': 2, 't': 1, 'e': 3, 'l': 2, 'g': 1, 'c': 1}

alphaF('happy')
{'h': 1, 'a': 1, 'p': 2, 'y': 1}
   
#다시 해보기    
def alphaF(x):
    alpha_sum={}
    for i in range(len(x)):
        if x[i] in alpha_sum:
            alpha_sum['x[i]'] = 'x.count(x[i])'
    for k,v in alpha_sum.items():
        print(k,v)


# 쌤답 
def alphaF(arg):
    freq={}
    for c in arg:
        if c in freq:
            freq[c] += 1
        else:
            freq[c] = 1
    print(freq)
    

#######################################################################
    
▣ pandas
- 데이터 분석 기능을 제공하는 라이브러리
- 1차원 배열: Series
- 2차원 배열: DataFrame

import pandas as pd 
from pandas import Series, DataFrame (pandas.Series 계속 써는 것을 방지하기 위해 이렇게 import할 수 있음)

■ Series
- 1차원 배열
- 인덱스(색인) 배열의 데이터에 연관된 이름을 가지고 있다. 

s = Series([10,20,30,40,50])
s.index    #색인의 인덱스를 볼 수 있음 
s.values   #값을 보여주면서 자료형을 보여줌
s.index = ['a','b','c','d','e']   #기존의 인덱스 번호를 수정 
s
# R의 vector형처럼 계산할 수 있다. 
s + 10
s - 10
s * 10
s / 3
s//3
s %3

# index를 바로 설정할 수 있음
s2 = Series([10,20,30,40], index=['a','b','c','d'])
s2
s2['a','b'] #오류
s2[['a','b']] #두개의 인덱스를 보려고 할 경우 -> 두개의 대괄호가 필요

# 기존의 인덱스를 보는 방법을 사용할 수 있음 
s2[0]
s2[0:3]
s2[-1]

s2[s2>20]   #20보다 큰 값 확인가능 

#인덱스가 있는지 확인하기 
'a' in s2
'e' in s2

#인덱스 값 수정, 추가, 삭제
s2['a'] = 100   #수정
s2
s2['e'] = 50    #추가
s2
del s2['e']     #삭제
s2['a'] = ''
s2
del s2          #변수삭제: del 변수이름 -> 변수이름 삭제

□ dictionary 형을 series로 생성(key : index/  value: 내용)
dict = {'a':10, 'b':20, 'c':30, 'd':40}
dict
s3 = Series(dict)
s3

dict = {'a':10, 'b':20, 'c':30, 'd':40}
ix = {'a','b','c','d'}      #내가 원하는 index 값(ix)만 가져옴; 그대로 참조함 
s4 = Series(dict, index=ix)
s4

dict = {'a':10, 'b':20, 'c':30, 'd':40}
ix = {'a','b','c','z'}          #z라는 index는 만들어졌지만 dict z값은 없음 -> NaN ; sequence한 배열이 원래 아님 #NaN이 있기 때문에 type도 바뀜
s5 = Series(dict, index=ix)
s5  #NaN(Not a Number): 인덱스 값을 찾을 수 없기 때문에 NaN저장


dict = {'a':10, 'b':20, 'c':30, 'd':40}
ix = {'a','b'}   
s6 = Series(dict, index=ix)
s6

□ pandas에서 null인 값 찾기 
import pandas as pd 
pd.isnull(s5)       #NaN가 있으면 True
pd.notnull(s5)      #NaN가 있으면 False

dict = {'서울':100, '부산':200, '광주':300, '제주':400}
s7 = Series(dict)
s7

city=['서울', '광주', '제주', '인천']

s8 = Series(dict, index=city)
s8

■ DataFrame
- 2차원 배열
- 표현식의 자료구조
- 각 컬럼은 서로 다른 종류의 값(문자, 숫자, 불리언)
- R언어 data.frame
- DataFrame([[],[],[]])

df1 = DataFrame([[1,2,3],[4,5,6],[7,8,9]]) #대괄호 안에 
df1

#dictionary
data = {'도시':['광주','부산','강원','인천'],'인구수':[100,200,50,300]}
data

df2 = DataFrame(data)
df2

df3 = DataFrame({'도시':['광주','부산','강원','인천'],'인구수':[100,200,50,300]})
df3

#컬럼 수정
df3.columns = ['지역','가구수']
df3

# 컬럼 정보 추출
df3.지역
df3.가구수

df3['지역']
df3['가구수']


# 연산작업(series에서와 같이 연산작업이 가능하다.)
df3['가구수']*100

#인덱스 확인
df3.index
#인덱스 수정
df3.index=['one', 'two', 'three','four']
df3

#행보기: ix 메소드 이용 
#데이트프레임.ix[인덱스이름]
df3.ix['one']
df3.ix[0]
df3.ix[1]

#series로 열을 추가
v = Series([1000,2000,3000,4000], 
           index=['one', 'two', 'three', 'four'])
v

df3['부채'] = v
df3

#직접 리스로 열을 추가
df3['인구수']=[10000,20000,300000,5000]
df3

#열 삭제
del df3['부채']
df3

# 
data = {'서울':{2001:200,2002:300},'부산':{2000:10,2001:20,2002:30}}

df4 = DataFrame(data)
df4
# 컬럼이름이 인덱스로, 인덱스가 컬럼이름쪽으로 방향을 바꿈
df4.T
#컬럼 확인
df4.columns
#인덱스 확인
df4.index
#value값 확인 
df4.values

□ reindex(재색인): 새로운 색인에 맞도록 객체를 새로 생성하는 기능
#series 생성: 인덱스가 sequence하지 않음 
obj = Series([10,20,30,40], index=['c','d','a','b'])

# 리인덱스를 통해서 sequence하게 만들 수 있음
obj2 = obj.reindex(['a','b','c','d'])
obj2

# 새로운 인덱스를 더할시에 그 값은 NaN이 됨 
obj3 = obj.reindex(['a','b','c','d','z'])
obj3

#필요한 것만 뽑아낼 때 reindex 응용하기 
obj4 = obj.reindex(['a','b','c'])
obj4




# -*- coding: utf-8 -*-
"""
Created on Fri Sep 14 09:46:58 2018

@author: stu
"""

import pandas as pd
from pandas import Series, DataFrame

Series
- 1차원배열

DataFrame
- 2차원배열 

□ .reindex() 
- 인덱스 배열을 변형하고자 할 때 사용
- 새로운 인덱스를 만들 때 사용
- NaN 값을 fill_value=0으로 만들 때 사용

obj = Series([10, 20, 30, 40], index =['c','d','a','b'])
obj


obj2 = obj.reindex(['a','b','c','d'])
obj2

# 'f' 인덱스는 없음 -> field 값은 NaN 으로 나타남
obj3 = obj.reindex(['a','b','c','d','f']) 
obj3

# fill_value=0 : NaN값을 0으로 바꿈 (직접 바꾸고 싶은 값으로 바꿀 때 fill_value사용)
obj4 = obj.reindex(['a','b','c','d','f'],fill_value=0)
obj4


▣ import numpy as np
import numpy as np

■ np.arange(): array 생성 #행렬을 만들 수 있음 
# array 생성
np.arange(4)

■ np.arange().reshape(,): 행렬생성
# 행렬 생성
np.arange(4).reshape(2,2)
np.arange(9).reshape(3,3)
np.arange(12).reshape(3,4)

df = DataFrame(np.arange(9).reshape(3,3), index=['a','b','c'], columns=['x','y','z'])
df

#d 인덱스가 없기 때문에 d는 NaN으로 만들어짐(적용됨)
df2 = df.reindex(['a','b','c','d'])
df2

□ method = 'ffill'/ method = 'pad'는 앞의 값으로 NaN을 채운다.
# method = 'ffill': NaN값이 앞에 있는 데이터가 채워짐 
df3 = df.reindex(['a','b','c','d'], method ='ffill')
df3 = df.reindex(['a','b','c','d'], method ='pad')
df3

obj = Series(['sql','r','python'], index=[0,2,4])
obj2 = obj.reindex(range(6))
obj2 = obj.reindex(range(6), method='ffill')
obj2

#method='bfill' 또는 'backfill'는 뒤의 값으로 NaN을 채운다.
obj2= obj.reindex(range(6), method='bfill')
obj2
obj2= obj.reindex(range(6), method='backfill')
obj2
obj2[5] = 'sql'
obj2

□ 행삭제 
obj = Series(np.arange(5), index=['a','b','c','d','e'])
obj
#행삭제: 꼭 적용을 시켜줘야 함
obj.drop('e') #미리보기만 해 줌
obj

obj = obj.drop('e')
obj

# 여러개의 값을 지울 수 있음
obj = obj.drop(['c','d'])
obj

#dataframe 삭제적용하기
df = DataFrame(np.arange(16).reshape(4,4), 
               index=['w','x','y','z'], 
               columns=['one','two','three','four'])
#삭제 미리보기
df.drop('x',axis=0) #axis=0:행
df.drop('four',axis=1) #axis=1:열

# 삭제 적용
df = df.drop(['w','y'], axis=0)
df

df = df.drop(['one','two'], axis=1)
df

□ 인덱스 보기
obj = Series([10,20,30,40], index=['a','b','c','d'])
obj
# indexing
obj['a']
obj[0]
obj[1:3]  #인덱스 번호
obj['b':'c'] #인데스 
# a하고 c만 보고 싶을 때: 안에 대괄호 필요 
obj['a','c'] #오류
obj[['a','c']]
obj[[0,2]]
# 30미만인 데이터 보기 
obj<30 #boolean 형식으로 데이터를 추출 
obj[obj<30] #30미만 데이터 추출

# dataframe 인덱스 보기
df = DataFrame(np.arange(16).reshape(4,4), 
               index=['w','x','y','z'], 
               columns=['one','two','three','four'])
df
df['one']
df[['one','two']]
df[2:]
df < 5
df[df<5]
df[df['one']<5]

#x행만 보여주기 
df.ix['x'] # .ix[]: 이름, 번호 모두 쓸 수 있음 
df.ix[0] # 번호로 인덱스 보기
df.loc['x'] # loc[]: 인덱스 이름, 컬럼이름만 가능 
df.loc[0] # error #loc[]인덱스 번호를 사용할 수 없
df.iloc[0] # iloc[]:인덱스 번호, 컬럼번호만 사용가능

df.ix['x','one']
df.ix['x',['one','two']]
#두개값을 보려고 할 때는 꼭 리스트 형으로 만들어서 표현해야한다.
df.ix[['x','y']]
df.ix[['x','y'],['one','two']]
#열에도 순번이 있기 때문에 리스트 모양으로 순번을 표현할 수 있다.
df.ix[['x','y'],[0,1]]
df.ix[0,'one']
df.ix[[0,2],[0,1]]

df.ix[:]
df.ix[0:2]
df.ix[0:2, 0:2]
df.ix[:,0:2]
df.ix[-1]
df.ix[:,-1]


##############################################################################################
※ 행과 열을 추출하는 방법: 매우 중요합니다. ※

[문제123] 아래와 같은 모양의 표를 생성하세요. 

      PYTHON   R  SQL
2014      60  90   50
2015      80  65   75
2016      70  75   85

#dictionary형을 먼저 만들어 생각해보기 
df = DataFrame({'PYTHON':[60,80,70],'R':[90,65,75],'SQL':[50,75,85]}, 
                index=['2014','2015','2016'])
df


[문제124] 'PYTHON' 열을 선택하세요
df.ix[:,'PYTHON']
df['PYTHON']

[문제125] '2014' 행 정보를 출력하세요.
df.ix['2014']
df.iloc[0]


[문제126] 인덱스번호를 기준으로 1부터 2번까지 출력하세요.
df.ix[1:3]
df[1:3]
df.iloc[1:3]

[문제127] PYTHON의 값을 기준으로 60보다 큰값을 가지고 있는 행 정보를 출력하세요.
df[df.ix[:,'PYTHON']>60]
df[df['PYTHON']>60]

[문제128] PYTHON의 값을 기준으로 60 보다 큰값을 가지고 있는 PYTHON 정보만 출력하세요.
df1 = df.ix[df['PYTHON']>60]
df1['PYTHON']

df.ix[df['PYTHON']>60, 'PYTHON']  #df['PYTHON']>60:행정보,/'PYTHON' 뒤에 열 정보를 추가하면 PYTHON정보만 추출한다.
df.ix[df['PYTHON']>60,'PYTHON'] 
df.loc[df['PYTHON']>60, 'PYTHON']
df['PYTHON'][df['PYTHON']>60]  #[df['PYTHON']>60]: 행제한

#SQL로 생각하기 'PYTHON'] , 'PYTHON'] ,'PYTHON'] : Select절 / df['PYTHON']>60: where절이라고 할 수 있음 

[문제129] '2015' 행값 중에 PYTHON 정보만 출력하세요
df.ix['2015','PYTHON']

[문제130] '2015' 행값 중에 PYTHON, R 정보 출력하세요 
df.ix['2015',['PYTHON','R']]

[문제131] 'R' 열 정보를 출력하세요.
df['R']
df.loc[:,'R']
df.ix[:,'R']

##############################################################################################

□ .at[열(인덱스 이름), 행(columns)]=값: 새로운 행 추가 
새로운 행을 추가: 2013년도 PYTHON: 70, SQL:90, R=85 추가한다.

df.at['2013','PYTHON'] = 70
df.at['2013','SQL'] = 90
df.at['2013','R'] = 85
df

#2013년도 정보 삭제
df=df.drop('2013')

#deprecated (곧 사라질 문법)
#cf. 예전 버전: .set_value(인덱스 이름,행,값)
df.set_value('2013','PYTHON',70)
df.set_value('2013','SQL',90)
df.set_value('2013','PYTHON',85)


#plsql 열을 추가해야 한다.
df.at['2013','PLSQL']=50
df.at['2014','PLSQL']=60
df.at['2015','PLSQL']=70
df.at['2016','PLSQL']=80

#삭제시: axis=0(행), axis=1(열)에 대해 신경쓰기
# axis=0 #행- 쓰지않으면 axis=0이 기본값으로 지정
df =df.drop('PLSQL',axis=1) #열 삭제



#행,열 추가 되면  밑,옆에 추가가 된다 -> 원하는 형식으로 행, 열을 정렬하기
df.at['2013','PYTHON'] = 70
df.at['2013','SQL'] = 90
df.at['2013','R'] = 85
df

df.at['2013','PLSQL']=50
df.at['2014','PLSQL']=60
df.at['2015','PLSQL']=70
df.at['2016','PLSQL']=80
df

# 원하는 행을 정렬하기
df = df.reindex(['2013','2014','2015','2016'])
df

# 열(column) 정렬하기
df = df.reindex(columns=['SQL','PLSQL','R','PYTHON'])
df

####################################################################################3
[문제132]PYTHON 점수가 80 이상 또는 SQL 점수가 90 이상인 데이터 출력하세요.
df[(df['PYTHON']>=80)|(df['SQL']>=90)]


[문제133] PYTHON 점수가 80 이상 이고 SQL 점수 90 이상인 데이터 출력하세요.
df[(df['PYTHON']>=80)&(df['SQL']>=90)]

#df[(df['PYTHON']>=80)&(df['SQL']>=70)]
####################################################################################3

□ pandas로 로드시키기
# 기존의 데이터 출력
import csv
file=open("c:/data/emp.csv",'r')
emp_csv = csv.reader(file)
next(emp_csv)

for emp_list in emp_csv:
    if emp_list[0] == "100": 
        print(emp_list[7])
 
#판다스로 데이터 로드시키기     
import pandas as pd       
emp = pd.read_csv("c:/data/emp.csv")        
emp


#데이터 정보 알아보기- 컬럼이름, 데이터 정보
emp.dtypes

#데이터 정보보기 - 전체건수, 컬럼이름, 데이터 정보, 메모리사용량
emp.info()
#cf. R에서 DATA정보를 알아보기 위해서는 str()

#100사원의 SALARY구하기
emp.ix[emp['EMPLOYEE_ID']==100, 'SALARY']
emp['SALARY'][emp['EMPLOYEE_ID']==100]


###############################################################################
[문제134] 직업이 ST_CLERK인 사원의 LAST_NAME, SALARY, JOB_ID를 출력해주세요.

emp[['LAST_NAME','SALARY','JOB_ID']][emp['JOB_ID']=="ST_CLERK"]

emp.ix[emp['JOB_ID']=="ST_CLERK",['LAST_NAME','SALARY','JOB_ID']]


###############################################################################
#student 데이터프레임만들
student = DataFrame([[60,80,70],[50,70,85],[90,80,95]],
                    index=['홍길동','박찬호','손흥민'],
                    columns=['영어','수학','국어'])
student

#데이터 추가하기
제임스 영어 100 수학 50 국어 80

student.at['제임스','영어'] = 100
student.at['제임스','수학'] = 50
student.at['제임스','국어'] = 80

student

#student_new 데이터프레임만들기
student_new = DataFrame([[60,70,80,],[50,75,85],[90,80,85]], 
                        index=['윤건','김건모','이문세'],
                        columns=['영어','수학','국어'])
student_new

# student1 데이터프레임만들기
student1 = DataFrame([[60,70,80,],[50,75,85],[90,80,85]], 
                        index=['싸이','나얼','윤상'],
                        columns=['영어','수학','국어'])

#기존 데이터프레임과 새로운 데이터프레임을 합치기
student = student.append(student_new)
student

□ pd.concat:기존 데이터프레임과 새로운 데이터프레임을 합치기
student = pd.concat([student,student1])
student

#컬럼정보, 데이터건수 확인 
student.info()
#열추가
student['과학'] = [100, 80, 90, 60, 50, 60, 70, 80, 70, 60]
student
#공통적으로 데이터 넣기(열추가)
student['한국사'] = '조선'
student
#과목만 추가하기(열만 추가)
student['음악'] = ''
student


##지우기
#열 지우기
del student['음악']
student

#축으로 지우기
student = student.drop('제임스',axis=0)
student

#열지우기 
student = student.drop('한국사',axis=1)
student

#데이터 찾기
student.ix['윤건']
student.loc['윤건']
student.xs('윤건', axis=0)
student.xs('영어') #error
student.xs('영어', axis=1)
student['영어']

#인덱스 이름 바꾸기 (딕셔너리 모양처럼 만들기)
student.rename(index={'윤상':'김상'}) #미리보기임 
student = student.rename(index={'윤상':'김상'})
student

#컬럼 이름 바꾸기
student =student.rename(columns={'과학':'물리'})
student


■ series끼리 연산하기
obj1 = Series([10,5,3,7],index=['a','b','c','d'])
obj2 = Series([2,4,6,8,10], index=['a','b','c','d','e'])

#series 사칙연산
obj1 *100

#더하기
#series 끼리 연산하기 - 인덱스 이름을 기준으로 연산한다. 
obj1 + obj2

#series 끼리 연살 할 때, 인덱스가 없는 것은 0으로 계산 작업을 하기
obj1.add(obj2, fill_value=0)

# 빼기
obj1-obj2
obj1.sub(obj2, fill_value=0)

# 곱하기
obj1*obj2
obj.mul(obj,fill_value=1)

#나누기
obj1/obj2
obj1.div(obj, fill_value=1)

■ dataframe 사칙연산: 인덱스를 기준으로 사칙연산
df1 = DataFrame(np.arange(6).reshape(2,3), 
                index=['2015','2016'], 
                columns=['python','sql','plsql'])
df1

df2 = DataFrame(np.arange(12).reshape(3,4),
                index=['2014','2015','2016'],
                columns = ['python','r','sql','plsql'])
df2

#
df1 + df2
df1.add(df2, fill_value=0)

#
df1.sub(df2, fill_value=0)

#
df1.mul(df2, fill_value=1)

#
df1.mul(df2, fill_value=1)


■ 브로드캐스팅(broadcasting): 하나의 값을 계속 중개해줌 
obj1 = np.arange(15).reshape(5,3)
obj1
obj2 = np.arange(3)
obj2


#브로드캐스팅: obj2 값은 [0,1,2]이므로 이 값이 계속 obj1의 다른 행에도 계속 돌아가면서 계산된다. 
#obj2가 obj1에 맞게 모양을 바꾼다. 
obj1 + obj2
obj1 - obj2
obj1 * obj2
obj1 / obj2


■자동으로  브로드캐스팅(broadcasting)이 안될 때 
#
obj2.repeat(5)
obj2.repeat(5).reshape(5,3)
obj2.repeat(5).reshape(3,5)
obj2.repeat(5).reshape(3,5).T

# 결과 값 같음 
obj1 + obj2.repeat(5).reshape(3,5).T
obj1 + obj2

■ 리스트 내장객체
df1 = DataFrame(np.arange(15).reshape(5,3),
                index=[str(i) for i in range(2012,2017)],
                columns = ['a','b','c'])
df1
type(df1)

#
s = df1.ix[0]
s
type(s)

# broadcasting이 여기서도 돌아감 
df1 + s

##연산작업을 할 때는 일반적으로 type을 일치시켜야 하지만 꼭 일치하지 않아도 broadcasting이 돌아가 연산이 된다. 

■ 정렬 
□ .sort_index(): 인덱스를 기준으로 오름차순 정렬 
obj = Series([2,3,5,6], index=['d','c','b','a'])
obj
obj.sort_index()
obj.sort_index(ascending=False)

□ .sort_values(): value를 기준으로 오름차순 정렬
obj.sort_values()
obj.sort_values(ascending=False)


□ dataframe정렬: sort.index() 
df = DataFrame(np.arange(8).reshape(2,4), 
               index=['two','one'],
               columns=['d','a','c','b'])
df               
#
df.sort_index()
df.sort_index(ascending=False)
df.sort_index(axis=0)
df.sort_index(axis=1) # 0: row, 1:column
df.sort_index(ascending=False, axis=1)

□ dataframe정렬: sort.values() 
# b라는 열을 기준으로 오름차순 정렬 
df.sort_values(by = 'b')

# b라는 열을 기준으로 내림차순 정렬 
df.sort_values(by = 'b', axis=0 , ascending=False)

#one이라는 행을 기준으로 열들의 내림차순 정렬
df.sort_values(by = 'one', axis=1 , ascending=False)




# -*- coding: utf-8 -*-
"""
Created on Mon Sep 17 09:40:05 2018

@author: stu
"""
###############################################################################################################
[문제134] emp.csv 파일의 데이터를 판다스를 이용해서 읽어 들인 후 급여가 10000 이상인 사원들의 이름, 급여, 입사일을 출력해주세요.

import pandas as pd

emp = pd.read_csv("c:/data/emp.csv")
emp.head()
emp.tail(10)
emp.info()

#답1
emp[['LAST_NAME','SALARY', 'HIRE_DATE']][emp['SALARY']>=10000]

#답2 
emp.ix[emp['SALARY']>=10000, ['LAST_NAME', 'SALARY', 'HIRE_DATE']] #보편적으로 없어질 method 

#답3
emp.loc[emp['SALARY']>=10000, ['LAST_NAME', 'SALARY', 'HIRE_DATE']]


[문제135] 급여 10000 이상인 사원들의 이름과 급여, 입사일를 출력하세요. 급여를 기준으로 내림차순하세요.

#답1
emp[['LAST_NAME','SALARY', 'HIRE_DATE']][emp['SALARY']>=10000].sort_values(by='SALARY', ascending=False)

#답2
emp.ix[emp['SALARY']>=10000, ['LAST_NAME', 'SALARY', 'HIRE_DATE']].sort_values(by='SALARY', ascending=False)

#답3
emp.loc[emp['SALARY']>=10000, ['LAST_NAME', 'SALARY', 'HIRE_DATE']].sort_values(by='SALARY', ascending=False)

# sort_values(by=['SALARY', 'HIRE_DATE'])와 같이 sort.vlaue에 해당하는 열은 리스트 모양으로 여러개 넣을 수 있다. 
# emp.loc[emp['SALARY']>=10000, ['LAST_NAME', 'SALARY', 'HIRE_DATE']].sort_values(by=['SALARY', 'HIRE_DATE'], ascending=False)


###############################################################################################################

obj = Series([78, 88, 92, 79, 67, 91, 70, 86, 90, 90])

#값을 기준으로 오름차순 정렬
obj.sort_values()

#값을 기준으로 내림차순 정렬
obj.sort_values(ascending=False)

#rank 구하기  (cf. sql의 분석함수 같이 공부하기)
#동일한 순위일 경우 일 경우 평균값으로 할지, 최소값으로 할지, 최대값으로 할지 결정할 수 잇다. 
# 오름차순 순위: eg. 67이 있는 위치(4)에 1로 표기됨, 78이 있는 위치(6)에 2로 표기됨
# 기본값: 동일한 순위일 경우 일 경우 평균값으로 표현
obj.rank() 

obj.rank(ascending=False)

#동일값일 때 평균으로 출력함 (기본값)
obj.rank(ascending=False, method='average')

#최소값인 동일한 순위로 나옴 (4등은 없음)
obj.rank(ascending=False, method='min')

#최대값인 동일한 순위로 나옴 (3등은 없음)
obj.rank(ascending=False, method='max')

#동일한 동률일 경우 index가 앞을 경우 먼저 순위를 줌 (e.g.90점이 8인덱스를 가진 경우 3위, 9인덱스를 가진경우 4위)
obj.rank(ascending=False, method='first')


#sql의 기존의 rank와 같음(e.g, 1,2,3,3,5 로 표현)
obj.rank(ascending=False, method='min')


#sql의 dense_rank와 같음: 연이은 정수로 표현(e.g., 1,2,3,3,4... 로 표현)
obj.rank(ascending=False, method='dense')

#series를 하나의 열로 들어가고, 순위도 하나의 열로 들어가 dataframe으로 만들기
obj1= DataFrame({'순위':obj.rank(ascending=False, method='dense'),
            '점수':obj})

#순위로 정렬하기
obj1.sort_values(by='순위')


import numpy as np
#NaN값 만들기 
obj2 = Series([70,60,80,np.nan,90])
obj2

#정렬을 하면 오름차순, 내림차순 모두 null값이 맨 뒤에 출력된다.
obj2.sort_values()
obj2.sort_values(ascending=False)
#cf. sql의 null값은 -> 오름차순: 제일 밑에/ 내림차순: 제일 위에


#NaN값을 제일 앞으로
obj2.sort_values(ascending=False, na_position='first')

#NaN값을 제일 뒤로
obj2.sort_values(ascending=False, na_position='last')


# NaN은 순위를 적용해도 무시됨 
obj2.rank()
obj2.rank(ascending=False)
#NaN값이 순위를 적용해도 무시됨: 기본값 na_option='keep'
obj2.rank(na_option='keep')
#na_option='top': NaN값이 1등으로 출력됨 
obj2.rank(na_option='top')
obj2.rank(ascending=False, na_option='top')
#na_option='bottom': NaN값이 꼴등으로 출력됨 
obj2.rank(na_option='bottom')
obj2.rank(ascending=False, na_option='bottom')



#
df = DataFrame({'영어':[60,80,70], '수학':[50,72,86]},
                index=['홍길동','박찬호','손흥민'])
df
#수학을 기준으로 정렬
df.sort_values(by='수학')
df.sort_values(by='수학', ascending=False)
#수학 데이터만 보기 
df['수학'].sort_values(ascending=False)
# rank 구하기 (과목별로 순위값이 자동으로 만들어짐)
 df.rank(ascending=False)
# 각 학생이 잘하는 과목에 대해 rank를 해줌  (axis=1 열이기 때문에 영어, 수학을 두 기준으로 순위를 구함)
df.rank(ascending=False, axis=1)
#영어에 대한 rank보기
df['영어'].rank(ascending=False)
# 홍길동에 대한 rank만 보기
df.ix['홍길동'].rank(ascending=False)


########################################################################################
[문제136] 급여를 많이 받는 순으로 10위 까지를 구하세요. 


import pandas as pd
emp.info()
emp = pd.read_csv("c:/data/emp.csv")
emp['SALARY'].rank(ascending=False, method='min').sort_values()[0:10]

DataFrame({'사원명':emp['LAST_NAME'], 
               '급여':emp['SALARY'],
               '순위':emp['SALARY'].rank(ascending=False, method='min')}).sort_values(by='순위')[0:10]

#좀 더 생각해보기 
s=DataFrame({'사원명':emp['LAST_NAME'],
           '급여':emp['SALARY'],
           '순위':emp['SALARY'].rank(ascending=False, method='dense')})
s.sort_values(by='순위')


#쌤답
emp[emp['SALARY'].rank(ascending=False, method='dense')<=10][['EMPLOYEE_ID', 'LAST_NAME', 'SALARY']]    
또는 

emp['rank'] = emp['SALARY'].rank(ascending=False, method='dense')
emp[emp['rank']<=10].sort_values('rank')
########################################################################################

□ pandas에서의 in 연산자

df = DataFrame({'영어':[60,80,70], '수학':[50,72,86]},
                index=['홍길동','박찬호','손흥민'])
df

# in 연산자: 이 조건의 값을 출력
df[df['수학'].isin([72,86])] #행을 제한하는 부분

# ~: not in 연산자의 의미로, 이 조건의 반대를 의미
df[~df['수학'].isin([72,86])]


########################################################################################
[문제137] 직업이 AD_VP, AD_PRES 인 사원들의 이름, 급여, 직업을 출력하세요.

import pandas as pd
emp.info()
emp = pd.read_csv("c:/data/emp.csv")

emp[emp['JOB_ID'].isin(['AD_VP','AD_PRES'])][['LAST_NAME','SALARY','JOB_ID']] #제한을 먼저 한 다음, 열을 가져옴 

emp[['LAST_NAME','SALARY','JOB_ID']] [emp['JOB_ID'].isin(['AD_VP','AD_PRES'])]



[문제138] 직업이 AD_VP ,AD_PRES 아닌 사원들의 이름, 급여, 직업을 출력하세요.
import pandas as pd
emp.info()
emp = pd.read_csv("c:/data/emp.csv")
emp[~emp['JOB_ID'].isin(['AD_VP','AD_PRES'])][['LAST_NAME','SALARY','JOB_ID']]

emp[['LAST_NAME','SALARY','JOB_ID']][~emp['JOB_ID'].isin(['AD_VP','AD_PRES'])]
########################################################################################

# NaN을 넣는 방법 
obj = Series([1,2,3,None,5])
obj

import numpy as np
obj = Series([1,2,3,np.nan,5])
obj

from numpy import nan as NA
obj = Series([1,2,3,NA, 5])
obj


#NaN에 0으로 채우기
obj.fillna(0) #미리보기임 (적용은 아님)

#NaN이 값을 True로 출력
obj.isnull()

#NaN이 값을 True로 출력 by Pandas
pd.isnull(obj)

#NaN 아닌 값을 True로 출력
obj.notnull()

#NaN값만 출력하기
obj[obj.isnull()]

#NaN아닌 값만 출력하기
obj[obj.notnull()]
obj.dropna()


# (from numpy import nan as NA로 만들어 놨기 때문에 NA사용 가능)
df = DataFrame([[1,2,3],[1,None,NA],[NA,NA,NA],[NA,2,3]])
df
#NaN이 하나라도 있으면 제외가 됨 
df.dropna()
df.dropna(how='all')
df.dropna(how='all', axis=0)  #0은 행을 기준
df.dropna(how='all', axis=1)  #1은 열을 기준
df.dropna(axis=0)
df.dropna(axis=1)

df[4] = NA
df.dropna(how='all', axis=1)


#NaN을 0으로 채움 
df.fillna(0)

#0번 열에만 0을 채움
df[0].fillna(0)

#1번 컬럼에는 0을, 1번 컬럼에는 1, 2번 컬럼에는 2, 4번컬럼에는 4를 채우고자 함
df.fillna({0:0, 1:1, 2:2, 4:4})

# NaN을 0으로 채우는 것이 적용됨
df.fillna(0, inplace=True)
df

#앞에 있는 내용으로 NaN를 채움
df.fillna(method='ffill')
df.fillna(method='pad')

#뒤에 있는 내용으로 NaN을 채움
df.fillna(method='bfill')
df.fillna(method='backfill')

########################################################################################
[문제139] 커미션이 null인 사원의 이름, 커미션을 출력하세요.
import pandas as pd
emp = pd.read_csv("c:/data/emp.csv")

#답1
emp[['LAST_NAME','COMMISSION_PCT']][emp['COMMISSION_PCT'].isnull()]

#답2
emp[emp['COMMISSION_PCT'].isnull()][['LAST_NAME','COMMISSION_PCT']]

#답3
emp.ix[emp['COMMISSION_PCT'].isnull(),['LAST_NAME','COMMISSION_PCT']]

#답4
emp.loc[emp['COMMISSION_PCT'].isnull(),['LAST_NAME','COMMISSION_PCT']]

[문제140] 커미션이 null아닌 사원의 이름, 커미션을 출력하세요.
import pandas as pd
emp = pd.read_csv("c:/data/emp.csv")
#답1
emp[['LAST_NAME','COMMISSION_PCT']][emp['COMMISSION_PCT'].notnull()]

#답2
emp[emp['COMMISSION_PCT'].notnull()][['LAST_NAME','COMMISSION_PCT']]

#답3
emp.ix[emp['COMMISSION_PCT'].notnull(),['LAST_NAME','COMMISSION_PCT']]

#답4
emp.loc[emp['COMMISSION_PCT'].notnull(),['LAST_NAME','COMMISSION_PCT']]
########################################################################################
▣ apply 함수
- apply함수는 행, 열값을 인수값으로 받아서 반복하여 그 함수를 적용한다. 

#series
s1 = Series([1,2,3])

def square(x):
    return x**2

#함수사용 
square(s1)
#error
s1.square()
#apply사용
s1.apply(square)
#lambda 사용
s1.apply(lambda x:x**2)


#dataframe
df = DataFrame([[1,2,3],[4,5,6]])
df
df.apply(square)
df.apply(square, axis=0)
df.apply(square, axis=1)

#행을 기준으로 열을 합함
df.apply(sum, axis=0)
#열을 기준으로 행을 합함
df.apply(sum, axis=1)
#
df.apply(lambda x:x**2)




########################################################################################
[문제141] last_name 첫글자가 S로 시작되는 사원들의 last_name을 출력하세요.

#답1
def ini(x):
    for i in range(len(x)):
        if x[i][0]=='S':
            print(x[i])

ini(emp['LAST_NAME'])

#답2
emp[emp['LAST_NAME'].apply(lambda x:x[0]=='S')]['LAST_NAME']

#답3
def start(x):
    for i in range(len(x)):
        if x[i].startswith('S'):
            print(x[i])
            
start(emp['LAST_NAME'])


#쌤답
def first_character(w):
    if w[0] == 'S':
        return True
    return False

emp['LAST_NAME'][emp['LAST_NAME'].apply(first_character)]
emp[emp['LAST_NAME'].apply(first_character)]['LAST_NAME']
emp.ix[emp['LAST_NAME'].apply(first_character),'LAST_NAME']

emp.ix[emp['LAST_NAME'].apply(lambda x:x[0]=='S'),'LAST_NAME']
emp.ix[emp['LAST_NAME'].apply(lambda x:x[0])=='S','LAST_NAME']
emp.ix[emp['LAST_NAME'].apply(lambda x:x.startswith('S')),'LAST_NAME']


[문제142] last_name g로 끝나는 사원들의 이름, 급여 출력하세요.
#답1
def last(x, y):
    for i in range(len(x)):
        if x[i][-1] == 'g':
            print(x[i],y[i])
            
last(emp['LAST_NAME'],emp['SALARY'])     
       
#답2
def last_character(w):
    if w[-1] == 'g':
        return True
    return False

emp[['LAST_NAME','SALARY']][emp['LAST_NAME'].apply(last_character)]

#답3
emp.ix[emp['LAST_NAME'].apply(lambda x:x[-1]=='g'),['LAST_NAME','SALARY']]
#답4
emp.ix[emp['LAST_NAME'].apply(lambda x:x.endswith('g')),['LAST_NAME','SALARY']]


[문제143] 110번 사원의 급여보다 많이 받는 사원들의 이름, 급여를 출력하세요.
#일반적인 data인 scalar형식에서 가져왔다면 문제가 되지 않지만, dataframe은 series형식으로 가져오기 때문에 이 부분을 고려해야하는 문제이다. 
import pandas as pd
emp = pd.read_csv("c:/data/emp.csv")
emp.info()

#답1
emp101 = emp['SALARY'][emp['EMPLOYEE_ID']==110]
emp[['LAST_NAME','SALARY']][emp['SALARY']> int(emp101)]

#답2
emp[['LAST_NAME','SALARY']][emp['SALARY']>int(emp['SALARY'][emp['EMPLOYEE_ID']==110])]

#쌤답 
-int를 함수를 이용하면 scalar 값으로 return함
-v_110.values[0]을 사용하면 값을 추출함 

v_110 = emp[emp['EMPLOYEE_ID']==110]['SALARY']
type(v_110)
emp[emp['SALARY'] > int(v_110)][['LAST_NAME','SALARY']]
emp[emp['SALARY'] > v_110.values[0]][['LAST_NAME','SALARY']]


[문제144] 관리자 사원의 이름, 입사일, 급여를 출력하세요.
#답1
emp[['LAST_NAME','HIRE_DATE','SALARY']][emp['EMPLOYEE_ID'].isin(emp['MANAGER_ID'])]

#답2
file = open("c:/data/emp.csv",'r')
emp_csv = csv.reader(file)
next(emp_csv)
manager_id=[]
for emp_list in emp_csv: 
    manager_id.append(emp_list[-2])
print(set(manager_id))
file.close()  

file = open("c:/data/emp.csv",'r')
emp_csv = csv.reader(file)
next(emp_csv)
for emp_list in emp_csv:
    if emp_list[0] in manager_id:
        print(emp_list[2], emp_list[5], emp_list[7])
file.close()  

#답3 #유일값만 넣기 위해 
file = open("c:/data/emp.csv",'r')
emp_csv = csv.reader(file)
next(emp_csv)
v_mgr = []
for emp_list in emp_csv:
    if (not emp_list[9] in v_mgr) & (emp_list[9] != ''):
        v_mgr.append(emp_list[9])
print(len(v_mgr))
file.close()

file = open("c:/data/emp.csv",'r')
emp_csv = csv.reader(file)
next(emp_csv)
for emp_list in emp_csv:
    for mgr in v_mgr:
        if emp_list[0]==mgr:
            print(emp_list[2], emp_list[5], emp_list[7])
file.close()


 
 # -*- coding: utf-8 -*-
"""
Created on Tue Sep 18 09:45:21 2018

@author: stu
"""

#################################################################################################
[문제145] 101번 사원의 관리자 이름, 입사일, 급여정보를 출력하세요.
1. pandas를 이용해서 해결

import pandas as pd
emp = pd.read_csv('c:/data/emp.csv')
emp[['LAST_NAME','HIRE_DATE','SALARY']][emp['EMPLOYEE_ID'].isin(emp['MANAGER_ID'][emp['EMPLOYEE_ID']==101])]

# 쌤답
import pandas as pd
emp = pd.read_csv('c:/data/emp.csv')
mgr =emp[emp['EMPLOYEE_ID']==101]['MANAGER_ID']
emp[emp['EMPLOYEE_ID']==mgr.values[0]][['LAST_NAME','HIRE_DATE', 'SALARY']]
emp[emp['EMPLOYEE_ID']==int(mgr)][['LAST_NAME','HIRE_DATE', 'SALARY']]

2. 일반적으로 csv 파일을 읽어서 해결

import csv
file = open('c:/data/emp.csv','r')
emp_csv =csv.reader(file)
next(emp_csv)
for emp_list in emp_csv:
    if emp_list[0]=='101':
       manager_id = emp_list[-2]
file.close()
        
file = open('c:/data/emp.csv','r')
emp_csv = csv.reader(file)
next(emp_csv)
for emp_list in emp_csv:
    if emp_list[0] == manager_id:
        print(emp_list[2], emp_list[5], emp_list[7])
file.close()        



#쌤답
import csv
file = open('c:/data/emp.csv','r')
emp_csv =csv.reader(file)
next(emp_csv)
v_mgr = []
for emp_list in emp_csv:
    if emp_list[0] == '101':  #sql문장시 full scan유발 ->  filter 술어 체크 : index가 중요함 
        v_mgr.append(emp_list[9])
file.close()

#filter 술어: 어느 위치에 문장이 있는지 모르기 때문에 모두 스캔 해야함 -> full scan유발 
#aceess술어: rawid를 알고 어느 위치에 있는지 찾아가는 형태의 scan -> 

import csv
file = open('c:/data/emp.csv','r')
emp_csv =csv.reader(file)
next(emp_csv)
for emp_list in emp_csv:
    if emp_list[0] == v_mgr[0]:  #list 변수이기 대문에 v_mgr[0]으로 표시
        print(emp_list[2], emp_list[5], emp_list[7])
file.close()


#################################################################################################

■ pandas에서 그룹함수 적용

import numpy as np

from pandas import Series, DataFrame

s = Series([2, 4, 8, np.nan, 6])

s.sum()
s.sum(skipna=True)
s.sum(skipna=False)


# skipna= True가 돌아가고 있음 
s.mean()
s.var()   #표본집단인기 때문에 n-1로 나눔
s.std()
s.max()
s.min()
#누적의 합 
s.cumsum()  
#최소값의 인덱스
s.idxmin()
s[s.idxmin()]
#최대값의 인덱스
s.idxmax()
s[s.idxmax()]


s = Series([2, 4, 8, np.nan, 6, 8, 2]) #최소값 2개, 최대값 2개
# 최소값이 2개 이지만 최소값의 처음 값의 인덱스만 return, 뒤의 인덱스는 return하지 않음
s.idxmin()

# 최대값이 2개 이지만 최대값의 처음 값의 인덱스만 return, 뒤의 인덱스는 return하지 않음
s.idxmax()

# 최소값, 최대값 인덱스 모두 구하기 
s[s==s.min()]
s[s==s.max()]

#인덱스만 보겠음
s[s==s.min()].index
#value값만 보겠음 -> array형으로 나옴 
s[s==s.min()].values

#4분위수를 포함하여 요약
s.describe()
#NaN을 포함하지 않은 갯수가 나옴
s.count()
#NaN을 포함하여 갯수가 나옴 
len(s)

#
df = DataFrame([[60,80,70],[50,75,83],[90,83,81]],
               index=['홍길동', '박찬호', '손흥민'],
               columns=['영어','수학','국어'])
df
#과목별로 sum이 됨: axis= 0
df.sum()
# 행단위로 sum
df.sum(axis=0)
df.sum(axis='rows')
#열단위로 sum
df.sum(axis=1)
df.sum(axis='columns')

#
df.mean()
df.mean(axis=1)

# df의 dataframe에 한 행을 추가하기 
제임스 영어: 100, 수학: np.nan, 국어:90
df.at['제임스','영어']= 100
df.at['제임스', '수학']=np.nan
df.at['제임스', '국어'] = 90

#
df.sum()
df.mean()
df.mean(skipna=False)
df.mean(axis=1, skipna=False)

#
df.idxmin()
df.idxmax()
df.cumsum()

#
df['영어'].sum()
df['영어'].mean()
df['영어'].var()
df['영어'].std()
df['영어'].max()
df['영어'].min()
# 홍길동 학생의 점수 합
df.loc['홍길동'].sum()
# 데이터 요약 
df.describe()


#################################################################################################

[문제146] 최고 급여, 최저 급여 출력하세요.

#pandas이용
import numpy as np
from pandas import Series, DataFrame

print(emp['SALARY'].max())
print(emp['SALARY'].min())

#import csv 사용 -최대값 
import csv
file = open('c:/data/emp.csv','r')
emp_csv = csv.reader(file)
next(emp_csv)
max_sal = 0
for emp_list in emp_csv:
    if int(emp_list[7]) > max_sal:
            max_sal = int(emp_list[7])
print(max_sal)
   
#import csv 사용 -최소값 
import csv
file = open('c:/data/emp.csv','r')
emp_csv = csv.reader(file)
next(emp_csv)
min_sal = 1000000000  #고민해보기 
for emp_list in emp_csv:
    if int(emp_list[7]) < min_sal:
            min_sal = int(emp_list[7])
print(min_sal)

#
import csv
file = open('c:/data/emp.csv','r')
emp_csv = csv.reader(file)
next(emp_csv)
for emp_list in emp_csv:
    for i in range(len(emp_list)):
        print(emp_list[i][7]]])
    
    if int(emp_list[7]) < min_sal:
            min_sal = int(emp_list[7])
print(min_sal)


#
import csv

file = open("c:/data/emp.csv","r")
emp_csv = csv.reader(file)
next(emp_csv)
sal_max, sal_min = next(emp_csv)[7], next(emp_csv)[7]
print(sal_max)
print(sal_min)
for emp_list in emp_csv:
    if int(emp_list[7]) >= sal_max:
        sal_max = int(emp_list[7])
    if int(emp_list[7]) <= sal_min:
        sal_min = int(emp_list[7])
print("최고 급여 : {}, 최저 급여 : {}".format(sal_max,sal_min))

file.close()
#
import csv
sal_max, sal_min = int(next(emp_csv)[7]), int(next(emp_csv)[7])
file = open("c:/data/emp.csv","r")
emp_csv = csv.reader(file)
next(emp_csv)

for emp_list in emp_csv:
    if int(emp_list[7]) >= sal_max:
        sal_max = int(emp_list[7])
    if int(emp_list[7]) <= sal_min:
        sal_min = int(emp_list[7])
print("최고 급여 : {}, 최저 급여 : {}".format(sal_max,sal_min))



     
#쌤답-최대값 
import csv
file = open('c:/data/emp.csv','r')
emp_csv = csv.reader(file)
next(emp_csv)
sal = 0
for emp_list in emp_csv:
    if int(emp_list[7]) > int(sal):
        sal = emp_list[7]
print(sal)

#쌤답-최소값 
import csv
file = open('c:/data/emp.csv','r')
emp_csv = csv.reader(file)
next(emp_csv)
sal = 10000000000
for emp_list in emp_csv:
    if int(emp_list[7]) < int(sal):
        sal = emp_list[7]
print(sal)

#참고 
import csv
file = open('c:/data/emp.csv','r')
emp_csv = csv.reader(file)
next(emp_csv)
sal = []
for emp_list in emp_csv:
    sal.append(int(emp_list[7]))
print(max(sal))  
print(min(sal))
# max, min은 python에 있는 내장객체 



[문제147] 20번 부서 사원들의 급여 합을 구하세요.

#pandas이용
import numpy as np
from pandas import Series, DataFrame
emp['SALARY'][emp['DEPARTMENT_ID']==20].sum()

#import csv 파일 
import csv
file = open('c:/data/emp.csv','r')
emp_csv = csv.reader(file)
next(emp_csv)
sal = 0
for emp_list in emp_csv:
    if emp_list[10]=='20':
        sal += int(emp_list[7])
print(sal)


# emp_new 파일 
import pandas as pd
emp = pd.read_csv('c:/data/emp_new.csv', names=['empid','name','job','mgr','hire_date','sal','comm','deptno'])
print(emp['sal'][emp['deptno']==20].sum())


import csv
file = open('c:/data/emp_new.csv','r')
emp_csv = csv.reader(file)
sal = 0
for emp_list in emp_csv:
    if emp_list[7]=='20':
        sal += float(emp_list[5])
print(sal)


[문제148] 부서번호를 입력하면 그 부서의 급여 총액을 구하는 함수를 생성하세요.

dept_sum_sal()

부서번호를 입력하세요 :  20

19000.0


dept_sum_sal()

부서번호를 입력하세요 :  30

24900.0


import numpy as np
from pandas import Series, DataFrame

# 답
def dept_sum_sal():
    x=int(input('부서번호를 입력하세요 : '))
    print(emp['SALARY'][emp['DEPARTMENT_ID']==x].sum())
dept_sum_sal()

#쌤답1
def dept_sum_sal():
    emp=pd.read_csv('c:/data/emp_new.csv',names=['empid','name','job','mgr','hire_date','sal','comm','deptno'])
    id = input('부서를 입력하세요: ' )
    print(emp.loc[emp['deptno']==int(id),'sal'].sum())
dept_sum_sal()

#쌤답2
def dept_sum_sal():
    import csv
    file = open('c:/data/emp_new.csv','r')
    emp_csv = csv.reader(file)
    sal = 0
    id = input('부서번호를 입력하세요 : ')
    for emp_list in emp_csv:
        if emp_list[7] == id:
            sal += int(emp_list[5])
    print(sal)
    file.close()
    
dept_sum_sal()

[문제149] 직업을 물어보게하고 직업을 입력하면 해당 직업의 최고 급여를 출력되게하는데 아무것도 입력하지 않으면 계속 물어보게하는
프로그램을 작성하세요.

job_max_sal()

직업을 입력하세요 ?  ST_CLERK
3600.0

job_max_sal()

직업을 입력하세요 ? sa_rep
11500.0

job_max_sal()

직업을 입력하세요 ? 

직업을 입력하세요 ? 

직업을 입력하세요 ? 

job_max_sal()

직업을 입력하세요 ? sales
해당 직업의 사원은 없습니다.

import pandas as pd
emp=pd.read_csv('c:/data/emp.csv')
job = input("직업을 입력하세요 ? ")
if 'job.upper()' in (emp['JOB_ID']):
    print(max(emp['SALARY'][emp['JOB_ID']=='job.upper']))
elif 'job.upper()' not in (emp['JOB_ID']):
    print('해당 직업의 사원은 없습니다.)
elif 'job' = '':
    print("직업을 입력하세요?")

while jo
    print("직업을 입력하세요?") 
    

import pandas as pd
emp=pd.read_csv('c:/data/emp.csv')
max(emp['SALARY'][emp['JOB_ID']=='ST_CLERK'])

import pandas as pd
emp=pd.read_csv('c:/data/emp.csv')
emp['JOB_ID']

if ST_CLEKR in emp['JOB_ID']:
    print('ST_')

# try -except: 한 쌍 -> excetpion 처리
# user define  -> raise 문 
#쌤답1
import pandas as pd 
def job_max_sal():
    try:
        emp =pd.read_csv('c:/data/emp_new.csv',names=['empid','name','job','mgr','hire_date','sal','comm','deptno'])
        name = ''
        while name =='':
            name = input('직업을 입력하세요? ' )
        maxsal = emp['sal'][emp['job']==name.upper()].max()
        if pd.isnull(maxsal):   #pd의 null값 검출 
            raise Exception
        return maxsal
    except Exception as err:
        print('해당 직업의 사원은 없습니다.')

job_max_sal()

#쌤답2
def job_max_sal():
    try:
        import  csv
        file = open("c:\data\emp_new.csv",'r')
        emp_csv = csv.reader(file)
        name = ''
        sal = []
        while name =='':
            name = input('직업을 입력하세요 ? ')
        
        for emp_list in emp_csv:
            if emp_list[2] == name.upper():
                sal.append(int(emp_list[5]))
        maxsal = max(sal)
        if maxsal=='':   #null값 검출 
            raise Exception
        return maxsal
    except Exception as err:
        print ('해당 직업의 사원은 없습니다.')

job_max_sal()




[문제150]부서번호,급여를 기준으로 내림차순 정렬해서 아래 화면처럼 컬럼정보를 출력하세요.


     deptno  empid         name      sal
105   110.0    205      Higgins  12008.0
106   110.0    206        Gietz   8300.0
8     100.0    108    Greenberg  13208.8
9     100.0    109       Faviet   9900.0
10    100.0    110         Chen   8200.0
12    100.0    112        Urman   7800.0
11    100.0    111      Sciarra   7700.0
13    100.0    113         Popp   6900.0

#답
import pandas as pd 
emp =pd.read_csv('c:/data/emp_new.csv',names=['empid','name','job','mgr','hire_date','sal','comm','deptno'])
emp[['deptno','empid','name','sal']].sort_values(by=['deptno', 'sal'], ascending=False)


[문제151] index 번호 0부터 50까지 부서번호, 급여를 기준으로 내림차순 정렬한 후 아래결과처럼 출력하세요.


    deptno  empid         name      sal
8    100.0    108    Greenberg  13208.8
9    100.0    109       Faviet   9900.0
10   100.0    110         Chen   8200.0
12   100.0    112        Urman   7800.0
11   100.0    111      Sciarra   7700.0
13   100.0    113         Popp   6900.0

#답 
import pandas as pd 
emp =pd.read_csv('c:/data/emp_new.csv',names=['empid','name','job','mgr','hire_date','sal','comm','deptno'])
print(emp.ix[0:50][['deptno','empid','name','sal']].sort_values(by=['deptno', 'sal'], ascending=False))
#emp.ix[0:50] 행제한 


[문제152] 50번 부서 사원들의 정보를 급여를 기준으로 내림차순 정렬해서 해서 아래 화면처럼 컬럼정보를 출력하세요.

   empid         name  deptno     sal
21    121        Fripp    50.0  8200.0
20    120        Weiss    50.0  8000.0
22    122     Kaufling    50.0  7900.0
23    123      Vollman    50.0  6500.0
24    124      Mourgos    50.0  5800.0
84    184     Sarchand    50.0  4200.0


#답
import pandas as pd
emp = pd.read_csv("c:\data\emp_new.csv", names = ['empid','name','job','mgr','hire_date','sal','comm','deptno'])
print(emp[emp[['deptno','empid','name','sal']]["deptno"]==50].sort_values(by=['deptno','sal'],ascending=False))



[문제153] 10,20,30,40,50번 부서 사원들의 급여의 총액을 출력하세요.

<화면출력>

10 4400.0
20 19000.0
30 24900.0
40 6500.0
50 156400.0

import pandas as pd 
emp =pd.read_csv('c:/data/emp_new.csv',names=['empid','name','job','mgr','hire_date','sal','comm','deptno'])
for i in [10,20,30,40,50]:
    print (i, emp.loc[emp['deptno']==i, 'sal'].sum())
#emp.loc    


[문제154] s 변수에 값들 중에 unique한 값만 s_uniuqe변수에 넣어주세요.
s = [1,2,3,4,1,2,3,4,5,1,2,3,4,5,6,'']

#답
s_unique = []
for i in s:
    if i not in s_unique:
        s_unique.append(i)
    elif i in (s_unique):
        pass
print(s_unique)

#쌤답
s_unique = []
for s_list in s:
    if not s_list in s_unique:
        s_unique.append(s_list)
print(s_uniuqe)



# null값을 제외하기 
s_unique = []
for s_list in s:
    if (not s_list in s_unique) and (s_list != ''):
        s_unique.append(s_list)
print(s_unique)


s 변수에 값들의 빈도수 구해주세요.  #dictionary 형 생각하기 

s = [1,2,3,4,1,2,3,4,5,1,2,3,4,5,6,'']

freq = {}
for i in s:
    if i in freq:
        freq[i] += 1
    else:
        freq[i] = 1
print(freq)

#null 빼기
freq = {}
for i in s:
    if i in freq:
        freq[i] += 1
    else:
        if i != '':
            freq[i] = 1
print(freq)

########################################################################################################

import numpy as np
from pandas import Series,DataFrame
s = Series([1,2,3,4,1,2,3,4,5,1,2,3,4,5,6,np.nan])

#Series에서 유일값 출력하기
#unique(): series에서 유일값 뽑기 
ss = s.unique()
ss
#자료형이 array인되서  dropna로 nan값을 지울 수 없음 
ss.dropna()
#NaN 지우기 - data유형을 series로 바꿔서 만들어 주면 dropna를 사용할 수 있음
ss= Series(s.unique())
ss.dropna()

#값이 인덱스가 되고, 건수가 형성됨(sort를 통해 인덱스를 정렬할 수 있음)
s.value_counts()
s.value_counts(sort=True)
s.value_counts(sort=False)

#기술통계값으로 상대비율(값이 전체중에 몇 프로인지 출력함)
s.value_counts(normalize=True)

#dictionary값에 대해 상대 비율을 출력하기 
freq = {}
for i in s:
    if i in freq:
        freq[i] += 1
    else:
        freq[i] = 1
print(freq)

t = len(s)
for k,v in freq.items():
    print(k,v/t)


# null 값 뺀 dictionary 값에 대해 상대비율을 출력하기
freq = {}
for i in s:
    if i in freq:
        freq[i] += 1
    else:
        if i != '':
            freq[i] = 1
print(freq)

t = len(s)
for k,v in freq.items():
    print(k,v/(t-1))

#dataframe에서 유일값 출력하기
df = DataFrame({'a':['a1','a1','a1','a2','a2','a2','a3'],
                'b':['b1','b1','b1','b2','b2','b3',np.nan]})

#유일값 출력하기(nan도 출력)
df['a'].unique()
df['b'].unique()
#유일값 출력하기(nan빼고 출력)
ddf=Series(df['b'].unique())
ddf.dropna()

#빈도수 체크하기(null값이 빠짐)
df['a'].value_counts()
df['b'].value_counts()
df['b'].value_counts(dropna=True) #기본값 
df['b'].value_counts(dropna=False) 

#################################################################################################
[문제155] 부서별로 급여 총액을 출력하세요.

<화면 출력>

10 4400.0
20 19000.0
30 24900.0
40 6500.0
50 156400.0
60 28800.0
70 10000.0
80 304500.0
90 58000.0
100 53708.8
110 20308.0


#nan값 포함하지 않음 
import pandas as pd 
emp =pd.read_csv('c:/data/emp_new.csv',names=['empid','name','job','mgr','hire_date','sal','comm','deptno'])
emp_deptno=Series(emp['deptno'].unique())
dept = emp_deptno.dropna().sort_values()
for i in dept:
    print (int(i), emp.loc[emp['deptno']==i, 'sal'].sum())

#
import pandas as pd 
emp =pd.read_csv('c:/data/emp_new.csv',names=['empid','name','job','mgr','hire_date','sal','comm','deptno'])
emp_deptno=Series(emp['deptno'].unique())
dept = emp_deptno.dropna()
for i in dept.sort_values():
    print (int(i), emp.loc[emp['deptno']==i, 'sal'].sum())
    
#쌤답
import pandas as pd 
emp =pd.read_csv('c:/data/emp_new.csv',names=['empid','name','job','mgr','hire_date','sal','comm','deptno'])

deptno_unique = Series(emp['deptno'].unique())
deptno_unique = deptno_unique.dropna()

for i in deptno_unique.sort_values():
    print(int(i), emp.loc[emp['deptno']==i,'sal'].sum())



# -*- coding: utf-8 -*-
"""
Created on Wed Sep 19 09:47:35 2018

@author: stu
"""
###############################################################################

[문제156]부서별로 급여 총액을 출력하세요.

<화면 출력>

10 4400.0
20 19000.0
30 24900.0
40 6500.0
50 156400.0
60 28800.0
70 10000.0
80 304500.0
90 58000.0
100 53708.8
110 20308.0
nan 7000.0

# pandas에서 제공하는 isnull() 생각해서 풀기!

import pandas as pd
import numpy as np
from pandas import Series,DataFrame

emp = pd.read_csv("c:/data/emp.csv")
deptno = Series(emp['DEPARTMENT_ID'].unique())
deptno=deptno.sort_values()
deptno
for i in deptno:
    if pd.isnull(i):
        print(i, emp.loc[emp['DEPARTMENT_ID'].isnull(), 'SALARY'].sum())
    else:
        print (int(i), emp.loc[emp['DEPARTMENT_ID']==i, 'SALARY'].sum())



###############################################################################
   
▣ pandas      
■ groupby: pandas에서 grouping을 통한 집계값 구하기 

import pandas as pd
import numpy as np
from pandas import Series,DataFrame
import pandas as pd 
emp =pd.read_csv('c:/data/emp_new.csv',names=['empid','name','job','mgr','hire_date','sal','comm','deptno'])

# sql select 문
select deptno,sum(al)
from emp
group by deptno

# groupby 를 통한 함수
emp['sal'].groupby(emp['deptno']).sum()
emp['sal'].groupby(emp['deptno']).mean()
emp['sal'].groupby(emp['deptno']).var()
emp['sal'].groupby(emp['deptno']).std()
emp['sal'].groupby(emp['deptno']).count()
emp['sal'].groupby(emp['deptno']).max()
emp['sal'].groupby(emp['deptno']).min()

#grouping만 적용
deptno_group = emp['sal'].groupby(emp['deptno'])
#객체정보만 보여줌 
deptno_group
#
deptno_group.sum()
deptno_group.mean()

# 동일한 부서 안에서도 job이 다른 사원들의 결과값을 정리해줌 
#sql select문장
select deptno, job, sum(sal)
from emp
group by deptno, job
#pandas의 groupby사용 
emp['sal'].groupby([emp['deptno'], emp['job']]).sum()

dept_group = emp['sal'].groupby([emp['deptno'], emp['job']])
dept_group.sum()
dept_mean = dept_group.mean()
dept_mean

#unstack(): corsstable 모양으로 결과값이 출력됨
dept_mean.unstack()

#
emp.groupby(['deptno','job'])['sal'].sum()
#unstack(): corsstable 모양으로 결과값이 출력됨
emp.groupby(['deptno','job'])['sal'].sum().unstack()

#부서별로 data를 분리하여 바라보기  -> for문을 통해 출력 
#object 정보만 보임
emp.groupby('deptno')
# for 문을 통해 출력
for name, group in emp.groupby('deptno'):
    print(name)
    print(group)

★★★★★ # name1, name2.. 
for (name1, name2), gorup in emp.groupby(['deptno','job']):
    print(name1, name2)
    print(group)
    
        
#groupby는 NaN은 누락됨 -> 따라서 fillna와 같은 method를 사용하여 데이터를 정제한다음 적용하는 것이 좋다.
emp['sal'].groupby(emp['deptno'].fillna(0)).sum()


###############################################################################
[문제157] 년도별로 입사한 인원수 결과를 출력해주세요.
import pandas as pd
import numpy as np
from pandas import Series,DataFrame
import pandas as pd 
emp =pd.read_csv('c:/data/emp_new.csv',names=['empid','name','job','mgr','hire_date','sal','comm','deptno'])

import datetime


emp['hire_date']>='2005'
for name, group in emp.groupby(['hire_date']).count():
    print(name)
    print(group)


emp['hire_date'].dstrftime('%Y')
emp['hire_date']

emp.groupby(['hire_date']).count()

for i in emp['hire_date']:
   y = datetime.datetime.strptime(i, '%Y-%m-%d')  #char -> date
   print((y.strftime('%Y')))
   
   for j in year:
       if emp['hire_date'] == j: 
         
#답 
emp['empid'].groupby([i[0:4] for i in emp['hire_date']]).count()


[문제157] emp.csv 파일에 데이터 중에 년도별로 입사한 인원수 결과를 출력해주세요.

from pandas import Series, DataFrame
import pandas as pd
import numpy as np

#쌤답: 기존의 datatime을 사용할 수 없음 
# str.slice(,): 문자의 slicing 
emp = pd.read_csv("c:\data\emp_new.csv", names = ['empid','name','job','mgr','hire_date','sal','comm','deptno'])
emp.dtypes
#답1: str.slice 이용
print(emp.groupby(emp['hire_date'].str.slice(0,4))['empid'].count()) #문자이기 때문에 slicingㅇ르 할 수 있음 
#답2: .dt: pandas에서 제공하는 날짜 형을 바꿔주는 함수 (object만 보임)
# .dt.year: 년도를 뽑아냄
# .dt.month: 달을 뽑아냄

print(emp.groupby(pd.to_datetime(emp['hire_date']).dt.year)['empid'].count())
pd.to_datetime(emp['hire_date']).dt
pd.to_datetime(emp['hire_date']).dt.year
pd.to_datetime(emp['hire_date']).dt.month
pd.to_datetime(emp['hire_date']).dt.day
pd.to_datetime(emp['hire_date']).apply(lambda x: x.year)
pd.to_datetime(emp['hire_date']).apply(lambda x: x.month)

#format의 기본값: '2018-09-19 11:01:30', '20180919 11:01:30'
pd.to_datetime(Series('2018-09-19 11:01:30')).dt.year
pd.to_datetime(Series('2018-09-19 11:01:30')).dt.month
pd.to_datetime(Series('2018-09-19 11:01:30')).dt.day
pd.to_datetime(Series('2018-09-19 11:01:30')).dt.hour
pd.to_datetime(Series('2018-09-19 11:01:30')).dt.minute
pd.to_datetime(Series('2018-09-19 11:01:30')).dt.second
pd.to_datetime(Series('2018-09-19 11:01:30')).dt.quarter #분기
pd.to_datetime(Series('2018-09-19 11:01:30')).dt.dayofweek #(월요일=0, 일요일=6)
pd.to_datetime(Series('2018-09-19 11:01:30')).dt.dayofyear
pd.to_datetime(Series('2018-09-19 11:01:30')).dt.date
pd.to_datetime(Series('2018-09-19 11:01:30')).dt.time
pd.to_datetime(Series('2018-09-19 11:01:30')).dt.week
pd.to_datetime(Series('2018-09-19 11:01:30')).dt.days_in_month

# format을 사용하여 날짜의 형식을 새로 제공할 수 있음 
pd.to_datetime(Series('09192018 11:01:30'),format='%m%d%Y %H:%M:%S').dt.year



[문제158] emp_new.csv 를 emp리스트 변수안에 아래 모양과 같은 딕셔너리 데이터 유형에 데이트를 입력한 후 출력하세요.
# -> 앞으로 join과 관련된 문제를 풀기위해 필요한 부분임 
# list 변수안에 dictionary 형을 만들기 ;key -value 값
{'empno': 100, 'ename': King, 'job': AD_PRES, 'mgr': '', 'hiredate': 2003-06-17, 'sal': 24000, 'comm': '', 'deptno': 90}


100 King AD_PRES  2003-06-17 24000  90
101 Kochhar AD_VP 100 2005-09-21 17000  90
102 De Haan AD_VP 100 2001-01-13 17000  90
103 Hunold IT_PROG 102 2006-01-03 9000  60
104 Ernst IT_PROG 103 2007-05-21 6000  60

import csv
file = open("c:/data/emp_new.csv", 'r')
emp_csv =csv.reader(file) 
emp = []
for emp_list in emp_csv:
    emp.append({'empno':emp_list[0], 
    'ename':emp_list[1], 
    'job':emp_list[2], 
    'mgr':emp_list[3],
    'hiredate':emp_list[4],
    'sal':emp_list[5], 
    'comm':emp_list[6], 
    'deptno':emp_list[7]})
    
for e in emp:
    print(e['empno'], e['ename'], e['job'], e['mgr'],e['hiredate'], e['sal'], e['comm'], e['deptno'])
file.close()

# 잘못된 내답 ㅠ
import csv
file = open("c:/data/emp_new.csv", 'r')
emp_csv =csv.reader(file) 
emp={}
for emp_list in emp_csv:
    emp['empno']=emp_list[0], 
    emp['ename']=emp_list[1], 
    emp['job']=emp_list[2], 
    emp['mgr']=emp_list[3],
    emp['hiredate']=emp_list[4],
    emp['sal']=emp_list[5], 
    emp['comm']=emp_list[6], 
    emp['deptno']=emp_list[7]
    print(emp)



[문제159] emp_new.csv, dept_new.csv 파일을 읽어서 사원의 이름, 부서 이름을 출력하세요.
import csv
file1 = open("c:/data/emp_new.csv", 'r')
emp_csv =csv.reader(file1) 
emp = []
for emp_list in emp_csv:
    emp.append({'empno':emp_list[0], 
    'ename':emp_list[1], 
    'job':emp_list[2], 
    'mgr':emp_list[3],
    'hiredate':emp_list[4],
    'sal':emp_list[5], 
    'comm':emp_list[6], 
    'deptno':emp_list[7]})
file2 = open("c:/data/dept_new.csv", 'r')   
dept_csv = csv.reader(file2)
dept = []
for dept_list in dept_csv:
    dept.append({'deptno':dept_list[0],
                 'dname':dept_list[1],
                 'mgrid':dept_list[2],
                 'locid':dept_list[3]})      

for i in dept:
    for j in emp:
        if dept[i]['deptno']==emp[j]['deptno']:
            print(emp[j]['ename'], dept[i]['dname'])


import csv
file1 = open("c:/data/emp_new.csv", 'r')
emp_csv =csv.reader(file1) 
file2 = open("c:/data/dept_new.csv", 'r')   
dept_csv = csv.reader(file2)
for i in emp_csv:
    print(i)
    
    
    for j in dept_csv:
        if emp_list[][7]==dept_list[0]:
            print(emp_list[1], dept_list[1])
    

#쌤답
import csv
file1 = open("c:/data/emp_new.csv", 'r')
file2 = open("c:/data/dept_new.csv", 'r')   
emp_csv =csv.reader(file1)        
dept_csv = csv.reader(file2)
 
emp = []
dept = []

for i in dept_csv:
    dept.append({'deptno':i[0], 'dname':i[1], 'mgrid':i[2], 'locid':i[3]})

for j in emp_csv:
    emp.append({'empno':j[0], 
    'ename':j[1], 
    'job':j[2], 
    'mgr':j[3],
    'hiredate':j[4],
    'sal':j[5], 
    'comm':j[6], 
    'deptno':j[7]})
    
for d in dept:
    for e in emp:
        if e['deptno']==d['deptno']:
            print(e['ename'], d['dname'])
            
empfile.close()
deptfile.close()



[문제160] 사원들의 이름, 부서 이름을 출력하면서 소속부서가 없는 사원도 출력해주세요. 마지막에는 총건수도 출력하세요. 
import  csv
empfile = open("c:\data\emp_new.csv",'r')
deptfile = open("c:\data\dept_new.csv",'r')
emp_csv = csv.reader(empfile)
dept_csv = csv.reader(deptfile)

emp = []  
dept =[]

for i in  dept_csv:
    dept.append({'deptno':i[0],'dname':i[1],'mgr':i[2],'loc':i[3]})

for j in emp_csv:
    emp.append({'empno':j[0],'ename':j[1],'job':j[2],'mgr':j[3], 'hiredate':j[4],'sal':j[5],'comm':j[6],'deptno':j[7]})

cn = 0   # outer 조인 (driving 고정 +반대쪽이 driving 고정  cf. right outer join => left가 드라이빙 / left otuer join= > right이 드라이빙 )
for e in emp:
    if e['deptno'] == '':
        print(e['ename'])
        cn += 1
    else:
        for d in dept:
            if e['deptno'] == d['deptno']:
               print ( e['ename'], d['dname'])
               cn += 1

print(cn)

empfile.close()
deptfile.close()


#sql의 select 문장
select e.ename, d.dname
from emp e, dept d
where e.deptno = d.deptno:
    
select e.ename, d.dname
from emp e, dept d
where e.deptno = d.deptno(+):
    
select e.ename, d.dname
from emp e left otuer join dept d
where e.deptno =  d.deptno(+):
###############################################################################

from pandas import Series, DataFrame
import pandas as pd
import numpy as np

emp = pd.read_csv("c:/data/emp_new.csv", names=['empid','name','job','mgr','hire_date', 'sal','comm','deptno'])
dept = pd.read_csv("c:/data/dept_new.csv", names=['deptno','dname', 'mgr','loc'])

#몇개의 row와 몇개의 coulmn이 있는지 확인 
emp.shape
#columns 확인
emp.columns
#data type
emp.dtypes

■ pd.merge: pandas의 merge 
(#sql: merge는 dml 문장을 한꺼번에 실행할 수 있는 것)

#동일한 column이름(key값)이 존재하기 때문에 원하는 join결과가 나오지 않을 수 있음 -> deptno, mgr
#-> 이럴경우 먼저 나열 되어 있는 mgr을 기준으로 joind을 함
pd.merge(emp, dept)

#on 절을 통함 merge on에 쓴 것이 컬럼의 기준이 됨
pd.merge(emp, dept, on='deptno')

# on='deptno'을 기준으로 name, deptno, dname을 출력  (on절에 이름이 같을 경우 이렇게 실행하면 된다.)
pd.merge(emp[['name', 'deptno']],dept[['deptno','dname']], on='deptno')

# merge하고자 하는 컬럼의 이름이 다른 경우 left_on과 right_on을 사용하면 된다.  
# e.g., selfjoin시에 키 컬럼 이름이 달라지므로 selfjoin시 사용할 수 있다. 
pd.merge(emp[['name', 'deptno']],dept[['deptno','dname']],
         left_on='deptno', right_on='deptno')

# inner join(equijoin)  -> data 1개가 출력되지 않음 : 106건 
pd.merge(emp[['name','deptno']],dept[['deptno','dname']], on='deptno', how='inner')
# 왼쪽 데이터 프레임은 다 출력
pd.merge(emp[['name','deptno']],dept[['deptno','dname']], on='deptno', how='left')
# 오른쪽 데이터 프레임은 다 출력 
pd.merge(emp[['name','deptno']],dept[['deptno','dname']], on='deptno', how='right')
# full outer join: 모든 양쪽의 내용을 다 출력 
pd.merge(emp[['name','deptno']],dept[['deptno','dname']], on='deptno', how='outer')


###############################################################################
[문제161] emp_new.csv, dept_new.csv 파일 데이터에서 50번 부서 사원의 중에 급여가 5000 이상인 사원의 이름, 부서 이름을 출력하세요.

from pandas import Series, DataFrame
import pandas as pd
import numpy as np

#답1
emp = pd.read_csv("c:/data/emp_new.csv", names=['empid','name','job','mgr','hire_date', 'sal','comm','deptno'])
dept = pd.read_csv("c:/data/dept_new.csv", names=['deptno','dname', 'mgr','loc'])

pd.merge(emp[['name','sal','deptno']],dept[['deptno','dname']], on='deptno')
new=pd.merge(emp[['name','sal','deptno']],dept[['deptno','dname']], on='deptno')
  
new= new[['name','dname','sal']][new['deptno']==50]
new[['name','dname','sal']][new['sal']>=5000]

#답2
emp = pd.read_csv("c:/data/emp_new.csv", names=['empid','name','job','mgr','hire_date', 'sal','comm','deptno'])
dept = pd.read_csv("c:/data/dept_new.csv", names=['deptno','dname', 'mgr','loc'])

(pd.merge(emp[['name','sal','deptno']],dept[['deptno','dname']], on='deptno')[emp['deptno']==50])[['name','dname','sal']][emp['sal']>=5000]

#쌤답
emp = pd.read_csv("c:/data/emp_new.csv", names=['empid','name','job','mgr','hire_date', 'sal','comm','deptno'])
dept = pd.read_csv("c:/data/dept_new.csv", names=['deptno','dname', 'mgr','loc'])

pd.merge(emp[(emp['deptno']==50)&(emp['sal']>=5000)][['name','sal','deptno']],dept[['deptno','dname']], on='deptno')

[문제162] 2002년도에 근무한 사원들의 이름, 급여, 입사일, 부서코드,부서이름을 출력하세요.

from pandas import Series, DataFrame
import pandas as pd
import numpy as np

#답1
pd.merge(emp[['name','sal', 'hire_date','deptno']],dept[['deptno','dname']], on='deptno', how='left')[['name','sal','hire_date','deptno','dname']][emp['hire_date'].str.slice(0,4)=='2002']

#답2
new2=pd.merge(emp[['name','sal', 'hire_date','deptno']],dept[['deptno','dname']], on='deptno')
new2[['name','sal','hire_date','deptno','dname']][new2['hire_date'].str.slice(0,4)=='2002']

#쌤답1
pd.merge(emp[emp['hire_date'].str.slice(0,4)=='2002'][['name','sal','hire_date','deptno']], dept[['deptno','dname']], on='deptno')

#쌤답2
from datetime import datetime
pd.merge(emp[pd.to_datetime(emp['hire_date']).dt.year==datetime.strptime('2002','%Y').year][['name','sal','hire_date','deptno']],dept[['deptno','dname']],on='deptno')


[문제163] 직업이 AD_VP, AD_PRES 인 사원들의 이름, 급여, 직업, 부서코드, 부서이름 을 출력하세요.
emp = pd.read_csv("c:/data/emp_new.csv", names=['empid','name','job','mgr','hire_date', 'sal','comm','deptno'])
dept = pd.read_csv("c:/data/dept_new.csv", names=['deptno','dname', 'mgr','loc'])

#답1
import pandas as pd 
pd.merge(emp[(emp['job']=='AD_VP')|(emp['job']== 'AD_PRES')][['name','sal','job','deptno']],dept[['deptno','dname']], on='deptno')

#답2
import pandas as pd 
pd.merge(emp[emp['job'].isin(['AD_VP','AD_PRES'])][['name','sal','job','deptno']],dept[['deptno','dname']], on='deptno')



###############################################################################\
dept = DataFrame({'dname':['관리팀', '마케팅팀','구매팀','인사팀','경영지원팀','기술지원팀','홍보팀','영업팀','기획팀','재무팀','회계팀']},
                  index=[10,20,30,40,50,60,70,80,90,100,110])
dept

# right index/ left index: index를 이용할 때
pd.merge(emp[['name','sal','deptno']], dept, left_on='deptno', right_index=True)


###############################################################################
[문제164] 부서이름별 총액 급여를 출력하세요.  

#답1 
import pandas as pd 
emp = pd.read_csv("c:/data/emp_new.csv", names=['empid','name','job','mgr','hire_date', 'sal','comm','deptno'])
dept = DataFrame({'dname':['관리팀', '마케팅팀','구매팀','인사팀','경영지원팀','기술지원팀','홍보팀','영업팀','기획팀','재무팀','회계팀']},
                  index=[10,20,30,40,50,60,70,80,90,100,110])

m=pd.merge(emp[['name','sal','deptno']], dept, left_on='deptno', right_index=True)
dname_unique = Series(m['dname'].unique())
m

for i in dname_unique.sort_values():
    print(i, m.loc[m['dname']==i, 'sal'].sum())

#답2
    import pandas as pd 
emp = pd.read_csv("c:/data/emp_new.csv", names=['empid','name','job','mgr','hire_date', 'sal','comm','deptno'])
dept = DataFrame({'dname':['관리팀', '마케팅팀','구매팀','인사팀','경영지원팀','기술지원팀','홍보팀','영업팀','기획팀','재무팀','회계팀']},
                  index=[10,20,30,40,50,60,70,80,90,100,110])

# dataframe만 join이 가능하다, 따라서 처리를 한뒤 join을 해야함 
m=pd.merge(emp[['name','sal','deptno']], dept, left_on='deptno', right_index=True)
dname_unique = Series(m['dname'].unique())

m['sal'].groupby(m['dname']).sum()

# 쌤답1
from pandas import Series, DataFrame
import pandas as pd
emp = pd.read_csv("c:\data\emp_new.csv", names = ['empid','name','job','mgr','hire_date','sal','comm','deptno'])
dept = pd.read_csv("c:\data\dept_new.csv", names = ['deptno','dname','mgr','loc'])

#먼저 grouping 한 뒤에 -> join 함
dept_sal = emp['sal'].groupby(emp['deptno']).sum() #series형이어서 merge할수 없음 
dept_sal = DataFrame(dept_sal) #따라서 dataframe형을 바꿈 
dept_sal.reindex([10,20,30,40,50,60,70,80,90,100,110]) #다시 reindex가 필요함 
pd.merge(dept[['deptno','dname']], dept_sal, left_on = 'deptno', right_index=True)


# 쌤답2 
# 먼저 join 한 뒤 -> grouping의 집계값 구함
from pandas import Series, DataFrame
import pandas as pd
emp = pd.read_csv("c:\data\emp_new.csv", names = ['empid','name','job','mgr','hire_date','sal','comm','deptno'])
dept = pd.read_csv("c:\data\dept_new.csv", names = ['deptno','dname','mgr','loc'])
m = pd.merge(emp[['deptno','sal']], dept[['deptno','dname']])
m
m['sal'].groupby(m['dname']).sum()


#쌤답3 
dept= DataFrame({'dname':['관리팀','마케팅팀','구매팀','인사팀','경영지원팀','기술지원팀','홍보팀',
'영업팀','기획팀','재무팀','회계팀']},
index=[10,20,30,40,50,60,70,80,90,100,110])
pd.merge(dept, dept_sal, left_index = True, right_index=True)




# -*- coding: utf-8 -*-
"""
Created on Thu Sep 20 09:45:20 2018

@author: stu
"""
###############################################################################

[문제165] emp_new.csv 파일  데이터에 커미션 정보를 분석하려 합니다.
커미션에 null값들의 수, null이 아닌값들의 수를 구하세요.

1. 일반적으로 csv file을 읽어서 해결
import csv
file = open("c:/data/emp_new.csv",'r')
emp_csv = csv.reader(file)
comm = 0
for emp_list in emp_csv:
    if emp_list[-2] == '':
        comm +=1
print(comm)
        
import csv
file = open("c:/data/emp_new.csv",'r')
emp_csv = csv.reader(file)
comm = 0
for emp_list in emp_csv:
    if emp_list[-2] != '':
        comm +=1 
print(comm)
                
                
#쌤답
import csv

file = open("c:/data/emp_new.csv",'r')
emp_csv = csv.reader(file)
cn1 = 0
cn2 = 0
for emp_list in emp_csv:
    if emp_list[6] == '':
        cn1 += 1
    else:
        cn2 += 1
print('null의 수:' , cn1)
print('null이 아닌 수:' , cn2)
file.close()
        
                
                
2. pandas를 이용해서 해결
#답1 - null
import pandas as pd
emp = pd.read_csv("c:\data\emp_new.csv", names = ['empid','name','job','mgr','hire_date','sal','comm','deptno'])
emp[emp['comm'].isnull()]['empid'].count()
#답2
emp[(emp['comm']).isnull()]['comm'].fillna(0).count()

    
#답1 - notnull
import pandas as pd
emp = pd.read_csv("c:\data\emp_new.csv", names = ['empid','name','job','mgr','hire_date','sal','comm','deptno'])
emp[emp['comm'].notnull()]['comm'].count()


#쌤답 
#
import pandas as pd
emp = pd.read_csv("c:\data\emp_new.csv", names = ['empid','name','job','mgr','hire_date','sal','comm','deptno'])
print('null 수: ', emp[emp['comm'].isnull()]['empid'].count())
print('null 아닌 수: ', emp[emp['comm'].notnull()]['empid'].count())

[문제166] emp_new.csv, dept_new.csv 파일 데이터를 이용해서  조인된 결과를 보려고 합니다.
조인 함수를 생성하세요.

join(emp,'deptno','ename', dept,'deptno','dname')

join(emp,'mgr','ename', emp,'empno','ename') 

#답xxxxxx 잘못된 답! 근데 merge되는 순서 다시 확인하기 위해서 남겨둠 
from pandas import Series, DataFrame
import pandas as pd
emp = pd.read_csv("c:\data\emp_new.csv", names = ['empno','ename','job','mgr','hire_date','sal','comm','deptno'])
dept = pd.read_csv("c:\data\dept_new.csv", names = ['deptno','dname','mgr','loc'])
def join(x, x1, x2, y, y1, y2):
    print(pd.merge(x[[x1,x2]],y[[y1,y2]]))
    
#동일한 column이름(key값)이 존재하기 때문에 원하는 join결과가 나오지 않을 수 있음 -> deptno, mgr
#-> 이럴경우 먼저 나열 되어 있는 mgr을 기준으로 joind을 함

#답 1
from pandas import Series, DataFrame
import pandas as pd
emp = pd.read_csv("c:\data\emp_new.csv", names = ['empno','ename','job','mgr','hire_date','sal','comm','deptno'])
dept = pd.read_csv("c:\data\dept_new.csv", names = ['deptno','dname','mgr','loc'])
def join(x, x1, x2, y, y1, y2):
    print(pd.merge(x[[x1,x2]],y[[y1,y2]], left_on = x1, right_on = y1))


#쌤답2
import csv
empfile = open("c:/data/emp_new.csv",'r')    
deptfile = open("c:/data/dept_new.csv",'r')
emp_csv = csv.reader(empfile)
detp_csv = csv.reader(deptfile)
emp = []
dept = []

for j  in emp_csv:
    emp.append({'empno':j[0], 'enanme':j[1], 'job': j[2], 'mgr':j[3], 'hiredate':j[4], 'sal':j[5], 'comm':j[6], 'deptno':j[7]})

def join (outer_table, outer_column1, outer_column2, inner_table, inner_coulmn1, inner_coulmn2):
    for o in outer_table:
        for i in inner_table:
            if o[outer_column1] == i[inner==column1]:
                print(o[outer_column2], i[inner_coulmn2])

#쌤답2
import  pandas  as  pd

emp = pd.read_csv("c:\data\emp_new.csv", names = ['empid','ename','job','mgr','hire_date','sal','comm','deptno'])
dept = pd.read_csv("c:\data\dept_new.csv",names = ['deptno','dname','mgr','loc'])

def join(outer_table,outer_column1,outer_column2,inner_table,inner_column1,inner_column2):
    print(pd.merge(outer_table[[outer_column1,outer_column2]],inner_table[[inner_column1,inner_column2]],left_on=outer_column1,right_on=inner_column1))

join(emp,'deptno','ename', dept,'deptno','dname')

join(emp,'mgr','ename', emp,'empid','ename')    



###############################################################################
#하나씩 인덱싱을 함수에 넣음 
def f(arg):
    result=[]
    for i in arg:
        result.append(i*2)
    return result

f([1,2,3,4,5])
id(f)

#한통으로 [1,2,3,4,5]를 넣음
def f1(arg)  :
    return arg*2

f1([1,2,3,4,5])

■ map 함수는 입력받는 자료형의 각 요소가 함수에 수행된 결과를 묶어서 리턴하는 함수
#map 정보만 추출
map(f1,[1,2,3,4,5])
#list로 만들어줌 
list(map(f1,([1,2,3,4,5])))

#람다함수 이용
list(map(lambda x: x*2,[1,2,3,4,5]))


###############################################################################
[문제167] x변수에는 1,2,3,4,5  y변수에는 6,7,8,9,10 들어 있다. f(x,y) = x2 + y 를 구하세요.(lambda, map 함수를 이용하세요)

#답1
f = lambda x, y : x*2 +y
x = [1,2,3,4,5]
y = [6,7,8,9,10]
result = map(f,x,y)
print(list(result))

#답2
x = [1,2,3,4,5]
y = [6,7,8,9,10]
print(list(map(lambda x,y: x*2+y, x,y)))

###############################################################################
□ 한쪽의 value값과 한쪽의 index값을 붙이는 작업
from pandas import Series, DataFrame
import pandas as pd
import numpy as np

x = Series([1,2,3],index=['one','two','three']) #값, 인덱스 
y = Series(['하나','둘','셋'], index=[1,2,3]) #값, 인덱스 

#series에서는 pd.merge가 안됨 -> dataframe형으로 만들어야 함  
x1=DataFrame(x)
y1=DataFrame(y)

# merge: merge는 작업후 필요없 열을 버려줘야함
pd.merge(x1,y1, left_on = 0, right_index=True)

# map을 통해 pandas에서도 한쪽의 값과 한쪽의 index를 붙이는 작엄을 함 
#꼭 항상 value, index순서로 쓰지 않아도 됨 
x.map(y)

###############################################################################
[문제168] emp_new.csv는 pandas로 읽고  dept_new.csv는 일반 csv로 읽어 들인 후 조인을 수행하세요.

#답1
#한쪽은 DataFrame
import  pandas  as  pd
emp = pd.read_csv("c:\data\emp_new.csv", names = ['empid','ename','job','mgr','hire_date','sal','comm','deptno'])

import csv
file = open("c:\data\dept_new.csv",'r')


#dictionary형으로 만들기
import csv
file = open("c:\data\dept_new.csv",'r')
dept = csv.reader(file)
d = {}
for dept_list in dept:
    if dept_list[0] != d:
        d[int(dept_list[0])] = dept_list[1]
d

emp['dname']=emp['deptno'].map(d) 
print(emp[['empid','deptno','dname']])


#
import csv
file = open("c:\data\dept_new.csv",'r')
dept = csv.reader(file)
d = {}
for dept_list in dept:
    d[int(dept_list[0])] = dept_list[1]

d
emp['dname']=emp['deptno'].map(d)
print(emp[['empid','deptno','dname']])

#쌤답

#한쪽은 DataFrame
import  pandas  as  pd
emp = pd.read_csv("c:\data\emp_new.csv", names = ['empid','ename','job','mgr','hire_date','sal','comm','deptno'])

import csv
deptfile = open("c:\data\dept_new.csv",'r')
dept_csv = csv.reader(deptfile)
dept = {}

for i in dept_csv:
    if i[0] != dept:
        dept[int(i[0])] = i[1]
dept  

for k,v in dept.items():
    print(k,v)

# merge하지 않아도 join된 결과를 얻을 수 있다. 
emp['dname']=emp['deptno'].map(dept) 
print(emp[['empid','deptno','dname']])



[문제169] happiness 변수에 문장이 있습니다. 행복이란 단어가 몇개 나오는지 분석하시고, 위치정보도 출력해주세요.



happiness = '우리나라 「헌법」 제10조는 “모든 국민은 인간으로서의 존엄과 가치를 가지며, 행복을 추구할 권리를 가진다”라고 규정하고 있다.행복추구권은 근대 입헌민주주의의 핵심인 개인주의·자유주의를 그 사상적 기반으로 하고 있다. 행복추구권에 있어서 행복은 다의적인 개념으로, 각자의 생활조건이나 가치관에 따라 다르게 이해될 수 있으나, 최소한 인간적인 고통이 없는 상태 내지 만족감을 느낄 수 있는 행복한 상태를 의미한다.'

#답: 행복 단어 개수
cn=0
i=0
for i in range(len(happiness)):
    i += 1
    if happiness[i:i+2]=='행복':
        cn += 1
print(cn)    

#답2
cn = happiness.count('행복')
print('단어의 수:', cn)


#단어의 위치찾기- 다시 시도 해보기 
cn=0
i=0
loc=[]
for i in range(len(happiness)):
    i += 1
    if happiness[i:i+2]=='행복':
        cn += 1
        loc.append(happiness.find('행복'))       
print(loc)
print(cn)    

#답1
print('단어의 위치:', happiness.find('행복',44))
print('단어의 위치:', happiness.find('행복',71))
print('단어의 위치:', happiness.find('행복',122))
print('단어의 위치:', happiness.find('행복',133))
print('단어의 위치:', happiness.find('행복',217))

#답2: find: 있으면 인덱스 번호를 return해주고, 없으면 -index1의 값으로 return한다. 
a =1 
while happiness.find('행복',a) != -1:
    a = happiness.find('행복', a)
    print('단어의 위치: ', a)
    a += 1
    
happiness.find('행복') != -1





[문제170] emp1.csv, emp2.csv파일을 읽어서 부서별 총액급여를 구하세요.

import pandas as pd 

#답1
import pandas as pd 
emp1 = pd.read_csv("c:\data\emp1.csv", names = ['empid','name','hire_date','sal','deptno'])
emp = emp1
for i in range(2,3):
    emp = emp.append(pd.read_csv("c:\data\emp{}.csv".format(i), names = ['empid','name','hire_date','sal','deptno']))
emp['sal'].groupby(emp['deptno']).sum()



#답2
import pandas as pd 
emp=emp1.append(emp2)
    
emp1 = pd.read_csv("c:\data\emp1.csv", names = ['empid','ename','hire_date','sal','deptno'])
emp2 = pd.read_csv("c:\data\emp2.csv", names = ['empid','ename','hire_date','sal','deptno'])

emp['sal'].groupby(emp['deptno']).sum()
emp1['sal'].groupby(emp1['deptno']).sum()
emp2['sal'].groupby(emp2['deptno']).sum()

#답3
emp = pd.DataFrame(index = ['empid','name','hire_date','sal','deptno'])
for i in range(1,3):
    emp = emp.append(pd.read_csv("c:\data\emp{}.csv".format(i), names = ['empid','name','hire_date','sal','deptno']))
emp['sal'].groupby(emp['deptno']).sum()


#쌤답1
import pandas as pd
emp = pd.DataFrame()
for i in range(1,3):
    file = 'c:/data/emp{}.csv'.format(i)
    temp = pd.read_csv(file, names = ['empid','name','hire_date','sal','deptno'])
    emp = emp.append(temp)
    
print(emp['sal'].groupby(emp['deptno']).sum())


#쌤답2
■ import glob
glob.glob(): 동일이름이지만 번호만 달라지는 파일명을 불러들일때 사용하는 method, *가 키워드임

import glob
import pandas as pd

file = 'C:/python_data/emp*.csv'
file_list = glob.glob(file)
print(file_list)
emp = pd.DataFrame()

for i in file_list:
    temp = pd.read_csv(i, names =  ['empid','name','hire_date','sal','deptno'])
    emp = emp.append(temp)

print(emp['sal'].groupby(emp['deptno']).sum())



[문제171] 2016년도에 태어난 아이들의 정보가 들어 있는 year2016파일을 분석해야 합니다. 총 출생수를 출력해주세요.

#txt파일에서 ,로 구분자가 되어있기 때문에 csv로 읽어들일 수 있다. 
#총 출생수 
import pandas as pd
data = pd.read_csv('c:/data/yob2016.txt', names = ['name','gender','num'])

data['num'].sum()

# pandas를 사용하지 않을 때
readlines


#쌤답1: csv객체로 읽어들임 
import csv
import os 

count=0
file = 'c:\data\yob2016.txt'
name = os.path.basename('c:\data\yob2016.txt')  #물리적인 절대적경로를 빼고, 파일이름.확장자
name = name.split('.')[0]   #.을 기준으로 split [0]인덱스의 값만 뽑아내면 파일 이름만 뽑아내게 됨 
with open(file,'r') as f: #with를 사용하면 file.close()를 안해도 됨 
    data=csv.reader(f)
    for d in data:
        count += int(d[2]) #2번 index값을 intger형으로 바꾼후 count 변수에 누적 
print(name,count) #파일이름과 총출생수 출력 

#쌤답2 : readlines로 읽어들일 때 ★★★★★★★ 주의하기 
import csv
import os

count=0
file = 'c:\data\yob2016.txt'
name = os.path.basename('c:\data\yob2016.txt')
name = name.split('.')[0]
with open(file,'r') as f:
    data=f.readlines()
    for d in data:
        birth = d.split(',')[2] #split 을 해야함 
        count += int(birth)
print(name,count)



import pandas as pd 
import os

file = 'c:/data/yob2016.txt'
name = os.path.basename(file)
name = name.split('.')[0]

#쌤답3
yob = pd.read_csv('c:\data\yob2016.txt', names=['name','gender','birth'])
print(name,yob['birth'].sum())




[문제172] 2016년도에 태어난 아이 이름 상위 10까지 보여주세요. 성별 상위 5까지 보여주세요.
import pandas as pd
data = pd.read_csv('c:/data/yob2016.txt', names = ['name','gender','num'])


data[data['gender']=='F']
data[data['gender']=='M']

#답: 아이 이름 상위 10까지
total = DataFrame({'순위':data['num'].rank(ascending=False, method='dense'), '이름':data['name'], '성별':data['gender'], '인원수':data['num']})
total[['순위','이름','성별','인원수']][total['순위']<= 10]


#답: 성별 상위 5까지 
f= data[data['gender']=='F']
total_f= DataFrame({'순위':f['num'].rank(ascending=False, method='dense'), '이름':f['name'], '성별':f['gender'], '인원수':f['num']})
total_f[['순위','이름','성별','인원수']][total_f['순위']<= 5]

m= data[data['gender']=='M']
total_m= DataFrame({'순위':m['num'].rank(ascending=False, method='dense'), '이름':m['name'], '성별':m['gender'], '인원수':m['num']})
total_m[['순위','이름','성별','인원수']][total_m['순위']<= 5]



# 답22
import pandas as pd
name=pd.read_csv("c:/data/yob2016.txt", names = ['name','gender','count'])
a=name.sort_values(by='count',ascending=False)[0:10]
a

female=name[name['gender']=='F']
male=name[name['gender']=='M']

f=female.sort_values(by='count', ascending=False)[0:10]
f
m=male.sort_values(by='count', ascending=False)[0:10]
m


#쌤답
import pandas as pd 

yob2016 = pd.read_csv('c:\data\yob2016.txt', names=['name','gender','birth'])

def top(df, n=5, column='birth'):   # 넣지 않으면 n=5, column='birth' -> default값으로 설정할 수 있음 
    return df.sort_values(by=column, ascending=False)[:n]  #[:n]은 slicing ; 기억하기!! sort.values로 상위 몇 개만 뽑아내기! 

print(top(yob2016 , n=10))

print(yob2016.groupby('gender').apply(top))


#rank를 이용해서 출생수가 동일하게 counting된 아이들의 이름을 누락시키지 않게 하기 위해 




# -*- coding: utf-8 -*-
"""
Created on Fri Sep 21 09:45:39 2018

@author: stu
"""

###############################################################################

#sort_value는 같은 값이 없을 때 순위를 구하는 것이 가능하지만 같은 값이 있게 되면 누락되는 상황이 발생되기 때문에 순위를 구할때는 rank를 사용해야 한다. 
#rank안의 option의 dense를 사용해서 
#sql에는 inline view를 통해서 바깥쪽에서 제한을 함,(select 문장에서 rank구하기 확인하기-> 순위를 구하되 10위까지 구한 것을 dataframe을 하나 만들어 넣어놔야한다. 그런다음 제한하면 됨)
[문제173] emp1.csv 데이터를 이용해서 급여를 많이 받는 순으로 10위까지 구하세요.

import pandas as pd
from pandas import Series, DataFrame


emp = pd.read_csv('c:/data/emp1.csv', names=['empid','name','hire_date', 'sal', 'deptno']) 

emprank = DataFrame({ 'rank':emp['sal'].rank(ascending=False, method='desne')})

emprank = DataFrame({'empid':emp['empid'], 'name':emp['name'], 'hire_date':emp['hire_date'], 'sal':emp['sal'], 'rank':emp['sal'].rank(ascending=False, method='dense'), 'deptno':emp['deptno']})
rank=emprank[['empid','name','hire_date','sal','rank','deptno']][emprank['rank']<=10].sort_values('rank')
rank

#쌤답
emp['rank'] = emp['sal'].rank(ascending=False, method='dense')
emp[emp['rank']<=10] .sort_values('rank')


[문제174] emp1.csv 데이터를 이용해서 부서별로 급여를 많이 받는 순으로 5위까지 구하세요.
#답1
import pandas as pd
from pandas import Series, DataFrame

emp = pd.read_csv('c:/data/emp1.csv', names=['empid','name','hire_date', 'sal', 'deptno']) 
emp['dept_rank'] = emp['sal'].groupby(emp['deptno']).rank(ascending=False, method='dense')

for i in emp[emp['dept_rank'] <= 5].sort_values(['dept_rank']).groupby('deptno'):
    print(i)


#답2
import pandas as pd
from pandas import Series, DataFrame

emp = pd.read_csv('c:/data/emp1.csv', names=['empid','name','hire_date', 'sal', 'deptno']) 

emp['dept_rank'] = emp['sal'].groupby(emp['deptno']).rank(ascending=False, method='dense')
emp[emp['dept_rank']<=5].sort_values(['deptno','dept_rank'])


###############################################################################


[문제175] yob2016.txt 데이터를 이용해서 아기 이름 순위 10위까지 구하세요.

import pandas as pd
data = pd.read_csv('c:/data/yob2016.txt', names = ['name','gender','num'])

data['rank'] = data['num'].rank(ascending=False, method='dense')
data[['name','gender','num','rank']][data['rank']<=10].sort_values('rank')



[문제176] yob2016.txt 데이터를 이용해서 성별 아기 이름 순위 5위까지 구하세요.

import pandas as pd
data = pd.read_csv('c:/data/yob2016.txt', names = ['name','gender','num'])
data['gender_rank'] = data['num'].groupby(data['gender']).rank(ascending=False, method='dense')
data[data['gender_rank']<=5].sort_values(['gender','gender_rank'])

import pandas as pd
data = pd.read_csv('c:/data/yob2016.txt', names = ['name','gender','num'])
data['gender_rank'] = data['num'].groupby(data['gender']).rank(ascending=False, method='dense')

for i in data[data['gender_rank']<=5].sort_values(['gender_rank']).groupby('gender'):
    print(i)
    
    
[문제177] 2000 ~ 2016년도 년도별 출생수

https://catalog.data.gov/dataset/baby-names-from-social-security-card-applications-national-level-data

def countName():
    counting = []
    for i in range(2000,2017):
        count = 0
        filename = 'c:\python_data\yob\yob%d.txt'%i
        with open(filename,'r') as f:
            data=f.readlines()
            for j in data:
                birth = j.split(',')[2]
                count += int(birth)
            counting.append((j,count))
    return counting

result = countName()            
for year, cn in result:
    print(year, cn)
    
#쌤답1
def countBirths():
    ret=[]
    for y in range(2000,2017):
        count=0
        filename='c:python_data\yob\yob%d.txt'%y
        with open(filename,'r') as f:
            data=f.readlines()
            for d in data:
                birth = d.split(',')[2]
                count += int(birth)
            ret.append((y,count))
    return ret



result = countBirths()
for year, cn in result:
    print(year,cn)

##오답: 누적합이 되어버림 
import os
from pandas import Series, DataFrame
import pandas as pd
import numpy as np

year_cn=[]
all_data = pd.DataFrame()
for y in range(2000,2017):
    filename='c:\python_data\yob\yob%d.txt'%y
    name = os.path.basename(filename)
    name = name.split('.')[0]
    df = pd.read_csv(filename, names=['name','gender','birth'])
    #all_data = all_data.append(df)    -> 필요없는 부분 
    year_cn.append((name[3:],all_data['birth'].sum()))
    print(name[3:],all_data['birth'].sum())

#답
import os
from pandas import Series, DataFrame
import pandas as pd
import numpy as np

year_cn=[]
all_data = pd.DataFrame()
for y in range(2000,2017):
    filename='c:\python_data\yob\yob%d.txt'%y
    name = os.path.basename(filename)
    name = name.split('.')[0]
    df = pd.read_csv(filename, names=['name','gender','birth'])
    year_cn.append((name[3:], df['birth'].sum()))
    print(name[3:], df['birth'].sum())


#답
        
import pandas as pd

for i in range(2000,2017):
    temp = pd.read_csv('c:/python_data/yob/yob{}.txt'.format(i), names = ['name', 'gender', 'cnt'])
    print(i,temp['cnt'].sum())
    
[문제178]  2000 ~ 2016년도 년도별 출생수 결과를 year.txt 파일에 저장하세요.

import os
import glob
from pandas import Series, DataFrame
import pandas as pd
import numpy as np

#답1
#write 대상을 만들기 
year_cn=[]                                          #append 하여 만드는 작업
all_data = pd.DataFrame()
for f in glob.glob("c:\python_data\yob\yob*.txt"):   #물리적 확장자 주소
    name = os.path.basename(f)      # (물리적 확장자 주소가 아닌) file이름만 뽑아내기 -> 나중에 년도만 뽑아내기 위해서 
    name = name.split('.')[0]       # 파일 이름의 년도 정보 뽑아내기 
    df = pd.read_csv(f, names=['name','gender','birth'])   
    year_cn.append((name[3:],df['birth'].sum()))  #name[3:] :yob을 제거하고 연도만 넣기: 200x, 출생수 저장
    print(name[3:],df['birth'].sum())             #출력


# 이제부터 파일로 떨어뜨리기 ; 
#기존 데이터를 저장할때는 하나씩 저장하여 ,를 써주면서 형식을 저장해야함 (밑의 writer= csv.writer(f, delimiter=','와 다름))
with open('c:\python_data\yob\year.txt','w') as f:      #'w' :write정보 , f별칭 
    for year, birth in year_cn:                     #year_cn에서 year와 birth를 가져옴
        data = '%s,%s\n'%(year,birth)               #%s를 통해 year, birth를 넣음, \n 줄바꿈
        print(data)         
        f.write(data)                               #data 차곡차곡 정리



#답2 - append 하지 않고 한번에 작업하기 

import os
from pandas import Series, DataFrame
import pandas as pd
import numpy as np
import csv

with open('c:/python_data/yob/year_total.csv','w') as f:
    writer = csv.writer(f, delimiter=',')   #csv.writer : csv로 저장, / 구분자: delimiter=',' 
    for y in range(2000,2017):
        filename='c:/python_data/yob/yob%d.txt'%y   #for문을 사용하여 data읽어들이기 
        name = os.path.basename(filename)
        name = name.split('.')[0]
        df = pd.read_csv(filename, names=['name','gender','birth'])
        writer.writerow([name[3:],df['birth'].sum()])   #writerow(): 결과물 ()부분을 행단위로 저장하겠다. :writerow([name[3:],df['birth'].sum()]) 


#답3

import pandas as pd

f = open("c:/python_data/yob/year2.txt", "w")

for i in range(2000,2017):
    temp = pd.read_csv('c:/python_data/yob/yob{}.txt'.format(i), names = ['name', 'gender', 'cnt'])
    txt = "{},{}\n".format(i,temp['cnt'].sum())
    f.write(txt)

f.close()





[문제179] 2010 ~ 2016  년도까지 성별 출생 현황을
year_gender_total.csv 파일로 생성해주세요.

# 덥
import pandas as pd

f = open("c:/data/year_gender_total.csv", "w")

f.write('year,M,F\n')

for i in range(2000,2017):
    temp = pd.read_csv('c:/python_data/yob/yob{}.txt'.format(i), names = ['name', 'gender', 'cnt'])
    M = temp[temp['gender']=='M']['cnt'].sum()
    F = temp[temp['gender']=='F']['cnt'].sum()
    txt = "{},{},{}\n".format(i,M,F)
    f.write(txt)

f.close()



#이상한 답

import pandas as pd

f = open("c:/python_data/yob/year_gender_total2.csv", "w")

for i in range(2000,2017):
    temp = pd.read_csv('c:/python_data/yob/yob{}.txt'.format(i), names = ['name', 'gender', 'cnt'])
    temp1 = temp.groupby(temp['gender']).sum()
    f_cnt = temp1.loc['F']
    m_cnt = temp1.loc['M']
    txt = "{},{},{}\n".format(i,f_cnt, m_cnt)
    f.write(txt)

f.close()


#답

import os
from pandas import Series, DataFrame
import pandas as pd
import numpy as np

with open('c:/python_data/year_gender_total.csv','w') as f:
    writer = csv.writer(f, delimiter=',')
    writer.writerow(['년도','여자','남자'])
    for y in range(2000,2017):
        filename='c:\python_data\yob%d.txt'%y
        name = os.path.basename(filename)
        name = name.split('.')[0]
        df = pd.read_csv(filename, names=['name','gender','birth'])
        gender_cn = df['birth'].groupby(df['gender']).sum()
        f_cn = gender_cn.loc['F']
        m_cn = gender_cn.loc['M']
        writer.writerow([name[3:],f_cn, m_cn])
        


#writing시 영어 외의 문자열은 utf-8로 encoding 을 해야 문자가 깨지지 않는다. option으로 encoding='utf-8'을 사용하기! 
with open('c:/python_data/year-gender_total.csv','w',encoding='utf-8') as f:
    
    
###############################################################################

▣ matplotlib: 시각화 패키지

import matplotlib as mpl
import matplotlib.pylab as plt

plt.plot([1,5,10,15,20])
#graph격자
plt.grid(True)  
#plot을 show 해줘
plt.show

#x축: [100,200,300,400,500], y축: [1,5,10,15,20]
plt.plot([100,200,300,400,500],[1,5,10,15,20])
#web에서는 show를 하지 않으면 출력하지 않기 때문에 plt.show를 하면 출력된다. (spider에서는 plt.show를 쓰지 않아도 plot이 제공되지만 그래프 정보만 나오는 경우는 plt.show를 해줘야 그래프를 볼 수 있다.)
plt.show


plt.plot([100,200,300,400,500],[1,5,10,15,20], color='blue')
plt.plot([100,200,300,400,500],[1,5,10,15,20], color='c')  #rgbcmyk
plt.plot([100,200,300,400,500],[1,5,10,15,20], color='r')
plt.plot([100,200,300,400,500],[1,5,10,15,20], color='b')
plt.plot([100,200,300,400,500],[1,5,10,15,20], color='g')
plt.plot([100,200,300,400,500],[1,5,10,15,20], color='m')
plt.plot([100,200,300,400,500],[1,5,10,15,20], color='y')
plt.plot([100,200,300,400,500],[1,5,10,15,20], color='k')
plt.show

#회색조
plt.plot([100,200,300,400,500],[1,5,10,15,20], color='0.75') #0~1 회색조
plt.show

#linestyle -solid, dashed, dashdot
plt.plot([100,200,300,400,500],[1,5,10,15,20], color='blue', linestyle='dotted')
plt.show

plt.plot([100,200,300,400,500],[1,5,10,15,20], color='blue', linestyle='solid')
plt.show

plt.plot([100,200,300,400,500],[1,5,10,15,20], color='blue', linestyle='dashed')
plt.show

plt.plot([100,200,300,400,500],[1,5,10,15,20], color='blue', linestyle='dashdot')
plt.show

#
plt.plot([100,200,300,400,500],[1,5,10,15,20], '--r') #dashed red
plt.show

plt.plot([100,200,300,400,500],[1,5,10,15,20], '.r')
plt.show

plt.plot([100,200,300,400,500],[1,5,10,15,20], '-g') #solid green
plt show

plt.plot([100,200,300,400,500],[1,5,10,15,20], '--c') #dashed cyan
plt.show 

plt.plot([100,200,300,400,500],[1,5,10,15,20], '-.k') #dashdot black
plt.show

plt.plot([100,200,300,400,500],[1,5,10,15,20], ':r') #dotted red 
plt.show


# anaconda propmt에서 jupyter notebook 실행

clrl +enter: 실행
alt + enter: command line 생성 


# 
data = {'홍길동':[15,13,11],
        '윤건' : [13,14,15],
        '나얼': [10,9,12]}
data

df = DataFrame(data, index=['2015','2016','2017'])
df.rank()

x = df.rank()
x

plt.plot(x)
plt.show()


#한글은 깨짐 -> font를 불러와야 함 
from matplotlib import font_manager, rc
font_name = font_manager.FontProperties(fname="c:/windows/fonts/malgun.ttf").get_name()
rc('font', family=font_name)


#범례만들기: label 
plt.plot(x.ix[:,0], label='나얼')
plt.plot(x.ix[:,1], label='윤건', linestyle='--')
plt.plot(x.ix[:,2], label='홍길동', linestyle=':')
plt.title('기록 순위 비교 그래프', fontsize=15)
plt.xlabel('년도', fontsize=10)
plt.ylabel('순위',fontsize=10)
plt.legend() 
#yticks: 기존의 레벨을 다른 형식으로 변환해 주는 method
plt.yticks([1,2,3],['1등','2등','3등'])
#xticks:
plt.xticks(['2015','2016','2017'],['2015년', '2016년', '2017년'])

plt.xlim([2015.9,2017.9])


#y축의 범위: ylim
plt.ylim([1,2,3])
#x축의 범위: xlim
plt.xlim([2015.9,2017.9])


#범례출력하기 

#수평막대그래프
df.plot(kind='barh')
df.plot(kind='barh', stacked=True)

#수직막대그래프
df.plot(kind='bar')
df.plot(kind='bar', stacked=True)



##############################################################################
[문제180] 2010 ~ 2016  년도까지 성별 출생 현황을 그래프를 그리세요.

#module import 
import csv
from pandas import Series,DataFrame
import numpy as np
import pandas as pd
import matplotlib as mpl
import matplotlib.pyplot as plt
from matplotlib import font_manager, rc
font_name = font_manager.FontProperties(fname="c:/Windows/Fonts/malgun.ttf").get_name()
rc('font', family=font_name)
%matplotlib inline

with open('c:/python_data/year_gender_total.csv','w',encoding="utf-8") as f:
    writer = csv.writer(f, delimiter=',')
    writer.writerow(['년도','여자','남자'])
    for y in range(2000,2017):
        filename='c:\python_data\yob\yob%d.txt'%y
        name = os.path.basename(filename)
        name = name.split('.')[0]
        df = pd.read_csv(filename, names=['name','gender','birth'])
        gender_cn = df['birth'].groupby(df['gender']).sum()
        writer.writerow([name[3:],gender_cn.loc['F'],gender_cn.loc['M']])
      


df = pd.read_csv('c:/python_data/year_gender_total.csv')
df
#여자만 뽑아내어 그래프를 그리고 싶다면 df['여자']로 해서 Data를 뽑아낸 다음 
df['여자']

#set_index : '년도'를 index로 표현하고 싶을 때 사용 
df = df.set_index("년도")
df
df.plot()
df.plot(kind="bar")
df.plot(kind="barh")

plt.plot(df.ix[:,0], label="여자", color="r", linestyle="--")
plt.plot(df.ix[:,1], label="남자", color="b", linestyle=":")
plt.title("성별 출생 현황", fontsize=15)
plt.xlabel("년도",fontsize=10)
plt.ylabel("출생수",fontsize=10)
plt.legend()
plt.grid()



# -*- coding: utf-8 -*-
"""
Created on Thu Sep 27 15:36:46 2018

@author: stu
"""

import sqlite3

# 메모리에다가 db를 구성
conn = sqlite3.connect(":memory:")

# conn에 cursor 생성
c = conn.cursor() 

c.execute("create table contact(name, mobile, email, address)")

c.execute("insert into contact(name, mobile, email, address) values('홍길동','010','100@','100')")

c.execute("select*from contact")

c.fetchone()

c.fetchone()

c.execute("insert into contact(name, mobile, email, address) values('박찬호','010','103','102')")

c.execute("select*from contact")

c.fetchone()

c.fetchone()

c.fetchall()

#영구히 저장되는 것이 아니라서 rollback 수행시 사라짐
conn.rollback()

#영구히 저장
conn.commit()


#커서닫기
c.close()
#connect(메모리)닫기
coon.close()

conn=sqlite3.connect(":memory:")

c = conn.cursor()
# 커서와 메모리를 close했기 때문에 안의 내용(table) 사라짐
c.exectue("select*from contact")

c.close()

conn.close()

# 파일로 떨어뜨리면 close한 이후에도 계속사용 가능
conn=sqlite3.connect("c:/data/insa.db")

c = conn.cursor()

c.execute("create table emp1(id integer, name text, sal integer)")

c.execute("insert into emp1(id,name,sal) values(1,'권아름',1000)")

c.execute("insert into emp1(id,name,sal) values(2,'박찬호',2000)")

c.execute("select * from emp1")

c.fetchall()

conn.commit()

c.close()

conn.close()

#
conn=sqlite3.connect("c:/data/insa.db")

c = conn.cursor()

#내가 만든 테이블 보기
c.execute("select name from sqlite_master where type='table'")

c.fetchall()

#PRAGMA table_info(테이블명) : 테이블의 정보 확인 (sql에서 desc)
c.execute("PRAGMA table_info(emp1)")

c.fetchall()
# values를 ?,?,?로 두고 후에 입력값 처리
c.execute("insert into emp1(id,name,sal) values(?,?,?)",(3,'나얼',3000))	

c.execute("select * from emp1")

c.fetchall()

#입력값 처리
insert_sql="insert into emp1(id,name,sal) values(?,?,?)"	
c.execute(insert_sql,(4,'윤건',4000))

c.execute("select * from emp1")

c.fetchall()


conn.commit()

c.execute("select * from emp1")

#fetchmany(4) : 4개만 보기
c.fetchmany(4)

c.execute("update emp1 set sal=6000 where id=1")

c.execute("select * from emp1 where id=1")

c.fetchone()

conn.rollback()

c.execute("select * from emp1 where id=1")

c.fetchone()

c.execute("delete from emp1 where id=2")

c.execute("select * from emp1")

c.fetchall()

#컬럼 추가
c.execute("alter table emp1 add column deptno integer")		

c.fetchall()

c.execute("select * from emp1")

c.fetchall()

c.execute("drop table emp1")

c.execute("create table emp(id integer,name text,sal integer,deptno integer)")

c.execute("insert into emp(id,name,sal,deptno) values(1,'홍길동',1000,10)")

c.execute("insert into emp(id,name,sal,deptno) values(2,'박찬호',2000,20)")

c.execute("insert into emp(id,name,sal,deptno) values(3,'나얼',3000,30)")

c.execute("insert into emp(id,name,sal,deptno) values(4,'윤건',4000,40)")

conn.commit()

c.execute("select * from emp")

c.fetchall()

c.execute("create table dept(deptno integer, dname text)")

c.execute("insert into dept(deptno,dname) values(10,'총무부')")

c.execute("insert into dept(deptno,dname) values(20,'영업1')")

c.execute("insert into dept(deptno,dname) values(30,'영업2')")

c.execute("insert into dept(deptno,dname) values(40,'분석팀')")

conn.commit()

c.execute("select * from dept")

c.fetchall()

c.execute("insert into emp(id,name,sal,deptno) values(5,'김건모',5000,null)")

c.execute("insert into dept(deptno,dname) values(50,'인사팀')")

conn.commit()

c.execute("select * from emp")

c.fetchall()

c.execute("select * from dept")

c.fetchall()

#join은 ANSI표준으로 지원함
c.execute("select emp.id,emp.name,emp.deptno,dept.dname from emp inner join dept on emp.deptno=dept.deptno")	

#emp.deptno가 null인 김건모는 출력되지 않음
c.fetchall()



#20180928 - 아름 필기
20180928


# Anaconda Prompt에서
pip install beautifulsoup4


# Spyder에서
from bs4 import BeautifulSoup

html="""
<html>								html은 트리형식
	<body>
		<h1> 스크래핑 </h1>
			<p> 웹페이지 분석하기 </p>
			<p> 데이터 정제작업하기 </p>
 			<p> 데이터 정제작업하기2 </p>
	</body>
</html>
"""

soup=BeautifulSoup(html,"html.parser")		parser라는 분석기를 돌려야함

soup
Out[6]: 

<html>
<body>
<h1> 스크래핑 </h1>
<p> 웹페이지 분석하기 </p>
<p> 데이터 정제작업하기 </p>
</body>
</html>


# 원하는 태그 내용을 가져오기
h1=soup.html.body.h1				h1 내용을 긁어오기

h1
Out[9]: <h1> 스크래핑 </h1>

h1.string					변수.string : 태그는 제거하고 문자만 출력
Out[10]: ' 스크래핑 '

p1=soup.html.body.p				첫번째 p 내용을 긁어오기

p1.string
Out[13]: ' 웹페이지 분석하기 '

p2=p1.next_sibling				태그와 태그 사이에는 \n이 내부적으로 있음
						따라서 두번째 태그 내용을 보고싶으면 next_sibling 두번해야 함
p2.string
Out[21]: '\n'					

p2=p1.next_sibling.next_sibling			첫번째.next_sibling.next_sibling : 두번째 p 내용을 긁어오기
										   p2는 p1의 형제
p2.string
Out[19]: ' 데이터 정제작업하기 '

p3=p2.next_sibling.next_sibling			세번째 p 내용 긁어오기, 두번째 p를 기준으로 next_sibling.next_sibling

p3.string
Out[33]: ' 데이터 정제작업하기2 '


html="""
<html>
<body>
<h1 id='title'> beautifulsoup </h1>			id라는 속성을 부여
<p id='subtitle'> 스크래핑 </p>
<p> 데이터 추출하기 </p>
</body>
</html>
"""

soup=BeautifulSoup(html,"html.parser")

soup.find(id='title').string
Out[56]: ' beautifulsoup '

title=soup.find(id='title')

title.string
Out[58]: ' beautifulsoup '

soup.find(id='subtitle').string
Out[59]: ' 스크래핑 '


html="""
<html>
	<body>
		<ul>
			<li> <a href="http://www.itwill.com"> 아이티윌 </a> </li>		링크를 생성하는 태그
			<li> <a href="http://www.naver.com"> 네이버 </a> </li>
	</body>
</html>
"""

soup=BeautifulSoup(html,"html.parser")

a1=soup.html.body.ul.li.a

a1.string
Out[49]: ' 아이티윌 '

soup.find('a')							find : 해당 태그의 첫번째 것만 찾아줌
Out[63]: <a href="http://www.itwill.com"> 아이티윌 </a>

soup.find('a').string
Out[64]: ' 아이티윌 '

soup.find_all('a')						find_all : 해당 태그의 모든 내용을 찾아줌
Out[65]: 
[<a href="http://www.itwill.com"> 아이티윌 </a>,
 <a href="http://www.naver.com"> 네이버 </a>]

a=soup.a

a								첫번째 것만 보여줌
Out[72]: <a href="http://www.itwill.com"> 아이티윌 </a>

a.attrs								a안의 속성의 값을 보여줌
Out[70]: {'href': 'http://www.itwill.com'}

'href' in a.attrs						href라는 key가 a.attrs에 존재하는가
Out[71]: True

a['href']							href의 values만 보기
Out[75]: 'http://www.itwill.com'

a.attrs['href']
Out[76]: 'http://www.itwill.com'


link=soup.find_all('a')						find_all을 통해 'a'속성의 값을 출력하면 list 형태이므로 string이 바로 안됨

link
Out[79]: 
[<a href="http://www.itwill.com"> 아이티윌 </a>,
 <a href="http://www.naver.com"> 네이버 </a>]

for i in link:
    print(i.attrs['href'])
    print(i.string)
    
http://www.itwill.com
 아이티윌 
http://www.naver.com
 네이버 

for i in link:
    print(i.attrs['href'])
    print(i.get_text())
    
http://itwill.co.kr
 아이티윌 
http://www.naver.com
 네이버 

link=soup.findAll('a')

for i in link:
    print(i.attrs['href'])
    print(i.string)
    
http://itwill.co.kr
 아이티윌 
http://www.naver.com
 네이버 

for i in link:
    print(i.attrs['href'])
    print(i.get_text())
    
http://itwill.co.kr
 아이티윌 
http://www.naver.com
 네이버



<html>
<head>
	<title> 나의 홈페이지 </title>
</head>
	
<body>
<p align ='center'> 환영합니다 </p>
<p align ='left'> 이름 : 권아름 <br> 나이 : 25 <br> 취미 : 음악감상 </p>
<p align ='right'> 오늘 하루도 행복하세요...</p>
<a href = 'http://itwill.co.kr' class='cafe1' id='link1'> 아이티윌 </a>
<a href = 'http://www.naver.com' class='cafe2' id='link2'> 네이버 </a>
<a href = 'http://www.google.com' class='cafe3' id='link3'> 구글 </a>
</body>
</html>

위의 내용을 c:/data에 a.html로 저장 (파일형식 : 모든파일, 인코딩 : UTF-8)


with open("c:/data/a.html",encoding='UTF8') as html:				a.html파일을 불러와서 분석하기
    soup=BeautifulSoup(html,'html.parser')
  
soup.find('title').string
Out[91]: ' 나의 홈페이지 '

soup.find('body')
Out[92]: 
<body>
<p align="center"> 환영합니다 </p>
<p align="left"> 이름 : 권아름 <br/> 나이 : 25 <br/> 취미 : 음악감상 </p>
<p align="right"> 오늘 하루도 행복하세요...</p>
<a class="cafe1" href="http://itwill.co.kr" id="link1"> 아이티윌 </a>
<a class="cafe2" href="http://www.naver.com" id="link2"> 네이버 </a>
<a class="cafe3" href="http://www.google.com" id="link3"> 구글 </a>
</body>

p=soup.find_all('p')

p
Out[95]: 
[<p align="center"> 환영합니다 </p>,
 <p align="left"> 이름 : 권아름 <br/> 나이 : 25 <br/> 취미 : 음악감상 </p>,
 <p align="right"> 오늘 하루도 행복하세요...</p>]

for i in p:
    print(i.string)
    
 환영합니다 
None						p라는 태그안에 글자열을 변경하는 태그가 사용된 경우 None으로 출력
 오늘 하루도 행복하세요...

for i in p:
    print(i.get_text())				get_text() : text를 모두 출력
    
 환영합니다 
 이름 : 권아름  나이 : 25  취미 : 음악감상 
 오늘 하루도 행복하세요...

p=soup.findAll('p')

for i in p:
    print(i.get_text())
    
 환영합니다 
 이름 : 권아름  나이 : 25  취미 : 음악감상 
 오늘 하루도 행복하세요...

soup.find('body')
Out[104]: 
<body>
<p align="center"> 환영합니다 </p>
<p align="left"> 이름 : 권아름 <br/> 나이 : 25 <br/> 취미 : 음악감상 </p>
<p align="right"> 오늘 하루도 행복하세요...</p>
<a class="cafe1" href="http://itwill.co.kr" id="link1"> 아이티윌 </a>
<a class="cafe2" href="http://www.naver.com" id="link2"> 네이버 </a>
<a class="cafe3" href="http://www.google.com" id="link3"> 구글 </a>
</body>

soup.find('body').string			아무것도 안나옴

soup.find('body').get_text()			\n으로 구분되서 text 출력
Out[106]: '\n 환영합니다 \n 이름 : 권아름  나이 : 25  취미 : 음악감상 \n 오늘 하루도 행복하세요...\n 아이티윌 \n 네이버 \n 구글 \n'

soup.find('body').get_text(strip=True)		모두 붙여서 출력
Out[107]: '환영합니다이름 : 권아름나이 : 25취미 : 음악감상오늘 하루도 행복하세요...아이티윌네이버구글'

body=soup.find('body')

for i in body:
    print(i.string)
    
 환영합니다 


None


 오늘 하루도 행복하세요...


 아이티윌 


 네이버 


 구글 

for i in body:
    print(i.get_text())							get_text()는 find_all / findAll에서만 되는 메소드
AttributeError: 'NavigableString' object has no attribute 'get_text'

body=soup.find_all('body')

for i in body:
    print(i.get_text())
    

 환영합니다 
 이름 : 권아름  나이 : 25  취미 : 음악감상 
 오늘 하루도 행복하세요...
 아이티윌 
 네이버 
 구글 

body=soup.findAll('body')

for i in body:
    print(i.get_text())
    

 환영합니다 
 이름 : 권아름  나이 : 25  취미 : 음악감상 
 오늘 하루도 행복하세요...
 아이티윌 
 네이버 
 구글


soup.find('a')
Out[114]: <a class="cafe1" href="http://itwill.co.kr" id="link1"> 아이티윌 </a>

a=soup.find_all('a')

for i in a:
    print(i.get_text())
    
 아이티윌 
 네이버 
 구글 

a=soup.findAll('a')

for i in a:
    print(i.get_text())
    
 아이티윌 
 네이버 
 구글


a1=soup.findAll('a',{'class':'cafe1'})				같은 레벨의 a태그가 여러개 있을 경우 class 또는 id 속성을 통해서 찾기

a1
Out[128]: [<a class="cafe1" href="http://itwill.co.kr" id="link1"> 아이티윌 </a>]

for i in a1:
    print(i.attrs['href'])
    print(i.get_text())
    
http://itwill.co.kr
 아이티윌 

a2=soup.findAll('a',{'class':'cafe2'})

a2
Out[131]: [<a class="cafe2" href="http://www.naver.com" id="link2"> 네이버 </a>]

for i in a2:
    print(i.get_text())
    
 네이버 

a3=soup.findAll('a',{'class':'cafe3'})

a3
Out[133]: [<a class="cafe3" href="http://www.google.com" id="link3"> 구글 </a>]

for i in a3:
    print(i.get_text())
    
 구글


a1=soup.find('a',{'class':'cafe1'})

for i in a1:
    print(i.get_text())					find에서는 get_text()를 쓸 수 없음
    
AttributeError: 'NavigableString' object has no attribute 'get_text'

for i in a1:
    print(i.string)					find를 쓸 때는 string를 사용해야함
    
 아이티윌 

for i in a1:
    print(i.attrs['href'])				find에서는 attrs를 쓸 수 없음
    print(i.string)

AttributeError: 'NavigableString' object has no attribute 'attrs'


a1=soup.findAll('a',{'id':'link1'})			id라는 속성을 이용해서 찾기

for i in a1:
    print(i.attrs['href'])
    print(i.get_text())
    
http://itwill.co.kr
 아이티윌 

a2=soup.findAll('a',{'id':'link2'})

for i in a2:
    print(i.attrs['href'])
    print(i.get_text())
    
http://www.naver.com
 네이버 

for i in soup.findAll('a',{'id':'link3'}):
    print(i.attrs['href'])
    print(i.get_text())
    
http://www.google.com
 구글 


soup.findAll(class='cafe1')
                     ^
SyntaxError: invalid syntax			오류남, class_ 꼭 해줘야함

soup.findAll(class_='cafe1')
Out[152]: [<a class="cafe1" href="http://itwill.co.kr" id="link1"> 아이티윌 </a>]

for i in soup.findAll(class_='cafe1'):
    print(i.attrs['href'])
    print(i.get_text())
    
http://itwill.co.kr
 아이티윌 

for i in soup.findAll(id='link1'):		id는 _하면 안됨
    print(i.attrs['href'])
    print(i.get_text())
    
http://itwill.co.kr
 아이티윌


for i in soup.findAll('a'):
    print(i.get('href'))			href 속성의 값을 출력
    
http://itwill.co.kr
http://www.naver.com
http://www.google.com

soup.findAll(['a','p'])				여러 태그를 동시에 보고자 할 때는 [] 사용
Out[159]: 
[<p align="center"> 환영합니다 </p>,
 <p align="left"> 이름 : 권아름 <br/> 나이 : 25 <br/> 취미 : 음악감상 </p>,
 <p align="right"> 오늘 하루도 행복하세요...</p>,
 <a class="cafe1" href="http://itwill.co.kr" id="link1"> 아이티윌 </a>,
 <a class="cafe2" href="http://www.naver.com" id="link2"> 네이버 </a>,
 <a class="cafe3" href="http://www.google.com" id="link3"> 구글 </a>]

for i in soup.findAll(['a','p']):
    print(i.get_text())
    
 환영합니다 
 이름 : 권아름  나이 : 25  취미 : 음악감상 
 오늘 하루도 행복하세요...
 아이티윌 
 네이버 
 구글 



import urllib.request as req						BeautifulSoup은 다운로드 기능이 없어서 urllib.request사용

url="http://www.weather.go.kr/weather/forecast/mid-term-rss3.jsp"

res=req.urlopen(url)

res
Out[166]: <http.client.HTTPResponse at 0x8c278d0>

soup=BeautifulSoup(res,'html.parser')

soup.find('title').string
Out[170]: '기상청 육상 중기예보'

http://www.weather.go.kr/weather/forecast/mid-term-rss3.jsp
인터넷 화면에서 오른쪽버튼 - 소스보기
크롬으로 들어가면 자동으로 태그가 보임 (오른쪽 버튼 - 검사)



# -*- coding: utf-8 -*-
"""
Created on Mon Oct  1 09:49:43 2018

@author: stu
"""

from bs4 import BeautifulSoup

#html 가상으로 만들기

html="""
<html>
<body>
<div id = 'lecture1'>
<h1> 데이터 과학 </h1>
</div>
<div id = 'lecture2'>
<h1> 빅데이터분석 </h1>
<ul class = 'subject'>
<li> SQL </li>
<li> R </li>
<li> PYTHON </li>
</ul> 
</div>
</body>
</html>
"""

#분석기를 돌려야하고, 분석기는 저장해 둬야함 eg. soup

soup = BeautifulSoup(html, 'html.parser')


#h1 찾기: body는 생략가능 
##방법1
soup.html.div.h1.string                                                        
##방법2
soup.find('h1').string

#태그 모두 제거
soup.find('h1').get_text()
soup.find('h1').text

#변수에 h1 담기
h1 = soup.find('h1')
h1.string

#두번째 h1찾기
h2 = soup.find(id='lecture2')
h2.find('h1').string                                                            

#Python 찾기 (webpage에서 출력되는것;li목록이 다른 것에도 있을 것이라는 가정하에 뽑아내야함) 
#class_
soup.find('ul', class_='subject').string
#li가 여러개이기 때문에 get_text로 찾아야 함 -> 그러나 \n도 출력되기 때문에 다음 번과 같이 한다.
soup.find('ul', class_='subject').get_text()

ul = soup.find('ul', class_='subject')
for i in ul:
    print(i.string)
 
ul = soup.find('ul', class_='subject')                                          # 오류  
for i in ul:
    print(i.get_text())

for i in ul:                                                                   # 오류 
    print(i.text)
    
#find_all : 다 찾는 것  -> string으로는 찾아지지 않는다. : 따라서 get_text()를 이용해야함!
ul = soup.find_all('ul', class_='subject')
for i in ul:
    print(i.stirng)

ul = soup.find_all('ul', class_='subject')
for i in ul:
    print(i.get_text())

# 위와 유사한 method findAll
ul = soup.findAll('ul', class_='subject')
for i in ul:
    print(i.text)
    
# class 속성을 찾아야할 때는 꼭 class_로 넣어주거나 dictonary 모양으로 만들어 {'class':'subject'} 찾거나 하면 된다. (방법2가지)
ul = soup.find_all('ul', {'class':'subject'})
for i in ul:
    print(i.text)
    
    
■ css(cascading stylesheets)    
#stylesheets(eg. div..) 들에 대해서 편하게 분석하는 제공 툴 
□  select_one은 css 선택자 요소 하나를 추출   #find와 같은 역할을 한다. 

soup.select_one('div > h1').string      #>은 계층에 대한 표현

#두번째 h1을 찾기 -> id의 속성을 통해서 찾을 수 있음 
#div안에 id값을 표시할 때는 #(기호 샵)을 사용한다. 
soup.select_one('div#lecture1 > h1').string 

soup.select_one('div#lecture2 > h1').string 

                
# div.content 
-> .(점)은 그 안에 들어 있는 class를 의미한다. 


□ select는 css 선택자로 요소 여러개를 리스트로 추출한다. (기호의 의미 #:id, .:class를 의미)
s = soup.select('div#lecture2 > ul.subject > li')
for i in s:
    print(i.string)



■ 매번 url이 바뀔 경우에 crawling을 할 경우 
환율 정보 예시> 
https://finance.naver.com/marketindex/?tabSel=exchange#tab_section
https://finance.naver.com/marketindex


예를 들어 미국 환율만 뽑아 낼 경우 -> F12 -> 요소검사 -> span.value -> class가 value해당하는 string 값을 뽑아 내면 된다. 
<span class="value">1,111.80</span>

□url 내용을 가져오기 
from bs4 import BeautifulSoup
import urllib.request as req 

url = "https://finance.naver.com/marketindex"
res = req.urlopen(url)  #url에 있는 site내용을 가져옴 

#분석하기
soup = BeautifulSoup(res,"html.parser")
dollar = soup.select_one('div.head_info > span.value').string
print('USD/KRW', dollar)

□ copy> copy selector 으로 상위 정보와 함께 가져오기 ; 
1) #exchangeList > li.on > a.head.usd > div > span.value
2) soup.select_one을 통해서 span.vaule 뽑아내기 

1)    
#달러 찾기 
soup.select_one("#exchangeList > li.on > a.head.usd > div > span.value").string

#엔화 찾기
soup.select_one("a.head.jpy > div > span.value").string
soup.select_one("div.head_info.point_dn > span.value").string

#중국 원화 찾기
soup.select_one("a.head.cny > div > span.value").string


■ naver 실시간 검색
url1 = "https://datalab.naver.com/keyword/realtimeList.naver"
res = req.urlopen(url1)

soup = BeautifulSoup(res,"html.parser")
soup

막히네요.. 


#content > div > div.keyword_carousel > div > div > div:nth-child(1) > div > div > ul
ul = soup.find('ul', class_='rank_list')                                          # 오류  
for i in ul:
    print(i.text)


# =============================================================================
# 오후 수업 시작
# =============================================================================
html = """
<ul id = '조선왕'>
<li id = '태조'> '이성계' </li>
<li id = '정조'> '이방과' </li>
<li id = '태종'> '이방원' </li>
<li id = '세종'> '이도' </li>
<li id = '문종'> '이향' </li>
</ul>
"""

soup = BeautifulSoup(html, "html.parser")

#세종의 이름 뽑아내기; 세종의 id 속성 뽑아내기
soup.select_one("#세종").string
soup.select_one("#세종").text
soup.select_one("li#세종").string
soup.select_one("ul > li#세종").string
soup.select_one("#조선왕 #세종").string
soup.select_one("ul#조선왕 > li#세종").string
soup.select_one("li[id=세종]").string
#li:nth-of-type: li의 순서를 제한하여 id 속성 뽑아내기
soup.select_one("li:nth-of-type(4)").string
soup.select('li')

# list 형식으로 되어있는 text를 추출하기
for i in soup.select('li'):
    print(i.text)
    
soup.select('li')[0].string
soup.select('li')[3].string

#환율정보 nth-of-type 사용하기 (여러번 사용할 경우, 오류가 발생한다.-> 그땐 변수에 담아놓고 다시 시작하는 방법을 사용할 수 있다.)
url = "https://finance.naver.com/marketindex"
res = req.urlopen(url)
soup = BeautifulSoup(res,"html.parser")
l = soup.select_one('div.market1 > div.data > ul.data_lst > li:nth-of-type(1)')
l.select_one("span:nth-of-type(2)").string

#li:nth-of-type(2)
l = soup.select_one('div.market1 > div.data > ul.data_lst > li:nth-of-type(2)')
l.select_one("span:nth-of-type(2)").string

#li:nth-of-type(3)
l = soup.select_one('div.market1 > div.data > ul.data_lst > li:nth-of-type(3)')
l.select_one("span:nth-of-type(2)").string

#market2
l = soup.select_one('div.market2 > div.data > ul.data_lst > li:nth-of-type(1)')
l.select_one("span:nth-of-type(2)").string

#market3
l = soup.select_one('div.market3 > div.data > ul.data_lst > li:nth-of-type(1)')
l.select_one("span:nth-of-type(2)").string



# =============================================================================
# 개인실습: 네이버 부동산
# =============================================================================
url_reals = "https://land.naver.com/article/articleList.nhn?rletNo=97&rletTypeCd=A01&tradeTypeCd=A1"
real_state = req.urlopen(url_reals)
soup = BeautifulSoup(real_state, "html.parser")

#홀수만 매물 정보 검색가능
info = soup.select_one('tbody > tr:nth-of-type(1)')
info

price = info.select_one('td:nth-of-type(7)')
test = price.select_one('td > div> strong#')
test
                 
price.select_one('td > div > strong')


e.select_one('td:nth-of-type(7) > div > strong title')



# sale 타입
info.select_one('td:nth-of-type(1)')
info.select_one('td:nth-of-type(1) > div#inner')

# 특징
info.select_one('td:nth-of-type(2)')
# 단지정보 
info.select_one('td:nth-of-type(3)')
# 면적 
info.select_one('td:nth-of-type(4)')
# 동정보
info.select_one('td:nth-of-type(5)')
# 층수 정보
info.select_one('td:nth-of-type(6)')
# 중개업소 
info.select_one('td:nth-of-type(8)')


# =============================================================================
# 동아일보로 부터 인공지능 링크값 가져오기 
# =============================================================================
#contents > div:nth-child(9) > div > div:nth-child(2) > div.t > p.tit > a


url_ai = "http://news.donga.com/search?check_news=1&more=1&sorting=1&range=1&search_date=&query=%EC%9D%B8%EA%B3%B5%EC%A7%80%EB%8A%A5"
ai = req.urlopen(url_ai)
soup = BeautifulSoup(ai, "html.parser")
soup

#
a = soup.select_one('.searchCont > div:nth-of-type(3) > div.t > p.tit > a')

#url 불러오기
lst = []
for i in soup.select('div.searchList > div.t > p.tit'):
    print(i.select_one('a')['href'])
    lst.append(i.select_one('a')['href'])


#본문 기사 정보 긁어오기 
lst    

cn = 0
txt = []
for i in lst:
    print(i)
    res = req.urlopen(i).read().decode('utf-8')
    soup = BeautifulSoup(res, 'html.parser')
    result = soup.select('div.article_txt')
    
    
    for i in result:
        #print(i.text)
       txt.append(i.text)
 txt
    
new_txt = []

for i in range(0,15):
    new_txt.append(txt[i][0:txt[i].find('Copyright')])
     

# =============================================================================
# 설치하기 : konlpy 
# =============================================================================
Anaconda Prompt 
-설치 pip install konlpy 
- Java base 로 구현되어 있음 
- Java base 설치가 되어있어야 구현이 가능함 

- konlpy 실행이 안될 경우: pip install jpype1
- pip install jpype1 도 안될 경우: 밑의 step3개를 따르세요.
 
#step1
https://konlpy-ko.readthedocs.io/ko/v0.4.3/install/

#step2
https://www.lfd.uci.edu/~gohlke/pythonlibs/#jpype
JPype allows full access to Java class libraries. 

python 버전 확인 -> 3.6이기 때문에 / 운영체제 64bit이므로 
다운로드 : JPype1‑0.6.3‑cp36‑cp36m‑win_amd64.whl 
저장: c드라이브에 

#step3 
anaconda prompt을 관리자 권한으로 실행 
-> command line에서 cd c:\로 만들고 다시 설치 
-> dir *.whl # 파일이 있는지 확인

pip install JPype1‑0.6.3‑cp36‑cp36m‑win_amd64.whl

# =============================================================================
# konlpy 실행시키기
# =============================================================================
#java 경로 설정 
1) jdk의 위치 확인 후 
2) 시스템 고급 설정 > 환경변수
3) stu에 대한 사용자 변수 > 새로만들기
    -변수이름: JAVA_HOME
    -변수값: jdk 위치
4) 시스템 변수
    ;JAVA_HOME

#konlpy 실행 
from konlpy.tag import Twitter

twitter = Twitter()

malist = twitter.pos("아버지 가방에 들어가신다.", norm=True, stem=True)

print(malist)

pos: 형태소 분석
norm : 그래욬ㅋㅋㅋㅋ -> 그래요 로 바꿔줌
stem : 그렇다 원형을 찾아 준다

# 그래욬ㅋㅋㅋ 분석 
slang = twitter.pos('그래욬ㅋㅋㅋ', norm=True,  stem = True)
print(slang)

#txt분석 
txt = "텍스트 마이닝은 텍스트 형태의 데이터를 수학적 알고리즘에 기초하여 수집 , 처리 분석, 요약하는 연구 기법을 통칭하는 용어이다."

twitter.nouns(txt)



# -*- coding: utf-8 -*-
"""
Created on Tue Oct  2 09:45:42 2018

@author: stu
"""

# =============================================================================
# KoNLPY(코엔엘파이) : 한국어 정보처리를 위한 파이썬 패키지
# =============================================================================

▣ KoNLPY(코엔엘파이) : 한국어 정보처리를 위한 파이썬 패키지

■ 형태소(morpheme)
- 언어학에서 일정한 의미가 있는 가장 작은 말의 단위를 뜻함 
- 자연어 처리에서 토큰으로 형태소를 이용한다. 

■ 형태소 분석(morphological analysis)
- 단어로 부터 어근, 접두사, 접미사, 품사 등 다양한 언어적 속성을 파악하고 이를 이용하여 형태소를 찾아내거나 처리하는 작업

■ KoNLPy
- 형태소 분석을 하기위해서 필요한 라이브러리를 모아 놓은 패키지이다.

■ 형태소 분석기 종류
    □ Twitter
    - 트위터 코리아에서 개발 
    - https://github.com/twitter/twitter-korean-text
    
    □ Kkma(꼬꼬마)
    - 서울대학교 개발
    - http://kkma.snu.ac.kr
    
    □ Hannaum(한나눔)
    - KAIST
    - http://semanticweb.kaist.ac.kr/hannanum
    
    □ Mecav(매카브)
    - 일어용 형태소 분석기를 한국어를 사용할 수 있도록 수정
    - http://bitbucket.org/eunjeon/mecab-ko
    
    □ Komoran(코모란)
    - shineware에서 개발 
    - http://github.com/shin285/KOMORAN

■ 설치 
pip install konlpy
pip install jpype1

■ 꼬꼬마 실행
from konlpy.tag import Kkma
kkma = Kkma() 

txt = '통찰력은 사물이나 현상의 원인과 결과를 이해하고 간파하는 능력이다. 통찰력을 얻는 좋은 방법은 독서이다'
txt1 = '통찰력은 사물이나 현상의 원인과 결과를 이해하고 간파하는 능력이고 통찰력을 얻는 좋은 방법은 독서이다'

#문장을 분석 
kkma.sentences(txt)
kkma.sentences(txt1)

#형태소 분석
kkma.pos(txt)

#명사 분석
kkma.nouns(txt)

■ Twitter 실행
from konlpy.tag import Twitter
twitter = Twitter()

#형태소 분석
twitter.pos(txt)

#명사 분석
twitter.nouns(txt)

#트위터에서 추가적으로 제공하는 부분: 맞춤법, 원형
txt = '그래욬ㅋㅋㅋㅋ'
twitter.pos(txt, norm=True, stem=True)
norm: '그래욬ㅋㅋㅋ -> 그래요'
stem: 그렇다 원형으로 찾아준다.

#꼬꼬마와 트위터 비교하기
txt = '텍스트 마이닝은 텍스트 형태의 데이터를 수학적 알고리즘에 기초하여 수집, 처리, 분석, 요약하는 연구기법을 통칭하는 용어이다.'

kkma.pos(txt)
twitter.pos(txt)

#konlpy의 corpus위치 정보
C:\Users\stu\Anaconda3\Lib\site-packages\konlpy\data\corpus

■ nltk 설치/실행: 
pip install nltk

import nltk

from konlpy.corpus import kolaw
#kolaw 디렉토리에 있는 내용을 보여줌 
kolaw.fileids()
#파일 읽어 들이기 
doc_ko = kolaw.open('constitution.txt').read()
#twitter로 명사를 뽑아내고 별도의 변수에 저장
tokens_ko = twitter.nouns(doc_ko)
tokens_ko
# 단어의 수를 세기 -> dictonary형으로 자료형으로 만들어 없으면 새로운 방을 만들어 counting, 있으면 누적해서 counting
# 단어의 수를 세기: nltk method 이용하기
ko = nltk.Text(tokens_ko)
# token이 만들어짐
ko.tokens
#단어개수를 뽑아줌
len(ko.tokens) 
#단어의 중복제거
len(set(ko.tokens))
#단어의 빈도수 
ko.vocab()

■ plot 만들기 -> 한국어를 깨지지 않게 하기 위해 폰트를 불러와야 함 
import matplotlib.pyplot as plt
from matplotlib import font_manager ,rc
font_name = font_manager.FontProperties(fname="c:\windows\Fonts\malgun.ttf").get_name()
rc('font',family=font_name)

# plot 만들기 
plt.figure(figsize=(12,6))
ko.plot(50) #상위 50개만 보여주기
plt.show()

#빈도 상위 10개 단어 보여주기 
ko.vocab().most_common(10)


■ 분석해야할 문서는 임의로 절대적 경로를 불러들일 수 없고, corpus위치 정보에 넣어야 함
- 문재인 대통령 취임사를 바탕으로 다시 분석하기
kolaw.fileids()

doc_ko = kolaw.open('moon_speech.txt').read()
#twitter로 명사를 뽑아내고 별도의 변수에 저장
tokens_ko = twitter.nouns(doc_ko)
tokens_ko
# 단어의 수를 세기 -> dictonary형으로 자료형으로 만들어 없으면 새로운 방을 만들어 counting, 있으면 누적해서 counting
# 단어의 수를 세기: nltk method 이용하기
ko = nltk.Text(tokens_ko)
# token이 만들어짐
ko.tokens
#단어개수를 뽑아줌
len(ko.tokens) 
#단어의 중복제거
len(set(ko.tokens))
#단어의 빈도수 
ko.vocab()


import matplotlib.pyplot as plt
from matplotlib import font_manager ,rc
font_name = font_manager.FontProperties(fname="c:\windows\Fonts\malgun.ttf").get_name()
rc('font',family=font_name)

# plot 만들기 
plt.figure(figsize=(12,6))
ko.plot(20) #상위 20개만 보여주기
plt.show()

#빈도 상위 10개 단어 보여주기 
ko.vocab().most_common(10)

■ 불용어(필요없는글자;stopword) 제거하기 
#리스트 변수에 불용어 만들기 
stopword=['.',',','(',')','의','지','에','간','것','곳','달','저','이','과','향']
#리스트 내장객체 생각해보기  (eachword가 stopword에만 없어야 ko안에서 eachwod를 리스트로 만들기)
ko = [eachword for eachword in ko if eachword not in stopword]
#토큰작업
ko = nltk.Text(ko)
# token이 만들어짐
ko.tokens
#단어개수를 뽑아줌
len(ko.tokens) 
#단어의 중복제거
len(set(ko.tokens))
#단어의 빈도수 
ko.vocab()
ko.vocab().most_common(10)

■ 다양한 method 
#특정단어 개수 세기
ko.count('국민')
#특정단어와 연관있는 단어(특정단어 side에 있는 단어)
ko.concordance('약속')
ko.concordance('문재인')

■ wordcloud install하기/ 실행하기
#Anaconda Prompt에 설치하기
pip install wordcloud
# 실행하기 (spyder에서 )
from wordcloud import WordCloud
#data 변수에 상위 30개 단어 담기
data = ko.vocab().most_common(30)
#wordcloud 만들기
wordcloud = WordCloud(font_path="c:\Windows\Fonts\malgunbd.ttf", background_color='white', width=1000, height=800).generate_from_frequencies(dict(data))
plt.figure(figsize=(10,10))
plt.imshow(wordcloud)
plt.axis("off")
plt.show()

# =============================================================================
# 꼬꼬마로 문재인 취임사 분석하기 (twitter로 분석한 부분 kkma로만 바꾸고 다시 실행)
# =============================================================================
■ 꼬꼬마로 분석하기 
doc_ko = kolaw.open('moon_speech.txt').read()
#kkoma로 명사를 뽑아내고 별도의 변수에 저장
tokens_ko = kkma.nouns(doc_ko)
tokens_ko
# 단어의 수를 세기 -> dictonary형으로 자료형으로 만들어 없으면 새로운 방을 만들어 counting, 있으면 누적해서 counting
# 단어의 수를 세기: nltk method 이용하기
ko = nltk.Text(tokens_ko)
# token이 만들어짐
ko.tokens
#단어개수를 뽑아줌
len(ko.tokens) 
#단어의 중복제거
len(set(ko.tokens))
#단어의 빈도수 
ko.vocab()


import matplotlib.pyplot as plt
from matplotlib import font_manager ,rc
font_name = font_manager.FontProperties(fname="c:\windows\Fonts\malgun.ttf").get_name()
rc('font',family=font_name)

# plot 만들기 
plt.figure(figsize=(12,6))
ko.plot(20) #상위 20개만 보여주기
plt.show()

#빈도 상위 10개 단어 보여주기 
ko.vocab().most_common(10)

■ 불용어(필요없는글자;stopword) 제거하기 
#리스트 변수에 불용어 만들기 
stopword=['.',',','(',')','의','지','에','간','것','곳','달','저','이','과','향']
#리스트 내장객체 생각해보기  (eachword가 stopword에만 없어야 ko안에서 eachwod를 리스트로 만들기)
ko = [eachword for eachword in ko if eachword not in stopword]
#토큰작업
ko = nltk.Text(ko)
# token이 만들어짐
ko.tokens
#단어개수를 뽑아줌
len(ko.tokens) 
#단어의 중복제거
len(set(ko.tokens))
#단어의 빈도수 
ko.vocab()
ko.vocab().most_common(10)

■ 다양한 method 
#특정단어 개수 세기
ko.count('국민')
#특정단어와 연관있는 단어(특정단어 side에 있는 단어)
ko.concordance('약속')
ko.concordance('문재인')

■ wordcloud install하기/ 실행하기
#Anaconda Prompt에 설치하기
pip install wordcloud
# 실행하기 (spyder에서 )
from wordcloud import WordCloud
#data 변수에 상위 30개 단어 담기
data = ko.vocab().most_common(30)
#wordcloud 만들기
wordcloud = WordCloud(font_path="c:\Windows\Fonts\malgunbd.ttf", background_color='white', width=1000, height=800).generate_from_frequencies(dict(data))
plt.figure(figsize=(10,10))
plt.imshow(wordcloud)
plt.axis("off")
plt.show()

# =============================================================================
# [문제185]동아일보 검색을 토대로 nlp분석
# =============================================================================

from bs4 import BeautifulSoup

#url가져오기
import urllib.request as req 

url_ai = 'http://news.donga.com/search?check_news=1&more=1&sorting=1&range=1&search_date=&query=%EC%9D%B8%EA%B3%B5%EC%A7%80%EB%8A%A5'
ai = req.urlopen(url_ai)

#분석하기
soup_ai = BeautifulSoup(ai,"html.parser")
soup_ai


a_ai = soup_ai.select_one('.searchCont > div:nth-of-type(3) > div.t > p.tit > a')
a_ai

#url 불러오기
lst = []
for i in soup_ai.select('div.searchList > div.t > p.tit'):
    print(i.select_one('a')['href'])
    lst.append(i.select_one('a')['href'])
    
#본문 기사 정보 긁어오기 
lst   

cn = 0
txt = []
for i in lst:
    print(i)
    res = req.urlopen(i).read().decode('utf-8')
    soup = BeautifulSoup(res, 'html.parser')
    result = soup.select('div.article_txt')
    
    
    for i in result:
        #print(i.text)
       txt.append(i.text)
txt
    
new_txt = []

for i in range(0,15):
    new_txt.append(txt[i][0:txt[i].find('Copyright')])

#converting to list to string 1st way
news = ''
for i in new_txt :
    news +=i

news

#converting list to string 2nd way
str_ai =''.join(new_txt)
str_ai

■ twitter로 분석하기
from konlpy.tag import Twitter
twitter = Twitter()

#token작업 
ai_tokens = twitter.nouns(str_ai)
ai_tokens

# 단어의 수를 세기: nltk method 이용하기
ai = nltk.Text(ai_tokens)
# token이 만들어짐
ai.tokens
#단어개수를 뽑아줌
len(ai.tokens) 
#단어의 중복제거
len(set(ai.tokens))
#단어의 빈도수 
ai.vocab()


import matplotlib.pyplot as plt
from matplotlib import font_manager ,rc
font_name = font_manager.FontProperties(fname="c:\windows\Fonts\malgun.ttf").get_name()
rc('font',family=font_name)

# plot 만들기 
plt.figure(figsize=(12,6))
ai.plot(10) #상위 20개만 보여주기
plt.show()

#빈도 상위 10개 단어 보여주기 
ai.vocab().most_common(10)

■ 불용어(필요없는글자;stopword) 제거하기 
#리스트 변수에 불용어 만들기 
stopword=['.',',','(',')','의','것','등','또','고','수','곳','이','간엔','창','며','명','개','박','원', '때문', '더', '중', '은', '그', '건', '도', '를', '로','라며','위해']
#리스트 내장객체 생각해보기  (eachword가 stopword에만 없어야 ko안에서 eachwod를 리스트로 만들기)
ai = [eachword for eachword in ko if eachword not in stopword]
#토큰작업
ai = nltk.Text(ai)
# token이 만들어짐
ai.tokens
#단어개수를 뽑아줌
len(ai.tokens) 
#단어의 중복제거
len(set(ai.tokens))
#단어의 빈도수 
ai.vocab()
ai.vocab().most_common(1000)


■ wordcloud install하기/ 실행하기
#Anaconda Prompt에 설치하기
pip install wordcloud
# 실행하기 (spyder에서 )
from wordcloud import WordCloud
#data 변수에 상위 30개 단어 담기
data = ai.vocab().most_common(50)
#wordcloud 만들기
wordcloud = WordCloud(font_path="c:\Windows\Fonts\malgunbd.ttf", background_color='white', width=1000, height=800).generate_from_frequencies(dict(data))
plt.figure(figsize=(10,10))
plt.imshow(wordcloud)
plt.axis("off")
plt.show()



#[문제 185] 쌤답 - kkma사용
    #주의해야할 부분
        #기사형식에서 버려야 할 것을 버리고 string으로 저장 (1)
        #파일로 떨어뜨려 저장한 뒤, 파일로 읽어들여 분석하기 (2)

import urllib.request
from bs4 import BeautifulSoup

params = []
for i in range(1,50,15):
    list_url = "http://news.donga.com/search?p="+str(i)+"&query=%EC%9D%B8%EA%B3%B5%EC%A7%80%EB%8A%A5&check_news=1&more=1&sorting=1&search_date=1&v1=&v2=&range=1"

    url = urllib.request.Request(list_url)
    res = urllib.request.urlopen(url, timeout=100).read().decode("utf-8")
    soup= BeautifulSoup(res, "html.parser")
    for link in soup.findAll('p', class_='tit'):
        params.append(link.find('a').get('href'))


txt= []
for i in params:
    #print(i)
    url = urllib.request.Request(i)
    res = urllib.request.urlopen(url).read().decode("utf-8")
    soup= BeautifulSoup(res, "html.parser")
    result = soup.find_all('div',{'class':'article_txt'})
    
    
    for i in result:
        #print(i.text)
       txt.append(i.text)


#기사형식에서 버려야 할 것을 버리고 string으로 저장 (1)
new_text =''
for i in range(0,60):
    new_text = new_text + txt[i][0:txt[i].find('Copyright')] + '\n'
    

import nltk
from konlpy.tag import Kkma
kkma = Kkma()

tokens_ko = kkma.nouns(new_text)
tokens_ko

ko = nltk.Text(tokens_ko)
len(ko.tokens)
len(set(ko.tokens))
ko.vocab()
ko.vocab().most_common(50)


#파일로 떨어뜨려 저장한 뒤, 파일로 읽어들여 분석하기 (2)
with open("c:/data/new_text.txt","w",encoding="utf-8") as file:
    for i in range(0,60):
        file.write(txt[i][0:txt[i].find('Copyright')])


with open("c:/data/new_text.txt","r",encoding="utf-8") as file:
    news = file.read()          #file.read(): 하나의 문서로 그대로 가져옴/ -> readlines으로 하면 안됨; list형식으로 가져오기 때문에 


import nltk
from konlpy.tag import Kkma
kkma = Kkma()

tokens_ko = kkma.nouns(news)
ko = nltk.Text(tokens_ko)
ko.vocab()



# =============================================================================
# wordcloud - 그림 넣기;  파일 참조 wordcloud.txt
# =============================================================================

#설치한 library 목록을 보여줌 
pip.exe list 

#공학쪽 library: scipy 
- scipy 확인하기 


from wordcloud import WordCloud, STOPWORDS
import matplotlib.pyplot as plt

#UTF-8이 오류가 나서 ANSI 표준으로 바꿔 불러왔음 
with open("c:/data/moon.txt","r") as file:
	text = file.read()



from scipy.misc import imread

heart_mask = imread("c:/data/heart.jpg")

#공백 줄바꿈을 기준으로 Wordcloud를 만듦 
wordcloud = WordCloud(font_path = "c://Windows//Fonts//malgunbd.ttf", 
		stopwords=STOPWORDS,              #불용어 내부적으로 내장되어 있음; option; 
		background_color="white",
		width=1000,
		height=800,
		mask=heart_mask).generate(text)  #mask라는 변수에 heart_mask를 지정 

plt.figure(figsize=(10,10))
plt.imshow(wordcloud)
plt.axis("off")
plt.show()


# =============================================================================
# wordcloud2 - imageio.imread 로 이용하기
# =============================================================================
pip.exe list


from wordcloud import WordCloud, STOPWORDS
import matplotlib.pyplot as plt

with open("c:/data/moon.txt","r") as file:
	text = file.read()


## from scipy.misc import imread 

## heart_mask = imread("c:/data/heart.jpg") # deprecated

import imageio

heart_mask = imageio.imread("c:/data/heart.jpg")


wordcloud = WordCloud(font_path = "c://Windows//Fonts//malgunbd.ttf", 
		stopwords=STOPWORDS,
		background_color="white",
		width=1000,
		height=800,
		mask=heart_mask).generate(text)

plt.figure(figsize=(10,10))
plt.imshow(wordcloud)
plt.axis("off")
plt.show()

# =============================================================================
# 웹페이지의 이미지를 컴퓨터에 저장
# =============================================================================

■ 웹페이지의 이미지를 컴퓨터에 저장

한겨례신문 - 더보기 - 만화 - 메인의 10월 2일 한겨레 그림판의 그림 긁어오기

from bs4 import BeautifulSoup
import urllib.request as req

url = "http://www.hani.co.kr/arti/cartoon/home01.html"
res = req.urlopen(url)
soup = BeautifulSoup(res, "html.parser")

lnk=soup.select_one('div.today-comic > a > img').get('src')

print(lnk)
http://img.hani.co.kr/imgdb/resize/2018/1001/53_1538392461_00503455_20181001.JPG


from urllib import request

request.urlretrieve(lnk,'c:/data/20181002.jpg')            #lnk위치의 파일을 c:/data에 20181002.jpg로 저장

Out[14]: ('c:/data/20181002.jpg', <http.client.HTTPMessage at 0x9de5b00>)



# -*- coding: utf-8 -*-
"""
Created on Thu Oct  4 09:51:04 2018

@author: stu
"""


# =============================================================================
# [문제186] http://www.skwyverns.com/Wyverns/Players/picther/picther_list.asp
이미지를 다운로드하세요.
# =============================================================================
#img가 full address로 안 보일 경우 

from bs4 import BeautifulSoup
import urllib.request as req

params = []
url = "http://www.skwyverns.com/Wyverns/Players/picther/picther_list.asp"
res = req.urlopen(url).read()
soup = BeautifulSoup(res, 'html.parser')
#전체 가져옴
lnk = soup.select('div.sell > div.sum > a > img')

#실제 물리적인 주소를 만드는 방법
for i in lnk:
    params.append('http://www.skwyverns.com' + i['src'])

type(params)

#파일 저장 
for p in params:
    splitStr = p.split('/')
    name = splitStr[len(splitStr)-1]
    fullPath = 'c:/sk_picther/' + name
    req.urlretrieve(p, fullPath)


#사용처에 대해 고민해보기 
select vs. select_one
find vs. find_all
###############################################################################

#성복이꺼 
    

from bs4 import BeautifulSoup
import urllib.request as req
from urllib import request

url = "http://www.skwyverns.com/Wyverns/Players/picther/picther_list.asp"
res = req.urlopen(url)
res

## 이미
head ='http://www.skwyverns.com'

soup = BeautifulSoup(res,'html.parser')

img=soup.select_one('#content > div > div.entrie_list > div.list_group')
                    
img = img.select('.sell > .sum > a > img')
img

cn=0
cn
name=''
for i in img:
    cn+=1
    print(i.attrs['src'])
    print(i.attrs['alt'])
    
    img_url=head+i.attrs['src']
    name=i.attrs['alt']
    
    request.urlretrieve(img_url,"c:/data/"+name+".jpg")
    

#아루미꺼
from bs4 import BeautifulSoup
import urllib.request as req

url = "http://www.skwyverns.com/Wyverns/Players/picther/picther_list.asp"
res = req.urlopen(url)
soup = BeautifulSoup(res, "html.parser")

src=[]
name=[]

for i in soup.select('div.sell > div.sum > a > img'):
    src.append('http://www.skwyverns.com'+i.get('src'))
    name.append(i.get('alt'))


from urllib import request

for i in range(len(src)):
    request.urlretrieve(src[i],'c:/data/skwyverns_{}.jpg'.format(name[i]))
    

# =============================================================================
# 오전수업
# =============================================================================
▣ selenium
- 웹브라우저를 컨트롤하여 웹 UI(User Interface)를 자동화하는 도구
- dynamic한 웹페이지를 웹크롤링하기 위한 도구 (user id/ user pw를 필요로 하는 경우)

■ selenium client 설치
pip install selenium

■ selenium driver를 설치 (control할 수 있는 driver)
firefox driver: https://github.com/mozilla/geckodriver/releases
chrome driver: https://sites.google.com/a/chromium.org/chromedriver/downloads
panthomsJS: http://phantomjs.org


■ 사용 
from selenium import webdriver
url = 'http://www.naver.com'

#phantomJS가 웹브라우저를 제어함
driver = webdriver.PhantomJS('c:/data/phantomjs.exe')
#3초동안 대기
driver.implicitly_wait(3)
driver.get(url)
#스크린샷 저장
driver.save_screenshot('c:/data/naver.png')
#나가기
driver.quit()


##login하여 쇼핑-장부구니같은 내용을 스크롤링하고 싶을 경우 

#step1 login을 하는 페이지를 첫페이지로 간다    
https://nid.naver.com/nidlogin.login

# 숨어서 로그인하게, -> 클릭이 필요함: 이를 짜야함 


# =============================================================================
# 오후 수업
# =============================================================================

from selenium import webdriver
from bs4 import BeautifulSoup

#입력창에 id와 pw넣기
user = "kimhj139"
mypass = "wmfrjdnsgkfn"

#driver
driver= webdriver.PhantomJS("c:/data/phantomjs.exe")
driver.implicitly_wait(3)
#접속해야 될 사이트에 접속하기
url_login = 'http://nid.naver.com/nidlogin.login'
driver.get(url_login)
# id를 입력하는  input 요소를 찾는다. 
# find_element_by_id(id): id속성으로 요소를 하나 추출한다.
inputid = driver.find_element_by_id("id")
#입력박스에 있는 텍스트 지우기; (이전에 혹시 inputid값이 있다면 지워주기)
inputid.clear()
#send_keys: 입력박스에 아이디 입력
inputid.send_keys(user)
#비밀번호 입력하는 input 요소를 찾는다.
inputpw = driver.find_element_by_id("pw")
#기존 input값에 pw가 있는 경우 지우기
inputid.clear()
#
inputpw.send_keys(mypass)

#로그인하기- 요소 선택을 통해서 로그인 부분을 찾기
<input type="submit" title="로그인" alt="로그인" value="로그인" class="btn_global" onclick="nclks('log.login',this,event)">
# find_element_by_css_selector(""): css선택자로 요소 하나 추출  (#class는 input.btn_global로 찾고, type에 submit을 넣어주기, 속성은 꼭 써줄 필요는 없으나 어떤 페이지에서는 class이름이 동일할 경우 type을 찾아 써줘야한다.)
loginbn = driver.find_element_by_css_selector("input.btn_global[type=submit]")

#로그인 버튼 클릭 하기: 아이디와 비밀번호 전송
loginbn.submit()



#예시- 네이버 페이> 쇼핑 > 디지털/가전 
#주소
driver.get("https://pay.naver.com/introduction/merchant/list?searchMerchantCategoryCode=50000003&searchTapType=merchant&searchSortType=payOrderCount&searchType=merchantName&searchKeyword=")
# 페이지의 element를 모두 가지고 옮
html = driver.page_source
#BeautifulSoup가 내용을 가져오지 못하기 때문에 panthomJS가 가져오는 역할을 한다.
soup = BeautifulSoup(html, "html.parser")
#태그 안에서 원하는 부분만 추출하기 
notice = soup.find_all('table', class_="tb_list tb_store")

for n in notice:
    print(n.text)
    
driver.quit()


#예시 - 쇼핑목록 가져오기
from selenium import webdriver
from bs4 import BeautifulSoup

#입력창에 id와 pw넣기
user = "kimhj139"
mypass = "wmfrjdnsgkfn"

#driver
driver= webdriver.PhantomJS("c:/data/phantomjs.exe")
driver.implicitly_wait(3)
#접속해야 될 사이트에 접속하기
url_login = 'http://nid.naver.com/nidlogin.login'
driver.get(url_login)
# id를 입력하는  input 요소를 찾는다. 
# find_element_by_id(id): id속성으로 요소를 하나 추출한다.
inputid = driver.find_element_by_id("id")
#입력박스에 있는 텍스트 지우기; (이전에 혹시 inputid값이 있다면 지워주기)
inputid.clear()
#send_keys: 입력박스에 아이디 입력
inputid.send_keys(user)
#비밀번호 입력하는 input 요소를 찾는다.
inputpw = driver.find_element_by_id("pw")
#기존 input값에 pw가 있는 경우 지우기
inputid.clear()
#
inputpw.send_keys(mypass)

#로그인하기- 요소 선택을 통해서 로그인 부분을 찾기
<input type="submit" title="로그인" alt="로그인" value="로그인" class="btn_global" onclick="nclks('log.login',this,event)">
# find_element_by_css_selector(""): css선택자로 요소 하나 추출  (#class는 input.btn_global로 찾고, type에 submit을 넣어주기, 속성은 꼭 써줄 필요는 없으나 어떤 페이지에서는 class이름이 동일할 경우 type을 찾아 써줘야한다.)
loginbn = driver.find_element_by_css_selector("input.btn_global[type=submit]")

#로그인 버튼 클릭 하기: 아이디와 비밀번호 전송
loginbn.submit()


#주소
driver.get("https://order.pay.naver.com/home")

# 페이지의 element를 모두 가지고 옮
html = driver.page_source

#BeautifulSoup가 내용을 가져오지 못하기 때문에 panthomJS가 가져오는 역할을 한다.
soup = BeautifulSoup(html, "html.parser")
#태그 안에서 원하는 부분만 추출하기 
notice = soup.find_all 
('#_rowLi20181002104236CHK2018100275436881 > div.p_inr')                
notice

                     
for n in notice:
    print(n.text)
    
driver.quit()

#_listContentArea > div:nth-child(2)

# =============================================================================
# chrome driver
# =============================================================================

from selenium import webdriver
from bs4 import BeautifulSoup

#입력창에 id와 pw넣기
user = "kimhj139"
mypass = "wmfrjdnsgkfn"

#driver
#driver= webdriver.PhantomJS("c:/data/phantomjs.exe")
driver = webdriver.Chrome("c:/data/chromedriver.exe")
driver.implicitly_wait(3)
#접속해야 될 사이트에 접속하기
url_login = 'http://nid.naver.com/nidlogin.login'
driver.get(url_login)
# id를 입력하는  input 요소를 찾는다. 
# find_element_by_id(id): id속성으로 요소를 하나 추출한다.
inputid = driver.find_element_by_id("id")
#입력박스에 있는 텍스트 지우기; (이전에 혹시 inputid값이 있다면 지워주기)
inputid.clear()
#send_keys: 입력박스에 아이디 입력
inputid.send_keys(user)
#비밀번호 입력하는 input 요소를 찾는다.
inputpw = driver.find_element_by_id("pw")
#기존 input값에 pw가 있는 경우 지우기
inputid.clear()
#
inputpw.send_keys(mypass)

#로그인하기- 요소 선택을 통해서 로그인 부분을 찾기
#<input type="submit" title="로그인" alt="로그인" value="로그인" class="btn_global" onclick="nclks('log.login',this,event)">
# find_element_by_css_selector(""): css선택자로 요소 하나 추출  (#class는 input.btn_global로 찾고, type에 submit을 넣어주기, 속성은 꼭 써줄 필요는 없으나 어떤 페이지에서는 class이름이 동일할 경우 type을 찾아 써줘야한다.)
loginbn = driver.find_element_by_css_selector("input.btn_global[type=submit]")



#로그인 버튼 클릭 하기: 아이디와 비밀번호 전송
loginbn.submit()



#예시- 네이버 페이> 쇼핑 > 디지털/가전 
#주소
driver.get("https://pay.naver.com/introduction/merchant/list?searchMerchantCategoryCode=50000003&searchTapType=merchant&searchSortType=payOrderCount&searchType=merchantName&searchKeyword=")
# 페이지의 element를 모두 가지고 옮
html = driver.page_source
#BeautifulSoup가 내용을 가져오지 못하기 때문에 panthomJS가 가져오는 역할을 한다.
soup = BeautifulSoup(html, "html.parser")
#태그 안에서 원하는 부분만 추출하기 
notice = soup.find_all('table', class_="tb_list tb_store")

for n in notice:
    print(n.text)
    
driver.quit()

# =============================================================================
# 다음 로그인 - 웹크롤러
# =============================================================================
from selenium import webdriver
from bs4 import BeautifulSoup

#입력창에 id와 pw넣기
user = "kimhj139"
mypass = "cnfqkf!7"

#driver
#driver= webdriver.PhantomJS("c:/data/phantomjs.exe")
driver = webdriver.Chrome("c:/data/chromedriver.exe")
driver.implicitly_wait(3)
#접속해야 될 사이트에 접속하기
url_login = 'https://logins.daum.net/accounts/loginform.do?url=https%3A%2F%2Fmember.daum.net%2Ffind%2Fid.do%3Faction%3Dhome'
driver.get(url_login)
# id를 입력하는  input 요소를 찾는다. 
# find_element_by_id(id): id속성으로 요소를 하나 추출한다.
inputid = driver.find_element_by_id("id")
#입력박스에 있는 텍스트 지우기; (이전에 혹시 inputid값이 있다면 지워주기)
inputid.clear()
#send_keys: 입력박스에 아이디 입력
inputid.send_keys(user)
#비밀번호 입력하는 input 요소를 찾는다.
inputpw = driver.find_element_by_id("pw")
#기존 input값에 pw가 있는 경우 지우기
inputpw.clear()
#
inputpw.send_keys(mypass)

#로그인하기- 요소 선택을 통해서 로그인 부분을 찾기
#<input type="submit" title="로그인" alt="로그인" value="로그인" class="btn_global" onclick="nclks('log.login',this,event)">
# find_element_by_css_selector(""): css선택자로 요소 하나 추출  (#class는 input.btn_global로 찾고, type에 submit을 넣어주기, 속성은 꼭 써줄 필요는 없으나 어떤 페이지에서는 class이름이 동일할 경우 type을 찾아 써줘야한다.)
loginbn = driver.find_element_by_css_selector("button.loginBtn[type=submit]")
# button
<button id="loginBtn" type="submit" class="btn_comm" onclick="_tiq.push(['__trackEvent', 'loginform_pc', 'login_daum']);">로그인</button>
#로그인 버튼 클릭 하기: 아이디와 비밀번호 전송
loginbn.submit()



#예시- 네이버 페이> 쇼핑 > 디지털/가전 
#주소
driver.get("https://pay.naver.com/introduction/merchant/list?searchMerchantCategoryCode=50000003&searchTapType=merchant&searchSortType=payOrderCount&searchType=merchantName&searchKeyword=")
# 페이지의 element를 모두 가지고 옮
html = driver.page_source
#BeautifulSoup가 내용을 가져오지 못하기 때문에 panthomJS가 가져오는 역할을 한다.
soup = BeautifulSoup(html, "html.parser")
#태그 안에서 원하는 부분만 추출하기 
notice = soup.find_all('table', class_="tb_list tb_store")

for n in notice:
    print(n.text)
    
driver.quit()

###############################################################################
# naver
<input type="submit" title="로그인" alt="로그인" value="로그인" class="btn_global" onclick="nclks('log.login',this,event)">
#태그 안에서 원하는 부분만 추출하기 
notice = soup.find_all('table', class_="tb_list tb_store")
###############################################################################


# =============================================================================
# 이미지 검색만 하기
# =============================================================================

#기본적인 step#################################################################
# 네이버> 검색 > 이미지
# 이미지 검색창을 알아야 함 
https://search.naver.com/search.naver?where=image&sm=tab_jum&query=


# 입력창 태그보기
# <input type="text" id="nx_query" name="query" class="box_window" maxlength="255" accesskey="s" value="" autocomplete="off" title="검색어 입력">

# img url
#<img src="https://search.pstatic.net/common/?src=http%3A%2F%2Fpost.phinf.naver.net%2FMjAxNzEyMDdfMjIy%2FMDAxNTEyNjQ0NDEyODAy.tWSXo2z5dNjQe_VMhffKFR7dwxrR4u7YypsOi7VYNrwg.c5EgFgAEWov-QJhwRRVXjPd_uvZHGCbQQtqrBNw2-b8g.JPEG%2FIJhr12cKveg86zwOBerfBe69yccY.jpg&amp;type=b400" class="_img" alt="아이언맨 슈트 총정리-마크1부터 48까지  | 포스트" onerror="var we=$Element(this); we.addClass('bg_nimg'); we.attr('alt','이미지준비중'); we.attr('src','data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7');" data-width="526" data-height="969" style="height: 150.654px; width: 81.7792px; left: 0px; top: 0px; zoom: 1; opacity: 1;">

#검색된 이미지를 더 많이 보기 위해서는 end key나, scroll bar를 내리거나, 밑의 화살키를 누르거나 하는 작업을 반복해서 해야 함 

import urllib.request as req
from bs4 import BeautifulSoup
from selenium import webdriver
#end key를 제어하는 모듈 
from selenium.webdriver.common.keys import Keys
import time

browser = webdriver.Chrome("c:/data/chromedriver.exe")

#이미지 검색해야할 창 
browser.get("https://search.naver.com/search.naver?where=image&sm=tab_jum&query=")
#id 속성으로 입력창 값을 찾음 # 입력창 태그보기
# <input type="text" id="nx_query" name="query" class="box_window" maxlength="255" accesskey="s" value="" autocomplete="off" title="검색어 입력">
elem = browser.find_element_by_id("nx_query")
#검색어 검색창에 검색어 넣기,+ 검색하기
elem.send_keys("아이언맨")
elem.submit()
#html tag 분석
brower.find_element_by....
#웹페이지에 있는 정보를 다 가져오기  => body만 가져온 다음 -> 이미지만 세세하게 들어

#body 태그 안에 있는 것을 기준으로 end 키를 내부적으로 돌리겠다.
browser.find_element_by_tag_name("body").send_keys(Keys.END)
#
time.sleep(5)
#end키를 한번 만 돌릴 경우 이미지를 다 볼 수 없기 때문에 반복문을 생성한다.
for i in range(1,2):
    browser.find_element_by_tag_name("body").send_keys(Keys.END)
    

# END키를 누르면 계속해서 tag가 바뀌게 됨

html = browser.page_source    
soup = BeautifulSoup(html, "html.parser")

#img를 찾아야 함
# <img src="https://search.pstatic.net/common/?src=http%3A%2F%2Fpost.phinf.naver.net%2FMjAxNzEyMDdfMjIy%2FMDAxNTEyNjQ0NDEyODAy.tWSXo2z5dNjQe_VMhffKFR7dwxrR4u7YypsOi7VYNrwg.c5EgFgAEWov-QJhwRRVXjPd_uvZHGCbQQtqrBNw2-b8g.JPEG%2FIJhr12cKveg86zwOBerfBe69yccY.jpg&amp;type=b400" class="_img" alt="아이언맨 슈트 총정리-마크1부터 48까지  | 포스트" onerror="var we=$Element(this); we.addClass('bg_nimg'); we.attr('alt','이미지준비중'); we.attr('src','data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7');" data-width="526" data-height="969" style="height: 196.568px; width: 106.702px; left: 0px; top: 0px; zoom: 1; opacity: 1;">

params = []

imglist = soup.find_all("img", class_="_img")

for im in imglist:
    params.append(im['src'])
    
params

a = 1
for p in params:
    req.urlretrieve(p, "c:/data/pictest/"+str(a)+".jpg")
    a += 1 
    
browser.quit()

###############################################################################
#스크롤 되다가 끊어지는 모양으로 나오게 될 경우 range값을 조정해본다. 
import urllib.request as req
from bs4 import BeautifulSoup
from selenium import webdriver
#end key를 제어하는 모듈 
from selenium.webdriver.common.keys import Keys
import time

browser = webdriver.Chrome("c:/data/chromedriver.exe")

#이미지 검색해야할 창 
browser.get("https://search.naver.com/search.naver?where=image&sm=tab_jum&query=")
#id 속성으로 입력창 값을 찾음 # 입력창 태그보기
# <input type="text" id="nx_query" name="query" class="box_window" maxlength="255" accesskey="s" value="" autocomplete="off" title="검색어 입력">
elem = browser.find_element_by_id("nx_query")
#검색어 검색창에 검색어 넣기,+ 검색하기
elem.send_keys("아이언맨")
elem.submit()

#body 태그 안에 있는 것을 기준으로 end 키를 내부적으로 돌리겠다.
browser.find_element_by_tag_name("body").send_keys(Keys.END)
#
time.sleep(5)

#time.sleep을 늘려서 모든 태그 주소값 가져와보기
for i in range(1,2):
    time.sleep(40)
    browser.find_element_by_tag_name("body").send_keys(Keys.END)
    time.sleep(40)
    
html = browser.page_source    
soup = BeautifulSoup(html, "html.parser")


params = []

imglist = soup.find_all("img", class_="_img")

for im in imglist:
    params.append(im['src'])
    

a = 1
for p in params:
    req.urlretrieve(p, "c:/data/pictest/"+str(a)+".jpg")
    a += 1 
    
    
browser.quit()

# =============================================================================
# google 이미지 웹크롤링
# =============================================================================
import urllib.request as req
from bs4 import BeautifulSoup
from selenium import webdriver
#end key를 제어하는 모듈 
from selenium.webdriver.common.keys import Keys
import time

browser = webdriver.Chrome("c:/data/chromedriver.exe")

browser.get("https://www.google.co.kr/imghp?hl=ko&tab=wi")

#id 속성으로 입력창 값을 찾음 # 입력창 태그보기
# naver: <input type="text" id="nx_query" name="query" class="box_window" maxlength="255" accesskey="s" value="" autocomplete="off" title="검색어 입력">
# google: <input class="gsfi" id="lst-ib" maxlength="2048" name="q" autocomplete="off" title="검색" type="text" value="" aria-label="검색" aria-haspopup="false" role="combobox" aria-autocomplete="list" dir="ltr" spellcheck="false" style="border: none; padding: 0px; margin: 0px; height: auto; width: 100%; background: url(&quot;data:image/gif;base64,R0lGODlhAQABAID/AMDAwAAAACH5BAEAAAAALAAAAAABAAEAAAICRAEAOw%3D%3D&quot;) transparent; position: absolute; z-index: 6; left: 0px; outline: none;">
elem = browser.find_element_by_id("lst-ib")
#검색어 검색창에 검색어 넣기,+ 검색하기
elem.send_keys("아이언맨")
elem.submit()



#body 태그 안에 있는 것을 기준으로 end 키를 내부적으로 돌리겠다.
browser.find_element_by_tag_name("body").send_keys(Keys.END)

#
time.sleep(5)

#time.sleep을 늘려서 모든 태그 주소값 가져와보기
for i in range(1,2):
    time.sleep(5)
    browser.find_element_by_tag_name("body").send_keys(Keys.END)
    time.sleep(5)
    
html = browser.page_source    
soup = BeautifulSoup(html, "html.parser")


params = []

# naver: <img src="https://search.pstatic.net/common/?src=http%3A%2F%2Fpost.phinf.naver.net%2FMjAxNzEyMDdfMjIx%2FMDAxNTEyNjQ0NDE1NzE2.OPs8ezLyVGnCYm__ukqwZWmNvFTdpQKcKaVK6KeXJF4g.2NIe1RpaB-yuEshhbdJ75iqWaaWsDntQe-uXONbJfcog.JPEG%2FIQDWQKddg_ynSbDTKmWU42inVob8.jpg&amp;type=b400" class="_img" alt="아이언맨 슈트 총정리-마크1부터 48까지  | 포스트" onerror="var we=$Element(this); we.addClass('bg_nimg'); we.attr('alt','이미지준비중'); we.attr('src','data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7');" data-width="271" data-height="499" style="height: 177.154px; width: 96.2097px; left: 0px; top: 0px; zoom: 1; opacity: 1;">
#naver-  class="_img" 
# <img class="rg_ic rg_i" id="eYn1yvL47yOQmM:" jsaction="load:str.tbn" alt="아이언맨에 대한 이미지 검색결과" onload="typeof google==='object'&amp;&amp;google.aft&amp;&amp;google.aft(this)" src="data:image/jpeg;base64,/9j/4AAQSkZJRgABAQAAAQABAAD/2wCEAAkGBxMTEhUTExMWFhUXFx4aFxgYGB0YGhcXGhcYHRgYGhoYHiggGxolGxgYITEhJSkrLi4uFx8zODMtNygtLisBCgoKDg0OGxAQGy0lHyYtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLf/AABEIAKgBLAMBIgACEQEDEQH/xAAcAAACAwEBAQEAAAAAAAAAAAAFBgMEBwIAAQj/xABIEAABAwIDBQUDCQYEBAcBAAABAgMRACEEEjEFBkFRYRMicYGRMqGxByNCUmLB0eHwFDNygpKyJKLS8RU0Q2MlVHSEo7PjU//EABoBAAMBAQEBAAAAAAAAAAAAAAIDBAEFAAb/xAArEQACAgIDAAEDAwMFAAAAAAAAAQIDESEEEjFBIjJRE2FxBYGhFCNCsfD/2gAMAwEAAhEDEQA/ACOLxpDqrLPhPIV5nHnMkZXPaHxrh/EkOLhBPePH8q7wz6i4gdmRK08eorcGGgbyrIwD5m+Q38TFZvi8W6HYShxQyouCY9kVou9hjZ7v8I9601n+Iz9ocqARbVQH0R1oY+BP06dx78fu3PU0/bAcV+ytkyDl4m4uaz/54/QT/UPxrQdig/szU65RNZPw2IWx5hlw/YP9prHtvvqIdEn2Rx5g1r+1P3Ln8B+BrG9sm7/gn+002oVZ4QMOK7eJMdhIv0SDVxuRlAJkNmPfVQI+dXwP7PAPLSrODVZs8exn3U7JO0Ud61/+GjNJ76NJ68qDbnrGUxmjIYF51M630k+Qpg3nR/gB/GjrwNC91MG8G1LykJKT38pCZzGIOmsT0mih6emnjQaxJ7i4SfZOp+wIPiRbxpK3CUYdudU/A05Y0DKu5Jyq9cgnyOopN+T9Mh7xT8DTZfchUftYxOuHNqfaHwrnZ7p7RFzqnj9qvPHvEfa+6udnDvo/l+NB8mo2B5SuZ9TVFx1XM+tE30VScbrUG0UjiVcz61IxiVHifWultV9wrInWK1+Hop5CmGUeJPrV1CTzPrUTTU6XqcAipJPZZGOCJzNzPrXAdVzPrUji6iUmsRp9L55n1qM4hXM+tcKTUPZqmiUQclkYk8z618U6frH1qIt14gkQK9g8Q4h1XBR9agxxX2K7mbceRFW2MGQb1LjWu4ayUtYNSM227iF9obm88etCMcrIgCfGmfedKUHNF6Q9pYjNYXoYgy0DcW6edVUmTrVtxiReoWQmb0wVktYYDKq561z+0AcTUuHKSlyOV6pOZeBNePbZcYxRmxNaDu8c+GbM6Ag/1q/GsxwyoVWm7lAHDDotQ+B++gmMgQrdX2i4QCMx49fGrWBUsutylPtp4/aHWhinXe0VGX2jw6+FEtlFwvNSUxnGg6+FLCQ774KjZ7ngj/7E0iu9p2ioKYm0+FO2/B/8PPUt/wB6aRXGXS4shxIBVaRw9K9FaNfp2pD31ke+tD2Sn/DtTrkE+lZx2Ds/vU+n5VpWzUwy0PsJ+AoZhR9Lu2P3Dn8B+FY1tY3xHl/ZWx7bMYd0/YPwrDMViVuBwhEBwgiVpsAmIqiiLecCbmEP+ovozHvFSMwFN/8ApzPlH40Ib2vmS+8EHKkIbUCbysqiOnzZqBveVKSD2ajDeTUdL+6nuqXwJUo+Mtb3bYxLKG2222w2QlSXCkOLzBN/blKSJMQmY40nO7YxZVnViH83PtV+gvYdNK0nFFl5hsOkoQWCsGAQlScsE9OFvrVme0XEBen6HlXNnY+7R24caKqU0wxsbeTFOKKFqS4gjvlcJISBeFpykqjQGZohuJgw2vFt/UdyieIBUAfMXpWwm0EpcQRmSAoE5SrQHXheJ/KmfY20inEqyozftTqezJMAJUrIiddNDxlJqnjuU3gg5dajFPAQxI+cV/H91cbOT3kHQWPvoHj95Mq1fN3Cj9LiLcqm2RtltxIU6mEJUgLANymTNOtbrjkXwqI3Tw/DdlOpWMyFJUnmkgj1FV1ml/cfFYdx539mBCOzEzbvZtQDpTLjFoQJWQPifAC5r1VvaCk9B8jiuFvSGyoomusGoBUmoXcegCciz5R8TXGD2lh1qglSVciKJ2w8yD/or19XUZGHUg1ZkK0oSpm0pMjpU+DWQb0lxXqNy08MndYIqMVaU8CK803QmkKWppE3m+U3C4Vam0NreUm2YEIbniM1yY/hon8pe8Qw2GWhtYStXdKuKZBJCZI72UGvz5iMYFiCqBJITciSBxkxefWglZ+B8KVjMh5x/wAsmKUe40y2P5ln1JA91MO6PynpxDiGXWVJcWQElvvpJ6p9pI63ArJtk7NW+4G2k51GYGgjiSSmAB41qO7O7yMGiRCniO8sWgfVTHD41tbbZ6yMYo1NDwmCRPKuMe5KaQO1UVe0Z8TTHg1HJcmitjhCIsWt7UlVudAP+BZBmOp4Uz7WV3geRqpjViJnhSYywZJCe9h5tGlD1sQTIpmU0SDbzoFi1wYIqhPIlorYfL3wOIvVRzJwmiWCYzExyqPHYVLZhSb1jkk8BRjrILFaV8nuKSMMoGf3p/tRWamnPcvHJQwoGf3hP+VFBZ4MqWy0ntCpULAueA50U2IHO3bzLkZhaAKA4TDulRhxYv1ph2Bg3BiGyVqUJ0MxoetCzUOG/wAr/ADqtof5hWeraWXV/OkDMeE8T1rQvlB/5NA5vNj3n8Kzs4KXFHtFi508fGth4Y/Sy1gVkKUXyEp9pRTYToNZJPIXp9wePd7NsIw6yAlIClqSiYAvEk1n72Fn5vOuECZ4lahJJvwGUVqeDR3Gx0SPcKGbCiD9uYzF9g7mw7YTkMkOyQP6awE4l2CUqcypiSCqEgmEzFhOgr9I7yD/AArw+wR61hmFxeIw2GxDASyUrVlKlCVJNpy2vbSdDcVVxpJJk968KOD/AOSxJ5vsf2vmhRaOUKIOUkgKixIEkTpIBFutGmMG4GX8PCZztulWY6JS4mAMt5z+6rrruJXhkYKGQlKe0zgd9Se7CSY1EC4ucoB0vX+pH8kvVsjxjbrmEZSltaylrRsKVKbZVLhPduBafhSfjWV8cOoEak56dNvYZ1GCbUlUZUIuknNmSQQRF+JM8IpUxW0HCg5lrUVHVTijw4SdCSbHlXIuf1vB3ePh1LswOlRkANif57/5vhT3sNkBOCzMqS5+1IJJKhlCnQBCVD2VZCdeA50uYXH9m0pUypRCUqzKBbH1gnLNzbwFqYN08Y2ltpa1xCiUhUhMoebWk2Exm7pV1IrabOk02jLqVKuSUhaxeHU46tKUlSlOKASBJJzGwAqBOHcZbcC0FIJQqFSFQSYjob00t7FdbeDqVIzJczAEEideEGrO12sRjVlTnZlxQQAEJKRCVGNSbyTXRtxJYORTKUHoLfJG68tTpZyJhAzdoCe7PCONals3ZxcKcQSFZgDChMJPAXgRaLGYPOyfudu69gG8Q7iAlGdAbSJF1KNtPGn7d9ycO3H1Y9CRUFzSSR0Izn1cvkR948b2a1hViCbUlYN5eKfKRORHfcUkwcvBIPBSjAHmeFaPv1u+jEEKDpaVoYSFBUdDF6C7K2OjDtBLas8qlxZF1E20GgFgB48zXP74Z25cuL46jFb+TndHaOIS584qGswTElXtTEFRKpBA4x0FPLoM1lm9eMLaUBNj2gV/Tp8a1XCvB1tDiTIWkH1FX8WfZPJyOVDCTO8Omh+9e3v2RoZQFOrnKCYAA1Wo/RQJEqOniQKv4t9LLS3V6IE+J4AdSYA8axT5Q8Up5JcOLblWUuNJ7xUklWRCDPsDKbczJ1FHdJLRnHr7fU/ELW/W1u3cbUtxSwW8ySEgAkrWFLylVsxTbjlSgHSlZtts6lfXuC3+a9NW1cetCm2FFCkobGcZEq7xur2kzmzE36igOMCUrUEwQDYwBI4WEVMpFsqsvOg1uThCcWyGHcqpnvJKQUj2k6mZTNq1vFIg6j1rHd3ce6H2g17RWALSYJuBMjSeFaxjnCdWVep4pPTyqmlkvIilgrqXfUeopmwRlseFKeGwIUq7Kh4k/V/Qp7w2GCGhaLfdRXPRNFCrthBkCPGqzjPS1GdokaxS7tHaRBiIip0z0kd7QxACYA4UqY5Oa8UytvJhWcX4UDL2cmnQYqRUwrmRU8DXzazoInW1fHm1AxFQ4xPdE60eEwc40CFKovsR4JQQfrfcKo/s461yiRIHOvSWhlbwxk2e0lX/AFVj+Yf6qad2W09uiHFK11UDwPCaUti7CWqSWVnyP3U17u7JUy8lRaUkAG5B5HnSm9BRHL5RTGHZHPEN/BVZwMChThOZy5NgrmfCtD+Uk/M4cf8AfT/aqkFjd1alZuyWfWvR8PP05dwaVLWSV2JFlRZNhw6VreGUAGx4VmOE3eU4kuhtapUqCAeCjWks+0gdRQTYUUWN4v8AlnPD7xWHbZblDp5O/gK3DeY/4Zzy/uFYZtpRyLjQvGfUffTaxVnhMo5l4kcmx7lKNdZpXHEYf/Sa4xB72Jya9mmY5yqa8pfeMa/s4n/L91NFpYCmNUkN4bPp2yBoYEp1McBQPa27qmyOzQsAG8tuKAibyoERfnajr29OCZCW3mXUqSUrSpSO0Bj2VJyuJt4jWaAq2rswyoLUCZ/6Cp96zfzqWxvOkdbiQrcWpyX+QZidirUnupURM5ikgmYmEkcDOlAt5cWlLwQgyG20IkaZgkFUA6QokGbyDTY5t3BEKlDzgNjYIBnncmaWt7cD85+1pENYghSbyQ4U/OA/zhdDF59MuhGP2vI84LG9s2h2IzgKI6lN/fVjZDsPIP8AD/dVPdkp/YmO8AYNoMmFLHG3IedWtm2dR4j+6rapqSwcixdZmnb8tlacOgaKxABPKWnQk/1RQ3dfeVgsdmtwIdRPdWcsiSRBNpvEaiKYt4WUqauLhQynksylB/qUB51T2PsthxguKabPa/OEZQe8UgEgjnE+JNSXRi/XguhJKH9wUX+1XEyOlxHSKrYgBCwFEBI1kwB61TXu/hlYnIEnKZ0URz619w+xsI0pRWznjQKJMX5g/HlXNUIOWOxXl4ykI3yjYxDzrKWVZgD3iNJkHzACTfrWo/JiT/w7Dz9qPDtFRWd77IaDheQ2hCCgJSlAgWFz4391apuxhgxgWAshIQ0kqm0EjMqfMmurRCMY/S8iOR2cVlYyKXyxb1pYQMKgAuKGZROiEkEJMcVakcoB4CsGceKiEp8B0FMnyh7cTica86kykqhJmQUpASCDyMSPGgGzgblINzHu5caCx/IytNJRQbxezZYw7gAK4UlZEd6CMhA/gIk8TPU1SRspR/6Z9Pzp7d2cWcC22AO0WpMmwKUQXHCpR9lAUEyZjQ0Hw7GzlCHMYO1zGSWVZI5BWQzee8QLRap85Oh1jHEWybcHAJaeU4tsyEwgkRlJMEi54ceHnTJjNusqcDUOZjx4aHrQ3dhWGw61FOMw8KEHvpToTBjKk/71Ydw+CLudOMbU5mkBJCyTwEJBN+lVVTSIOVTLOU1j+SXZu8GFQvvOqERMg2gRTLit+sCW4TiEz1CvwrIdousB1ye0JzHMQRBveAUzVNT+F+q7/UP9NUyrjI5ym0ac1vMy4Q2hwKUZgAHx5UC27jkNmVpUb8PzoFuuW1YtoNJXnJITmUI9k6wKYN9mOzKe2SLj6Kup4EUhwSeEb2bWT5tTEpQyh1RKQsApm8yJi3ShOB240g94x5HjXts4pKsM0FpJQIygKg6GJkRpS24+xxbX/WPwpsIrAD9HF3eTDk2Vpr3T+FCsXtBLqpR7PC0UBD7F4bXp9fh6VcwbzeUZUGOqposIzbL7YEidKuowIj2kjxP4VQYxKQoEokDgVGPdB99XHFIVBnhwMT5QYPnSLcpaNianuxnA0PpTI8y4oaG/Ssl2V8pC24AYBj7Z/Cj6flfc/wDKJ/rP+mlut5GxsWB43z2c48lgNpKsruZURYZTe9T4DCuIkkEW50iD5WnjphE/1q/019HypYlRCf2RIBMEyowDYmtafhqkO26bav2NrW4J9VKNX04Y50mONZbgvlAxrDaWW8K2pKBAUc1xzsaO7p784zE4ptl5htCVTJAM2STaVdKxxN7DfvaYwrn8v9wrDtrqKG1JUPbekHpmSa1vfXaSS0ptKxMCUxcd4GdelZ9i8AlwdmUkxeR9FSb1sbIrQE1lAd5eRWLIv3U+8qqPFrhayP8Ay6fuFefaWgYxTgMKSnLy1X8LV8eaParkEgsoBi8AwD8D6U7skKwFNqbITiGW0qABEwo2iU2jzy+RrP8AamCLSyhScq091Q6jUzcEdRWpmEoSTGkJ4nxI0FhrS/vbkfakIbDqTE5YUUi1yNTY2M62qGNjlJplNUl8iGlIEXvV3evaSlNMYZSQEsJJkaLLkEHyE++h/akHQD3UwYBrD4gNpcAU9MAkkJyCVQqIlRJKRfiOUUxaeSiTTWEHtkPf4VlBXADaLAaEp/MnzojslQLiPFP91UNpdkh3s2BLaQE85IF4nhwHhNXdgj51EfZ/uqjjenOs3M2PeZgrwmISn2uyUU/xAEp94FZfudvY62kMqXKTJST1Mn4z51sakzIPGvzZj8OlDrjSVkKZcWlMCQoAqywQZGkTfUUF0FOtplFTalg0LZ2MPbAk86q7wYwhJ6mZngL/AHUB2VtJkFObEZTGtjePCoN68alYQlt5LqTJVESDIgd3nexrkKtueDoPKjkqYDDqxj7QKjlW6lCURbLPeV5AGtp3oaBweJSR3exXbwQYrLfkqwxxG0A4B83hWleBcX3B6jMf5a13aWH7VpxomA4hSCeWYEffXdqgorCOddc20mfkpxGZaJ0URPS9/dT9u5siIVlgaBRvEaxbjY+XU1Ht3drC4Y9qC44g91IByFKwohQWpSVJzAAwALxeOMre9+HSwMpczpAAZUlMTF/nQYyg/ZBNrDWob+z8OzxHVW3Kx/wS/KFjHA2huFdkQAFDQqQAkpVzhITbpNISCYkHoaubU2w5iVS5BVoCkACLwCNDEmDr1NGt390luQtz5tB0JkqV4J4DqT60VcH4TX2xlJy+CnsHd84i5JCRqTYdO8Z48ACaI4PZqmX20sgqv31ga8wOSbefGnXH4VtltKG2+6ItJk/aJ99VdmD51HzRTYiZPNX3GfOrIUYWWc+27L6oUnd13HFqUlaYUbzFp4Ek1c2T8n/bWOJSDGiU5/fMUS2vmSFG4T2iki8DmQPdRDcHEy8E2vP9pP3U2c31yhMFmWGSbA+T44fENPHEZuzVOXs4mxETmtrXHyo4Nx3s+zQVQOA07w1pyXiyTQTeF4xUv6jk9jpRSWEIb2yC5h20qOQpAka3vQ7C7shz2nI4afnTRi8UEp50vr2jGnupkZNeCWkC8fsVLaykOE+UV7Ds5BFSPPFSpNczR9m/TD7lk0w4O6BkFgI015n1peU2r6p9KJbNxi20ZRIvOnhSLotx0Ej5sjAZtaZGdlAjhSRgtkYlV06fxgffR3ZGxsUl5tavZSoE9+bDpNZP+TYP9hqw+x+lX29lQDMWE1W29h1vMdm17RI45dDzpbwW7GLS4lainKkyr53gLm1ISz8jnr4G7ZWySrDtrt3kA61b2ds8oeQolSRCrp19k6UkI3LxjrYcQUZVCU/OxbqIrRdhY1DZYQohJSgJk3Hsxf8APmKGen6EvBW2ziFhZUqSokQJ0AkyRqKpIdQgkJdAKZCwAbmYIBtM5tPGmHetghovLX313ACfohRHdImEx91IjCRlzXAvmBHEHp460nq1tiZejKtkPtqRYpiSdIvEepFQtoSkkKIukTMHQC0Wga89aEMYlY7wMpSYvHK2vnXSNpOK7wKRwMRzkwORkelFKUpAZL+MxZCbGY01i/COsHjXGHwc98KIAEqmx5QOdzUaMSlSgcnGRJ0MkBR8TXtoYrL7Qgm4AiL3SSJ6zJn8FLPwEIm28GwlTikrXKXCFjJAkyUlJJ8jMcxar27+Ha7TtMxUUoSOQum09YERXe9eNaMDsVSEjvZ/3km5jKQACCARz86+7AUlYcKBc3KZm6USYPKBMeVW/BTZ9uEex22Q0uOzmb6xAkjTjpUeyt63xiEKSnMlJ9gAXTPE8xzJojjd2TiVJcDzTfcgNqJC1QpRtbLoedFN3t2ktkKhJAhVu8FXspUXyWkk8iK936rRRx+G5blpGj4LfBzENuKCg32YzK7hPcSCpQk2SSBA8ZrNt6MHkxpCUQVISueFhld85SpU9CONals7d1BYWxmKu0Muq0NzJ04mwjlSzvjgw3iGpClns3BqkEkuFU3GmZSrC8ceNTu+TlsZXVCV3SBkT+1y0+SEjuqMJVOlxw4eFRJxK1ysWCrW5TRna2FOYAptOh0v09PSuOyMStVpmBabzpNj00o018FM6bftk9B3cbbD2FehiLp74N82kDxi4q6n5Ucdh1lLiU4hsGJUMiyOeYC06wQdaF7oAhT731FNmP6zx+jIAottbZZWBiEoKlDuuoAklEQFJHGNevurYcrrPDJ7ONGyP7lzefAYbaOzVbQaBw6jLiyQTnLZUhSVhBg3FlRNh1rKnsEE4dKlLCSVmQQcxgQCm1x3jOladszbHY4ZeDdblhaFgKQLoDuaVRxGYnumCPdSxtQYdbaGUNuuq7oChlTlOQAiFJlRKgdCkWGtVW2xlhr+5NVxZV9lJ/wQ7h4BAWVlQUtKJyx7OY21ETAOmk03nFXoPsBSOw7iSO+QpRsV91MSOEaa1O9NV0NKBz+Tl2YC+8DwyiZiRprQzZbo7VAClzMDT6x++re8SoQCFZdO96UI2ftJLbqVrcK0pMkJFzCtL+lF8AN/UGN72kqbUkH2cSsDwj8qp7jYct45gkKudCNQpCgD4X91BdpYrtCpcnvKJ63M1d3OdUrHYclSlQsSCeGg18dKTKOItBwlmaNKexBTw0Uf7qHbbJU2bdat4t4kKtotQ9Fp/wBVLe8j7hyEJJHQEnjIkGo4lE/AHtNqEgzr+NAMQyRci1GnsSowFAyPokcLcDUOIdOlo/KmKeCdghpE0T2f2bZC1iSLgHn4VEsaWueXGoVIvej7GZJn9pqJJy6k1XOOPKuivS1hX1IBvf0miTTNyUMI7iwPm+0jomfuo1sN/Gl5Hah3JN8wgaHpzoNhtvutiE5fMfnR/YO33nXkoWE5TMwL6eNLmejgM7xPPhsdgV5830BJiD+VA9mYrHF2HO27PKoqzCBGRWvnFF949prYSktxckXE8KX9mbzPuPdmrLlUlcwL2bUR7wKCK0MkXsO5tJS0obOISyYAUn2Qk9Jo5tbGKQoBJhVsxUL5gBczpcE+dK2H31xLTvZAo7MEJHduBbW96YNusrzEgBQJnuggWEEQZjnHxqe9PKNXmiztDeFb7aWlAAI9gCbGwN+Mm/Cq6MKIgyUgGw0MXgE3GvpUGz8O4A4koy5CkmQQbwAFE2F8xgfV6VFi9qICoJMBIseB0MQedxNTSbbwZ/JFtJLaQQFgQZtMcgAI1iDJNUGn0xBgeFDW3M2a8aa310q9gkgpvwF+vrqapjHC2LZI0pxWXsyfaEHlJ0/XU1I41BAXeSJvrcSJnS8TFWmMrQI7QgfRKeJjgdOPuo5sXAJKkLXmUtR+ay5SbmAsgi5KrgGwoG9lXF48rpYij5gN1GnAVYhpIVGcNZVkJF4C3QlSlrAMZQQnoTeguGwzZxXZNIU2iSAOF+7IIQARfjGhp12m2llWVS386ZKiFITeNJCSRHQ0kt4vM8jsu0MOJCSohUKUsa2BN+ZvRqfwdp8fCUorX/YRwGGDbbYkhSkkmO8hScyk96OE/wBvGxopsp5ClqCUlKBA71u6iyEH7XFXUnkK+4vDjDsJZuVJBKlRxme74ZhHVYNwDQXYGLyjIY1kaDy9aGWiinta8vzw1LZi57pATbUWMdI04ac6Xd90vYcKeYcK+LiVAKIH2VKBVYcPGucGskiVQbaGT0q9iGxlIMqPI/dPvsTW5TQCp6W9s/4Mq2s84+c8qJNxE6a0PYYcJA9rpTtgGW0BaFAQhZynmlWnjeRVTaWJHspAF+FvKlJtaL5UqewRh3lsqLqWwMncgA98kGQq/s/lUD+2n3bOOqIIuJsOXkDV3b4CnOzSLJsI4qOp9beVAX+7N6JktsI1vQX2ftYZgHbgjIo8VIIgoUdbWKVapIHDT20MAkFSkki6Q2Anp3jETFhb7XSl/PmPj8aYtlpUoBse19G3qP191yin8k/btvGi9sfaYA7JxKS3mJBlKVInUjJF+czwtVvGtJF0KzI4KgjyM8ao7OwozwqARY/NpMkRIkgmYvrzpiTspSO0QXJQ2MzgSmStE2cbTISBEX6+NPqvcHh+E3J4CsWV6V94kktpgAmBY6UqYxJBEtouTpF7+NOO1cq20lMKSf1frQLGtJCSSgWJn8f1yroxkmsnBtg4zaYuFJUEgEA2uaIbrYZaccwTBCXm5IPNQ51EtCVKJKciCoxrCeOWfOi27uDQcW1lBAStJmQZ7wMxqBSbJeoZVBaeRi3n2hk7VuLKWrnMy0r7h60t4LbBRZQKk8R5nnrRPfQjtXMxIhZ8LpbOnO3upT7aFAzpePDrxP41PDwyyTyFdtbQQ5C0oyrmD4RYeP4VRYMklWh0Ecq9jFIypWPaVOZIAsOB8+tfMM8FJiDA68T4edFJaFs8XgJEflfXyquvFT4CuMQkRE1TCxGUDjWxieLLi5gjz8+NW2XABEmgZSZ0MVKjFxzHhRtfg0I4HbCUC7YPp+FF9k7bDjgSG8tiZtQLA4nDAHOiT4E/A0X2Q/hys9kmFAawRbzpUmHEK7X2x2AScmaZ48ooLhd4g64UdiEylXekW7p6Va21tDCoKRiE5pmLE8p0qhhMdgVKUGG8q8pg5SLcdTWRClk+tb35XQ12AsoIzT1AnSndeJBUpKjlSWyCqLCYuSLjx4UhJ2hge0y9lLmeJy/TmJmedMj75zDMRliDPASDpMRrfr0pN2thJ6BOIeU0T3iR3ZhWo70ZuR0MGhLii6sBJJAlRnWLEk8+PvontBQShKcuXNcuqMyi8Qkaj486CMYxCVpSEKVJgk37sQYjjJNtLcaTDewSwBCjFr6xYX0GarvagBCSDFyTaSomJB8OHOao4hwERmGUGDIm5g+OgHWr77kAKICQkHLBnMVaG1ut72NMb0gcF9gpcAbBklWVR0sbc7nyq8rauVZUi0GExaAmyY8gKXMLtJKSlMkuCSLQhOokc1GFXNhax4dHGLXCEpEmB3UySQItF7jh4mlTgfQf0mSoi5P5CG1drqXJKzc3k3vxPOrSsFGELpEtIcQIuntFFaMxnXQkf7UBx+z3k+2B4BxtR/pSoq91S7X3kWtlnCmyUrTPUgqJnnf3zTK4JDOXy5SWF/79h1axoeCVE95SRmMRIuRbhqSR9ZSqhxmBQbmx6R50D2djMqQOQHuq6ra4PDhflSMtyZ2oRhCqKj5gLNY4tpEQY0k0O2jiX3YInvGAZCU/kAAfTnQtzaMmpsJjwTC5KeIBjwI5EcPCqqK4uWzn8y5qD/T9C7e4uOWhDiUqIUL3RPiEFSSkRzJJ5J0rte4GO/8A5K9Gz8HqdPk53jCv8MtUnVsniOX3x49KennghJUqwAknoKunVGMsdUfNrn3r/kzBdq7u4nCKhbZuISr2ozQCcyYBVw0ETx1pdxmz1G0G1PO9W8QfcK8xgE9kAYi8Zz5WHUk8BSozi+8BIA6/lWcjjxhj8nU4l07a8TKWE2QoAEJUQRJOUwNbT4fGjeHwPZtlxViD3OcjpyuPhxqbC7WygpBOUxbUEp0nS35VDvZt1b/fVAIEAJECKhm1nRbCpxjtaJNm7TSpLnatpUh0+1HfacnUHiCfOVcjRLaGOlKVSlJSkBBK+8pMa3idR11mkPZ+NN2RJm/nAKQOpPwok3g8RHcb7oEG6c0A3lJVnt/Dahsj+Cfh3dW+35LOB2hKXkEwAAvwvCviKmGMSlQJUSAokiJBgJMelBNiqPbKSPaLahe4mx8xYUbWy99jjwH1R0510eK/9vBxP6ju9y/JUaaCXzngJuRm9m909CYIohsHEZcQknIE2hSTY94Wk1GhleGDgdSVpWRBBkCQYufs8q+7X2cheLSShTBAQoN2IAsQZ5nXzrJxy8iIywkg3vxhpDp5Pe4tI/Cs/KYJCuFazvCyCMUPE/8Awn/TWT4jurPdsVaHxpFfh65YkRpQYuZ1PgPLhUy0JCLkZre+qru0ADGWeE6fDWoO1MCTqRTMNii40xeSfLkK5eVlPs1Op5KRYGolqEida2Pp4jL6TwqurCzVltiTMW11ipg+Ba1GzyIsNgmTJU7HmPworszCNIUVNrzGINwYHlS4NlrUmc6QPOjm7OzFNFRUoHMBpwg1LZJfkdBN/B927g2HCkvOZCBa6Rr4g8qpYDAYVtRU06Vrym2ZJsdbAVZ3h2Gp9aSFhMCIIJm+tqqYXdxTHzhcSq0QARr41sJJ4WTZJlobMwfahSXpczZsuZJ70zEROtMmx0KccdSCJ7PuzpOZOtK2F3aUh0PdqkgLkpgg3/3pw3UT/iHT/wBv7xS7MN+mpC/tBS21rSpBWVGIiJv7QOv0Y5CTUaTlADeUOHVQgBIABsdSYETprTfvEs5TGuUx6Vm2IxK0TCdRCp0MiNB+rUrpk89M6dWJQsrSXJm6ZTYWzDQ2MWkaV554yZgzEZZjynwoK3MiP10pmwxVlzLSkQMoSkTAg9ZtYeVMmuqBBbIPaA8II14/omi2EJiADJ7pA1UT9AHUfajw8R+GxULgKIPelQF9LRfiLa8Z4Uf3PQS8VlslCIlPRUiABcydSNb15R7PZdTc4w0GlbBWMO4pSWvmkBS20tthIse7mynMq171neMxwdcaIEZbHxKifO9561suN2zhkYdxgBCQoqAQhvKgFY4CNb3JuTxrDFKSlSkwSc1rwBfWOJ8/WmpL4BsnLXb0Z0ukW5VGrEUPGLM8vvrteJ0tU3QuXMk44LQxN7kxU63Mv0jp3TFj7/fQ5Lo/3rlRr20ErchbD7UUhaVJWpJSZSRqDR/Hb9Yl5tTbj7ikq4BKUT55jFKLYkfryr6RTlyZpYyBKiDfZosu4hU6+mgi0Vwpw86jCiK5KqTKyUnlscmorCLuHxBEXr5j8WSMvpVLtPfXLrZAzcR50Ki2z0+V9GEVcPiCH+6oghdotoI15RIjqacXcK+WzJQUpMwkISocykhIVNuBPCaSt30/P5zIy97zmtXb2k4ptSTK0wTpmUk/WSoXB845irHGOMM5cJz9iJuxFk4tMwYSq44iNfffqaalGlfdp4Fa1STCFWHRQ1/WvjRc7RP1Dw96M3Lyp9CxAm5Uu00xhxTCVkzeBEfRm8H+KCB60m4HZzvapU4pRkA94apgEanQimDE4pRdShCozEFaZg5ciDPqT6VWClojMZicsme5JAHhFqG2zpES3secclKnXQr2VATwsWXZ+FZpvZs/sHFRCkrJKLyYB4jhTenaKVqOdZJUABbKPZUCDOg70UD3nwBcSjKmVJMEzwOutTVWxzhh2y7CMhjMZg/dVh7DpESYgWB4/lV/BYMyq6REDvHqLAR4e+q+OataSqYMaeAqntsRk+NAFIFuvGuFoJUkJEnlzqsh0pOWKtuJMgj9TRJGldx86V5KARJNSvpTAF51J+6P1pVcMngaIEHnZ2IIkAx/F+dMO52FcQpRcm4ESZtS6vab4GUKMfwj8KZN0MQ4pKisknMAJEWjwqK5yUX4WVpZRxvBs7EOPktezlA9oDSeZqphdnYhtRLvsxHtA3kcJq3vDisS28oNE5IH0ZvF7xVHA4zELUQ6TliR3YvI6eNepb14esS2TbM2RiEvhax3MxPtA6zFpp33XV889/AB/mpL2Bj8SvEBDhVkvYpgWFrxThu2Pnnj9lPxNBY3nYcFos7yrIQVDUJJF40FZntB5RMgdSeF603eR/I2pUTCVGPAUi4pKVd7QlIOUcARx9RXoeZBs9F5uM6SqQJuRrHHzpoViTACLpsEzrJSJVBHhx4ceAANi8gzwHpUTbygbEijku4rOAy2jKrtFJC1RNzGosVFPAW9IrlvHujMEuKTJ72XulXiReOSZgCq+De7itdb314x4TfyrjDLkHlNDtLBXSnhNHK3YHhQ55+xAmSokk+X4UUIFee2flQhwoORc5FRZRSYUAeYI0plYV2i9sLaDeruYJi8IQ6k3HeLToKVdYKTy5FnbwOHDiSrDsrUoBSFNdq2lRJsQguZRNtLSIiaB7vtytpKIBWQkZoy9/uwrNbKZgza9O+w3MOcstoTC4U2JyhU8MxJg6XPEchRS40peMH9XBA4ptctlpKAoQZk+SpUq3hBpE29swsORBCeE/D8+Nb5vRsphxn9pbBNtU3sBeeUAeUUjHBYd4lLuXKgSoKUEeAzEiOApEeLKD0NhcpLJmeHWKmp+/4Bs+xhkf8AuP8A9KlGzdlCQS35PKPwXXpUNfJVG7K8M5Uad93Njow7ZeeAKj9G9h9URxPGPCiWD2fs0rAbyBz6BzkwoX0JgmmndzY7biklQmFqkDguVSfTTxpNlUn9KBnbrOBO2g204BnwrSPqFReJvySlyTJgeMUCwGNbbxoScmRAcEBIyqUGyAJuVXJuSfZ6SXz5RsWwFhKCEwkoUsawm68scYOSftKFZFtlKErtCYMAJNkixgGTz510Kv6fKMezZzpcxPWAMw9ClKEgnQcuZ/CieFdMzJkaHj61Ww+Qk0QVlsRaeA+NKureSvjSWNE+xMUe3UoqJUpCkqJ1i0KnifHkKKYhxQNlL4c+CYPrrVDYWCzYrIlYMpJzCQNAdeFHsaFIIAOmpEROoAOpEc6r48W4HO5kkpkjClEpxABukIVMGQE3On1kj1qLEYlJAK0qsY5R4TVdK8oAAJHprpEVWcxABvextqJgxrU91bnInUkwyjGEiQITwiNfOh+3NoBaQAVE6cx1It7qsjDKLRLiMxJ7ibJI8ACJI8D99B3cUlK+4go597MffYVPTWs5CbKJUoSJPWp9nm+UiQR7xXT7iDMBU8yZM1CySDbXhV3q2CcuN5yTxua4gpIHrRLCpQFLzEGwibXOvCquJcBUTxnyiK8vcA5OUYNS0kgWHGq6kqBimfCp+Y/l++q+SiQWBaTtwgCED1NHth4pTwK8sXj0r1erl8iKjHKRfTJt4ZT2xvYtpxTQbBCYvmImQDpHWqmG2+p8lJQBHe1J/WtfK9VFVUFFSxsCyby0Xd3t5FvvZCgAZSZBPCmzd79494J+Jr5XqRclGWENreUcb0OgNqKhICFSOYi9I21cUiBlBnKLEGIgRHOvV6m1LQm/0BjEHMVExNdvOAjWSda9XqocULLuzmiptQSL2/OuGEG9javV6lWIs4r1g8Zk9BNRu7UeLSGlKUUNhXZpNgjMSVKAi5uq559K9Xq2tGXSbkT7IfBCUqkQqARwCinUcbBXK5FH8Bild54gqbdMuge0hf01AfxHMRyWB1H2vUxSaZnsUMat5AE9kcUMhImG1oKoEAqPZgk8yTQXeYqQtCQCG1d4E3zKOsnif0K+V6gm3sdVhNMF9sbE1DNer1SSbOhFn1DhBBEzNvEaU/f8S7BLbri1MuuXKE9/MYgnJBAkESfLnX2vUyvwVcsvDFreTaPauCAoApGZS2+zytI7xQgQNYkkC8gcTKfjVPYp45ULcJUYCQTqSZ+HkBXq9VcW2sZOXZjJWdYcacKFgpUNQdRbpVzDumwnTTp4V6vUu0dQxj3UxPZPFwoCpSQkkWkEE/rrR3buJK0tqUqXIiABAR9HS89DXq9VvH+w53M+8otpK0gJEqBgzwB09DNQYrCEcALye9OluHjX2vVPbN/q9f2FRWi7tLEBxIAMhI9s96baJ5ePSlxwAGBevV6lULGgmyxgcKXFZQoJsTJ0twq4zjFNt9mCmFKzEwDBiLGJ0kRXq9VODGys2gX511iMOMsjhXq9WMFMLbN/dBJ5ffUDzqQSJSPEivV6tGH/2Q==" style="width: 300px; height: 168px; margin-left: -2px; margin-right: -6px; margin-top: 2px;">


imglist = soup.find_all("img", class_="rg_ic rg_i")

for im in imglist:
    params.append(im['src'])
    
imglist


a = 1
for p in params:
    req.urlretrieve(p, "c:/data/pictest/"+str(a)+".jpg")
    a += 1 
    
    
browser.quit()


# -*- coding: utf-8 -*-
"""
Created on Fri Oct  5 09:52:16 2018

@author: stu
"""

# =============================================================================
# 정규표현식(Regular Expression) 
# =============================================================================

▣ 정규표현식(Regular Expression)

import re

source = "Data Science"

■ re.match
- boolean 형식의 값을 return문 
- 조건 제어문에서 사용하는 것이 유리하다.

# Da’라는 글자가 source에서 처음부터 어디까지 있는지 match하자
m = re.match('Da',source)

# 대소문자를 구분함 -> 현재 값: None
re.match('da',source)
print(re.match('da',source))

#
if m:
    print('패턴이 일치한다.')
else: 
    print('패턴이 불일치한다.')
    

#
if re.match('da',source):
    print("패턴이 일치한다.")
else:
    print("패턴이 불일치한다.")
    
# re.I : 대소문자 구분 하지 않기
if  re.match('da', source, re.I):
    print("패턴이 일치한다.")
else:
    print("패턴이 불일치한다.") 

#group, start, end, span에 대한 method 의미
source = "Data Science"
m = re.match('da', source, re.I)
if  m:
    print("패턴이 일치한다.")
    print(m.group())
    print(m.start())
    print(m.end())
    print(m.span())
else:
    print("패턴이 불일치한다.") 
    
■ re.match : 앞의 패턴을 찾는 것을 의미
#re.match에 대한 boolean return을 확인하기    
bool(re.match('D','Data'))
#[0-9]숫자의 패턴으로 되어있는지 확인하기
# *의 의미확인하기
bool(re.match('[0-9]th', '2th'))
bool(re.match('[0-9]th', '21th'))
bool(re.match('[0-9][0-9]th', '21th'))
bool(re.match('[0-9]*th', '21th'))
bool(re.match('[0-9]*th', '2th'))
bool(re.match('[0-9]*th', 'th'))
bool(re.match('[0-9]th', 'th'))
bool(re.match('[0-9]*th', '212th'))
#\d: [0-9]를 의미(숫자 패턴 확인)
bool(re.match('\d\dth', '21th'))
bool(re.match('\d*th', '21th'))

#메타문자
- a.b: .위치에 모든 문자 온다, aab, acb, aob
- .은 한글자 한글자를 의미한다. 
bool(re.match('D.','Data'))
bool(re.match('D...','Data'))
bool(re.match('D.b','Data'))
bool(re.match('D.t','Data'))
#[.]:.이 한글자 한글자가 아닌 dot .로 찾을 때는 대괄호로 사용하게 된다. 즉, dot을 문자로 의미하게 된다.
- a[.]b: .은 문자로 인식해서 찾는다. 
bool(re.match('D[.]','D.ata'))
# *: 앞의 패턴이 0번, 1번, 몇번이상 나올지 상관없다.
a*b: aaaaab, aab
bool(re.match('D*','Data'))
bool(re.match('D*a','Data'))
bool(re.match('D*a','DData'))
bool(re.match('A*','DData'))
bool(re.match('AA*','DData'))
# +: +앞에 글자가 최소 한번 이상 반복
a+b : +앞에 글자가 최소 한번 이상 반복
bool(re.match('c+','ccat'))
bool(re.match('c+','cat'))
bool(re.match('c+','at'))
bool(re.match('c*','at'))  #+와 *비교하기
#?: ?앞에 글자가 0번, 1번 반복되는 경우 (*, +, ?를 꼭 같이 고려하기)
a?b: ?앞에 글자가 0번, 1번 반복되는 경우  
bool(re.match('c?','ccat')) #cc가 두번 나온경우이지만 두번째 c도 있기 때문에 true로 반환
bool(re.match('c?','cat'))
bool(re.match('c?','at'))
bool(re.match('c?a','ccat')) #cc가 두번 나온경우
bool(re.match('c?a','cat')) 
bool(re.match('c?a','at'))
#a{2}b: a가 2번 반복 aab
bool(re.match('c{2}a', 'ccat'))
bool(re.match('c{2}a', 'cat'))
bool(re.match('c{2}a', 'cccat'))
#a{2,3}b: a가 2번 또는 3번 반복 aab, aaab
bool(re.match('c{2,3}a', 'ccat'))
bool(re.match('c{2,3}a', 'cat'))
bool(re.match('c{2,3}a', 'cccat'))
bool(re.match('c{2,3}a', 'ccccat'))
#a|b: a또는 b
bool(re.match('c|a', 'ccat'))
bool(re.match('c|a', 'cat'))
bool(re.match('c|a', 'aat')) 
bool(re.match('c|a', 'bat')) 
#[a-zA-Z]: 알파벳 모두
# [0-9]: 숫자 모두
# \d: 숫자 모두 [0-9]
# \D: 숫자가 아닌 것과 매치, [^0-9]
# \s: 공백문자와 매치
# \S: 공백문자가 아닌 것과 마치 
# \w: 문자, 숫자와 매치, [a-zA-Z0-9]
# \W: 문자, 숫자가 아닌 문자, [^a-zA-Z0-9]


source = "Data Science"
m = re.match('Science', source, re.I)
if  m:
    print("패턴이 일치한다.")
    print(m.group())
    print(m.start())
    print(m.end())
    print(m.span())
else:
    print("패턴이 불일치한다.") 
    
    
source = "Data Science"
m = re.match('\w* Science', source, re.I)
if  m:
    print("패턴이 일치한다.")
    print(m.group())
    print(m.start())
    print(m.end())
    print(m.span())
else:
    print("패턴이 불일치한다.") 
# .*: .은 임의의 문자 -> .가 여러개일경우
source = "Data Science"
m = re.match('.*Science', source, re.I)
if  m:
    print("패턴이 일치한다.")
    print(m.group())
    print(m.start())
    print(m.end())
    print(m.span())
else:
    print("패턴이 불일치한다.") 
# .+     
source = "Data Science"
m = re.match('.+Science', source, re.I)
if  m:
    print("패턴이 일치한다.")
    print(m.group())
    print(m.start())
    print(m.end())
    print(m.span())
else:
    print("패턴이 불일치한다.") 
# .? 
source = "Data Science"
m = re.match('.?Science', source, re.I)
if  m:
    print("패턴이 일치한다.")
    print(m.group())
    print(m.start())
    print(m.end())
    print(m.span())
else:
    print("패턴이 불일치한다.") 

■ re.search
- search는 전체를 대상으로 검색
- boolean형식으로 값을 return함 
(match는 앞의 패턴을 찾는 것이지만 search는 상관없이 전체를 대상으로 검색한다.)
#
bool(re.search('Science', source, re.I))

#
m = re.search('Science', source, re.I)
if  m:
    print("패턴이 일치한다.")
    print(m.group())
    print(m.start())
    print(m.end())
    print(m.span())
else:
    print("패턴이 불일치한다.") 
    

■ re.findall
- findall은 정규식에 일치하는 문자열을 리스트로 반환한다.

source = "Data Science"
# a라는 글자를 source에 있으면 찾기
re.findall('a', source)
# A라는 글자를 source에 있으면 찾기
re.findall('A', source)
# a라는 글자를 대소문자를 가리지 않고 source에 있으면 찾기
re.findall('A', source, re.I)

#a와 a다음 뒤에 글자 찾기
re.findall('a.', source)
#a와 a앞의 글자 찾기
re.findall('.a', source)
#0또는 1
re.findall('a.?', source)
#1이상 
re.findall('a.+', source)
#0이상
re.findall('a.*', source)
# 숫자만 찾아내기
re.findall('[0-9]', '오늘은 2018년 10월 5일 입니다.')
re.findall('\d', '오늘은 2018년 10월 5일 입니다.')
re.findall('[0-9]+', '오늘은 2018년 10월 5일 입니다.')
re.findall('\d+', '오늘은 2018년 10월 5일 입니다.')
# 문자만 찾아내기
re.findall('\D+', '오늘은 2018년 10월 5일 입니다.')
re.findall('[^0-9]+', '오늘은 2018년 10월 5일 입니다.')
re.findall('[a-zA-Z]+', '오늘은 2018년 10월 5일 입니다.') # 알파벳 문자이기 때문에 반환하는 것이 없음
re.findall('[가-힣]+', '오늘은 2018년 10월 5일 입니다.') #한글을 찾기 위해서는 [가-힇]를 사용하여 찾기

# =============================================================================
# 오후수업
# =============================================================================

source = "Data Science"

#replace: old -> new로 바꾸기: 미리보기이기 때문에 변수에 넣어주기
source = source.replace('Science', 'Scientist')

■ re.sub: old -> new로 바꾸기: 미리보기이기 때문에 변수에 넣어주기(적용)
- 메타문자들을 쓸 경우는 re.sub을 사용해서 바꿔주는 것이 용이 
- sub: 일치하는 패턴 대체하기 함수
source = re.sub('Scientist', 'Science', source )

■ re.split: 입력된 패턴을 구분자로 분리
 # : 콜론을 기준으로 split하겠다는 의미
re.split('[:]','python:progarmming')    
re.split('[\:]','python:programming')    
re.split('[,]','python,programming')    
#분리시킬 구분자를 나열하면 됨
re.split('[,:]','python,programming:R')   
re.split('[\,\:]','python,programming:R')   
#공백문자를 구분으로 분리하기
re.split('[ ]','python programming R')   
re.split('[\s]','python programming R')  
#,를 기준으로, 공백문자를 기준으로 분리하기
re.split('[,\s]','python,programming R')  
# \를 기준으로 구분하기
re.split('[\\\]','python\programming R') 


#주민등록번호가 있을 때 뒷부분을 *로 바꾸기
010101-1234567 -> 010101-******
#group: 교체시 그룹을 만들어 기존의 일부 데이터를 유지하며, 새로운 데이터에 적용하기
    #( ):를 통해 그룹 만들기 e.g. (\d{6})
    #\g<1>: 첫번째 그룹을 의미

re.sub('(\d{6})[-]\d{7}','\g<1>-*******','010101-1234567')

■ re.compile
- 정규식 표현식을 미리 compile한 것을 사용하기
p = re.compile(r"(\w+)\s+((\d+)[-]\d+[-]\d+)")
            (\w+): 첫번째 그룹 
            ((\d+)[-]\d+[-]\d+): 두번째 그룹
            (\d+): 세번째 그룹
            (\w+) 문자, 숫자
            \s+공백이 하나, 두개
p.sub("\g<1> \g<2>", "James 010-1234-1234")

# group의 순서가 바뀜 (이것이 없으면 위치를 바꾸고자 할때, split를 하고 변수에 넣어주고 인덱스를 통해 바꿔주는 작업을 해야한다.)
p.sub("\g<2> \g<1>", "James 010-1234-1234")

m = p.search("James 010-1234-1234")

m.group(0) #전체
m.group(1) #이름
m.group(2) #전화번호

# group의 이름을 임의로 만들 수 있음
p = re.compile(r"(\w+)\s+((\d+)[-]\d+[-]\d+)")
# (?P<name>\w+): 그룹 1, name이라는 그룹
# (?P<phone>(\d+)[-]\d+[-]\d+): 그룹2, phone이라는 그룹
p = re.compile(r"(?P<name>\w+)\s+(?P<phone>(\d+)[-]\d+[-]\d+)")
m = p.search("james 010-1234-1234")
m.group("name")
m.group("phone")

#
txt = "of the people, by then people, for the people"
re.findall('people', txt)
re.findall('of|by|for', txt)
re.findall('^of',txt) # ^은 시작의 의미  cf. [^0-9] :^은 not의 의미
re.findall('people$', txt) #$은 끝의 의미

#the 이전에 나오는 for를 찾는다. (the 문자 이전에 for가 있으면 보여주고 없으면 보여주지 않는다.)
re.findall('for (?=the)', txt)
#the 다음에 나오는 people을 찾는다. (the 문자 다음에 people이 있으면 보여주고 없으면 보여주지 않는다.)
re.findall('(?<=the) people', txt)


p = re.compile(r"(\w+)\s+((\d+)[-]\d+[-]\d+)")
p = re.compile(r"(\w+)\s+(\d+[-]\d+[-]\d+)")


p = re.compile(r"(\w+)\s+((\d+)[-]\d+[-]\d+)")
            (\w+): 첫번째 그룹 
            (\d+): 두번째 그룹
            (\w+) 문자, 숫자
            \s+공백이 하나, 두개
p.sub("\g<1> \g<2>", "James 010-1234-1234")

# =============================================================================
# group의 의미를 알기 위해 ()를 다시 설정하여 혼자 공부해 봄
# =============================================================================
# group의 순서가 바뀜 (이것이 없으면 위치를 바꾸고자 할때, split를 하고 변수에 넣어주고 인덱스를 통해 바꿔주는 작업을 해야한다.)
p.sub("\g<2> \g<1>", "James 010-1234-1234")

m = p.search("James 010-1234-1234")

m.group(0) #전체
m.group(1) #이름
m.group(2) #전화번호

p = re.compile(r"(?P<name>\w+)\s+(?P<phone>\d+[-]\d+[-]\d+)")
m = p.search("james 010-1234-1234")
m.group("name")
m.group("phone")


# =============================================================================
#  다시 수업으로 돌아가서
# =============================================================================

print("우리 행복하게 살자")
print('우리 "행복"하게 살자')
#\사용법: 문자로 인식하도록 하기 
print("우리 \"행복\"하게 살자")
#\: :만 사용하면 가끔 인식이 안될 수 있어서 \:를 사용하기도 함

정규식 표현식으로 나타내기 
txt = "Let's live happily"
p = re.compile('\w+')
p.findall(txt) #['Let', 's', 'live', 'happily']

p = re.compile('\w')
p.findall(txt)  #['L', 'e', 't', 's', 'l', 'i', 'v', 'e', 'h', 'a', 'p', 'p', 'i', 'l', 'y']

#'를 문자로 인식하기 때문에 앞에  \를 붙여 \'로 쓰도록 한다.
# [\']뒤에는 문자 하나만 나오면 되기 때문에 .을 사용하면 됨다.
p = re.compile('\w+[\'].')
p.findall(txt)  #["Let's"]
#굳이 \를 안해도 되는 경우는 ""를 사용하여 literal 문자로 나타내면 된다.
p = re.compile("\w+['].")
p.findall(txt)

p = re.compile('Physical | Computer') #둘 중에 하나 또는 둘 다 data를 바꿈
p.sub('Data', 'Physical Science and Computer Science') #replace함 
#p.subn: replace하면서 바뀐 정보에 대한 갯수를 return해줌 
p.subn('Data', 'Physical Science and Computer Science')


#group 다시 정확하게 공부
(정규식에서 tuple모양이 여기서는 group을 의미하다)
p = re.compile(r"(\w+)\s+((\d+)[-](\d+)[-](\d+))")
            r: literal 문자 안에 "를 사용할 경우 \을 또 해줘야 하기 때문에 계속 \를 사용하지 않고 사용하게 해줘도 된다는 의미로 쓰임 
            (\w+): 첫번째 그룹 
            (\d+): 두번째 그룹
            (\w+) 문자, 숫자
            \s+공백이 하나, 두개
p.sub("\g<1> \g<2>", "James 010-1234-1234")

# group의 순서가 바뀜 (이것이 없으면 위치를 바꾸고자 할때, split를 하고 변수에 넣어주고 인덱스를 통해 바꿔주는 작업을 해야한다.)
p.sub("\g<2> \g<1>", "James 010-1234-1234")

m = p.search("James 010-1234-1234")

m.group(0) #전체 (r"(\w+)\s+(\d+[-]\d+[-]\d+)")
m.group(1) #이름 (\w+)
m.group(2) #전화번호 (\d+[-]\d+[-]\d+)
m.group(3) #첫번째(\d+)
m.group(4) #두번째(\d+)
m.group(5) #세번째(\d+)


# -*- coding: utf-8 -*-
"""
Created on Mon Oct  8 09:53:55 2018

@author: stu
"""

# =============================================================================
# 오전 수업
# =============================================================================
cf. 
package: global 변수를 편하기 사용하기 위해서 이용

module식 개발: 작은 단위로 개발해서 끼워맞는 작업


▣ class - variable, method 로 구성 
■ 구조적인 프로그램(structured language/ procedural language)
- 프로그램은 순서대로 흐르는 언어(전방참조만 가능함)
■ 객체지향 프로그램(object-oriented language)
- 필요한 프로그램을 호출해서 사용하는 언어 
- 

###############################################################################

▣ 절차(구조적) 지향 프로그램(procedural language )
    - c언어 
    - 물이 위에서 아래로 흐르는 것처럼 순차적인 순차적인 처리가 중요시 되며 프로그램 전체가 유기적으로 연결 되도록 만드는 프로그래밍 기법
    - 단점
        : 재사용할 수 없다. 
        : 확장성이 떨어진다.(overload기능을 할 수 없음)
        : 유지보수가 어렵다. 
        
#누적합 구하기
(글로벌 변수)        
adder(3)
adder(4)
결과는 7일 출력되도록 함수를 만드세요.

x=0
def adder(y):  
    global x
    x+=y
    return x

a
adder(3)
adder(4)


b
adder(5)
adder(5)

a와 b가 따로따로 adder의 누적합을 구하고자 하는데 절차지향 프로그램은 이 경우는 a,b와 상관없이 합이 누적된다. 그래서 a와 b에 대한 함수를 따로 따로 개발해야한다.
그러나 객체지향 프로그램을 이용하여 하나의 프로그램을 가지고 둘이서 따로따로 사용할 수 있는 효과를 줄 수 있음 

▣ 객체지향 프로그램(object oriented language)
    - java, c++, c#, python 
    (cf. r은 구조적 언어이며, script 언어이다.)
    - 구조적프로그래밍과 다르게 큰 문제를 작게 쪼개는 것이 아니라 먼저 작은 문제들을 해결할 수 있는 객체들을 만든 뒤 이 객체들을 조합해서 큰 문제를 해결하는 방법
    - 객체: 사물 개념 중에서 명사로 표현할 수 있는 것을 의미한다.
            사람, 건물 학생
    - 클래스: 객체를 설명해 놓은 것(객체의 설계도)
    - 인스턴스: 클래스를 메모리에 만들어서 사용하도록 하는 의미

객체 = 사람 
속성(Attribute, field) = 변수: 팔, 다리, 머리, 눈, 코 , 입, 이름, 키, 나이, 주민번호, 주소, 학번, 성적, 성격
=> 수치, 값으로 표현 
메소드(method) = 함수 : 기능의 프로그램 처리, 조작하는 것, 속성의 값을 변경하는 기능

#클래스를 표현하는 방법 
class Calculator:
    def __init__(self):
        self.result = 0
        
    def adder(self, num):
        self.result += num
        return self.result

# __init__: 초기화 시키는 method, 꼭 필수사항은 아님
# self 는 자기자신 (이 클래스를 사용하고 있는 자기 자신 )
# 초기화 시키는 작업
# class Calculator:
#    def __init__(self):
#        self.result = 0
        
# adder 에 대한 method 
#    def adder(self, num):
#       self.result += num
#        return self.result
        

#하나의 프로그램을 다르게 사용하고 있음 
#class를 만들었으니 인스턴스instance를 해야함 
<<홍길동>>        
cal1 = Calculator() # 인스턴스 
print(cal1.adder(3))
print(cal1.adder(4))
print(cal1.adder(2))

<<박찬호>>
cal2 = Calculator() # 인스턴스 
print(cal2.adder(5))
print(cal2.adder(5))
print(cal2.adder(1))

class myClass:
    pass   #함수, 클래스에서 아무 작업하지 않을 때 사용 

#pass : 아무것도 수행하지 않겠다.; 함수, 클래스에서 아무 작업하지 않을 때 사용 
    
class Person:
    name = '홍길동'
    age = 20
    
    def myPrint(self):
         print("이름은 {}".format(self.name))
         print("나이는 {}".format(self.age))
#   name = '홍길동'
    age = 20
    위의 두개는 global 변수 처럼 어떤 인스턴스에서도 공통적으로 사용됨

#self: 이 함수를 쓰고 있는 자기 자신을 의미  ()
        홍길동이 이것을 쓰면 홍길동이 쓰고 있다는 것을 의미
# cf. java, c에서는 self를 this로 사용함

# 클래스를 기반으로 인스턴스 생성
p1 = Person()

# 인스턴스화한 method를 사용해야 함 
p2 = Person()
p2.myName()
p2.myAge()

p3=Person()
p3.name = '박찬호'
p3.age = 30
p3.myName()
p3.myAge()
#내 인스턴스 안에서는 속성을 추가할 수 있다. 
p3.job = '프로그래머'
print('직업은',p3,job)

#내 인스턴스 안에서 만큼은 변경 작업이 가능하다. 
#class 장점: 재사용이 가능함

#
class Person:
    def __init__(self):
        self.info=""
    def showinfo(self, name, age):
        self.info += "이름 :" +name+","+" 나이:"+str(age)+"\n"

# self.info대입연산자 + self. 이름 + self.age  그리고 \n 밑으로 한 줄 내리기로 append하게 생성한다.(누적함) 
# str(age)를 쓰지 않으면 오류가 남: 왜냐하면 숫자는 문자랑 같이 사용할 수 없기 때문에 

# init 무조건 인스턴스할 때 생성하고 초기화시킴, 이 클래스에서만 사용할수 있는 변수를 만듦
    name = '홍길동'
    age = 20
와 달리 init은 local변수처럼 적용된다. init에서 생성한 변수는 꼭 self를 붙여야 한다. 

#Person()을 수행시키자 마자 init이 돌아가고 self.info=""가 생성된다. self.info는 null값으로 값을 선언함 
man = Person()
man.showinfo("최유진", 26)
man.showinfo("구동매", 25)
print(man.info)

#woman이라는 인스턴스가 만들어짐, 새로운 info가 선언됨   
woman = Person()
woman.showinfo("고애신", 20)
woman.showinfo("이양화", 21)
woman.showinfo("김현정", 23)
print(woman.info)

name = "제임스"
class myName:
    def mySet(self, setname):
        self.name = setname
    def myPrint(self):
        print(name)
        print(self.name)

p1 = myName()     
p1.mySet("홍길동")        
p1.myPrint()
#self.name: 내 클래스 안에 있는 변수를 쓰겠다는 의미
#name: 클래스 밖에 잇는 변수를 쓰겠다는 의미

class Employee:
    empCount = 0
    
    def __init__(self, name, salary):       # __init__(self) : __init__에 self는 꼭 써야 한다!
        self.name = name                    # 일반적으로 init에 지정해놓은 변수를 self.이름에 같이 사용한다. (self.n = name이라고 해도 되지만)
        self.salary = salary
        Employee.empCount += 1
    def displayCount(self):                 #displayCount(self): self를 꼭 써줘야 한다. -문법임
        print('전체 종업원수는 %d'%Employee.empCount)
    def displayEmployee(self):              #displayEmployee(self): self를 꼭 써줘야 한다. 
        print("이름: ", self.name, ", 급여: ", self.salary)
    
#(기존에는 변수에 호출한 다음 넣었으나)    
# init의 생성자에 변수가 나열되어있으면 class를 인스턴스화 할때 값은 꼭 넣어야 함
emp1 = Employee("홍길동", 1000)
emp1.displayCount()
emp1.displayEmployee()

#Employee.empCount(클래스이름.변수이름 ) :진정한 글로벌 변수가 됨, init은 초기화 되지만 글로벌 변수는 초기화 되지 않는다. 어떤 인스턴스간에 공통으로 사용되는 변수가 됨 
emp2 = Employee("제임스", 2000)
emp2.displayCount()
emp2.displayEmployee()

emp3 = Employee("박찬호", 3000)
emp3.displayCount()
emp3.displayEmployee()


#비교후기. employee.empCount -> self.empCount 로 바꿨을 경우
class Employee:
    empCount = 0
    
    def __init__(self, name, salary):
        self.name = name
        self.salary = salary
        self.empCount += 1
    def displayCount(self):
        print('전체 종업원수는 %d'%self.empCount)
    def displayEmployee(self):
        print("이름:", self.name, ", 급여: ", self.salary)
 
# self.empCount는 empCount가 자기자신의 인스턴스만이 되게 된다.        
# emp1.displayCount()가 계속 1이 됨 
emp1 = Employee("홍길동", 1000)
emp1.displayCount()
emp1.displayEmployee()

emp2 = Employee("제임스", 2000)
emp2.displayCount()
emp2.displayEmployee()

emp3 = Employee("박찬호", 3000)
emp3.displayCount()
emp3.displayEmployee()


# =============================================================================
# 오후수업
# =============================================================================

# 클래스 만들고 -> 인스턴스 생성 -> 클래스 변수를 만듦 (Employee.name);class에서는 맨처음에 변수가 만들지 않았지만 이로 인해 변수가 생성됨 -> 
class Employee:
    pass

#똑같은 class를 사용하지만 인스턴스는 다르게 생성함을 보여준다. id가 다르게 출력되기 때문에 이를 확인할 수 있다.
emp1 = Employee()
emp2 = Employee()

print(id(emp1)) #id는 물리적 메모리 주소
print(id(emp2))

#__class__: 인스턴스의 class 정보확인하기(인스턴스가 어떤 class에 있는지 확인하기)
print(emp1.__class__)
print(emp2.__class__)

#class에 대한 메모리 정보는 같은 값으로 출력된다. 
print(id(emp1.__class__))
print(id(emp2.__class__))

print(id(Employee))

#클래스 변수가 만들어짐 (클래스 변수는 어떤 인스턴스 간에 사용할 수 있다.)
Employee.name = "홍길동"
emp1.name #클래스 변수를 사용
emp2.name #클래스 변수를 사용

emp1.name = "박찬호"
emp1.name #인스턴스 변수가 됨 

emp2.name #클래스 변수르 사용 (자기의 인스턴스가 없기 때문에 클래스 변수를 사용함)

emp1.salary = 2000  
emp1.salary         #인스턴스 변수
emp2.salary         #오류: 자기안에 인스턴스 변수가 없기 때문에


<<요약>>
- 클래스를 사용할 때는 인스턴스화 해야한다. 
- 무조건 처음 사용해야할 method는 __init__이다. : 인스턴스를 초기화시키기 위한 method -> 이는 입력값을 그대로 사용하기 위한 방법이다.
- self지시자로 선언된 변수가 없으면 값이 출력이 되지 않는다. (e.g., self.name = name 변수 선언을 함)
- 모든 인스턴스에서 사용하기 위해서는 class변수로 선언해야 한다. 

# =============================================================================
# [문제187] 생성자에 이름, 핸드폰번호, 메일, 주소 변수를 생성합니다. 
print_info 메소드를 생성한 후  출력하는 Contact 클래스를 생성하세요.
인스턴스는 set_contact 함수를 이용해서 만드시고 이름, 핸드폰번호,메일, 주소는 입력값으로 받아서 출력하세요.
# =============================================================================
생성자 : __init__

#답1 - 잘못됨 
class contact:
    def __init__(self):
        self.name = ""
        self.mobile = ""
        self.email = ""
        self.address = ""
    def print_info(self):
        self.name = input("이름을 입력하세요: ")
        self.mobile = input("핸드폰번호를 입력하세요: ")
        self.email = input("메일을 입력하세요: ")
        self.address = input("주소를 입력하세요: ")  
    def set_contact(self):
        print("이름:",self.name)
        print("핸드폰번호:",self.mobile)
        print("메일:",self.email)
        print("주소:",self.address)

#답2  - 잘못됨
class contact:   
    def __init__(self):
        pass
    def print_info(self):
        self.name = input("이름을 입력하세요: ")
        self.mobile = input("핸드폰번호를 입력하세요: ")
        self.email = input("메일을 입력하세요: ")
        self.address = input("주소를 입력하세요: ")    
    def set_contact(self):
        print("이름:",self.name)
        print("핸드폰번호:",self.mobile)
        print("메일:",self.email)
        print("주소:",self.address)        

emp1 = contact()
emp1.print_info()
emp1.set_contact()


#답2 수정
class contact:   
    def __init__(self,name, mobile, email, address):
        self.name = name
        self.mobie = mobile
        self.email = email
        self.address = address

    def print_info(self):
        print("이름: %d"%self.name)
        print("핸드폰번호: %d"%self.mobile)
        print("메일: %d"%self.email)
        print("주소: %d"%self.address)    
        
def set_contact():
    name = input("이름을 입력하세요: ")
    mobile = input("핸드폰번호를 입력하세요: ")
    email = input("메일을 입력하세요: ")
    address = input("주소를 입력하세요: ")    
    info = Contact(name, mobile, email, address)
    info.print_info()

set_contact()

'홍길동', '010-1000-1004', 'hong@aaa.com', '서울시 강남구 삼성로'

#쌤답 
class Contact:
    def __init__(self,name, pn, email, addr):
        self.name = name
        self.pn = pn
        self.email = email
        self.addr = addr

    def print_info(self):
        print("이름 : {} ".format(self.name))
        print("핸드폰번호 : {} ".format(self.pn))
        print("메일 : {} ".format(self.email))
        print("주소 : {} ".format(self.addr))


def set_contact():
    name = input("이름을 입력하세요 : ")
    pn = input("핸드폰번호를 입력하세요 : ")
    email = input("메일을 입력하세요 : ")
    addr = input("주소를 입력하세요 : ")
    conIns = Contact(name, pn, email, addr)
    conIns.print_info()

set_contact()


# =============================================================================
# [문제188] Contact 클래스 이용해서 입력 들어 온 값들을 c:/data/contact.db 에
	저장해서 관리하세요.
# =============================================================================


import sqlite3

conn = sqlite3.connect(":memory:")

c = conn.cursor()

c.execute("create table contact(name, pn, email, addr)")

class Contact:
    def __init__(self,name, pn, email, addr):
        self.name = name
        self.pn = pn
        self.email = email
        self.addr = addr

    def print_info(self):
        print("이름 : {} ".format(self.name))
        print("핸드폰번호 : {} ".format(self.pn))
        print("메일 : {} ".format(self.email))
        print("주소 : {} ".format(self.addr))

    def input(self):
        self.conn = sqlite3.connect('c:/data/contact.db')
        self.c = self.conn.cursor()
        self.c.execute("insert into contact(name, pn, mail, addr) values(?,?,?,?)",(self.name,self.pn,self.email,self.addr))
        self.c.execute('select * from contact')
        print(self.c.fetchall())
    
    def commit(self):
        self.conn.commit()
       
    def rollback(self):
        self.conn.rollback()
    def close(self):
        self.c.close()
        self.conn.close()


def set_contact():
    name = input("이름을 입력하세요 : ")
    pn = input("핸드폰번호를 입력하세요 : ")
    email = input("메일을 입력하세요 : ")
    addr = input("주소를 입력하세요 : ")
    conIns = Contact(name, pn, email, addr)
    conIns.print_info()
    conIns.input()
    conIns.commit()
    conIns.close()

set_contact()

c.execute("drop table contact")

c.close()
info.close()
import sys
import os.path
sys.data.append('c:\data')
from Contact import *

#c:\data 에 모든파일형식으로 하되 확장자를 .py로 해주기, encoding은 utf-8로 하기 (utf-8로 하지 않으면 불러들일 때 )
# pacakage이름.py로 저장




# -*- coding: utf-8 -*-
"""
Created on Wed Oct 10 09:45:17 2018

@author: stu
"""

cf. 변수함수가 모여있는 것이 class라고 할 수 있다.
class Person:
    hobbys = []                 #habbys:클래스 변수: 인스턴스간의 값이 공유
    def add_hobby(self, hobby):  #hobby:매개변수: add_hobby에서만 사용하는 변수
        self.hobbys.append(hobby) #self.hobbys 클래스 변수이기때문에 self이후에도 사용
        
#p1 인스턴스를 생성
p1 = Person()
#'노래부르기' hobby에 추가
p1.add_hobby("노래부르기")
print(p1.hobbys)

#p2 인스턴스 생성 
p2 = Person()
p2.add_hobby("글쓰기")
print(p2.hobbys)

#class 변수는 인스턴스 간에 공유가 되기 때문에, 클래스 변수를 잘 넣어야 한다. 
#위의 경우에는 클래스 변수로 넣으면 p1, p2에 계속 클래스 변수가 공유되어 쌓이기 때문에 hobby를 인스턴스 변수로 만들어야 한다. 

#클래스 변수 호출하는 방법 (#클래스 변수는 p1, p2나 상관없기 때문에 )
print(Person.hobbys)


#hobbys를 인스턴스 변수로 넣기 
class Person:
   def add_hobby(self, hobby): 
        self.hobbys = []   #hobbys는 인스턴스 변수 -> 인스턴스에서만 사용되는 변수로 사용됨
        self.hobbys.append(hobby)

p1 = Person()
p1.add_hobby("노래부르기") 
print(p1.hobbys)

p2 = Person()
p2.add_hobby("글쓰기")
print(p2.hobbys)


#? 다시 확인하기
#1) 클래스 변수인지, 인스턴스 변수인지
#2) add_hobby(self.hobby)/ self를 인스턴스 안에서만 사용하겠다 하더라도 class 변수로 사용될 경우 인스턴스에서만 사용되지 않는다.
class Person:
    def add_hobby(self, hobby): 
        self.hobbys = []   #list 변수이기때문에 출력하면 안됨 
        self.hobbys.append(hobby)
    def show(self):
        print("내 취미는 "+self.hobbys)

p1 = Person()
p1.add_hobby("노래부르기")
print(p1.hobbys)
p1.show() #Error: list변수이기 때문에 

p2 = Person()
p2.add_hobby("글쓰기")
print(p2.hobbys)


#list변수로 고치기 
class Person:
    def add_hobby(self, hobby): 
        self.hobbys = ""   
        self.hobbys = hobby
    def show(self):
        print("내 취미는 "+self.hobbys)

p1 = Person()
p1.add_hobby("노래부르기")
p1.show()

#인스턴스를 사용할 때 만들 때 값을 넣을지, 메소드를 사용할 때 값을 넣을지 고민해야 한다. 
#지금 여기서는 인스턴스를 만들 때 값을 넣을 수 없다.  --> __init__(초기생성자)가 필요하다.
class Person:
    def add_hobby(self, hobby): 
        self.hobbys = hobby
    def show(self):
        print("내 취미는 "+self.hobbys)

#초기 생성자 사용
#초기 생성자를 만들 때, 인스턴스화를 할 때 name을 꼭 입력값으로 받아야 함.
class Person:
    def __init__(self, name):
        self.name = name
        self.hobbys =[]
    def add_hobby(self, hobby): 
        self.hobbys.append(hobby)

#인스턴스는 이름만 넣고, 초기화 됨 
#이름을 넣고, self.name = name 리스트 변수 생성
#add.hobby 메소드를 사용할 때 값을 생성 
p1 = Person('홍길동')
p1.add_hobby('음반수집')
p1.add_hobby('노래부르기')
print(p1.hobbys)

p2 = Person('박찬호')
p2.add_hobby('글쓰기')
print(p2.hobbys)


# =============================================================================
# [문제_189]초기 생성자에는 이름, 주소, 급여를 입력값으로 받고 아래와 같이 출력되는 클래스를 생성하세요. 
인스턴스 생성될때 마다 건수를 출력해주세요.
# =============================================================================
사원수 : 1
이름 : 홍길동 , 주소 : 덴마크,  급여 : 1000

사원수 : 2
이름 : 홍아들 , 주소 : 노르웨이,  급여 : 2000

#sal을 숫자로 받음 
class Emp:
    cn = 0
    def __init__(self, name, addr, sal):
        self.name = name
        self.addr = addr
        self.sal = sal
        Emp.cn += 1
        print('사원수 : %d' %Emp.cn)
        print('이름 :'+self.name+', 주소:'+self.addr+', 급여: %d'%self.sal)

p1 = Emp('홍길동', '덴마크', 1000)
p2 = Emp('홍아들', '노르웨이', 2000)

#sal을 함수에서 str으로 변환해서 입력하기; 숫자로 입력가능 
class Emp:
    cn = 0
    def __init__(self, name, addr, sal):
        self.name = name
        self.addr = addr
        self.sal = sal
        Emp.cn += 1
        print('사원수 : %d' %Emp.cn)
        print('이름 :'+self.name+', 주소:'+self.addr+', 급여: '+str(self.sal))

p1 = Emp('홍길동', '덴마크', 1000)
p2 = Emp('홍아들', '노르웨이', 2000)

#sal을 string으로 받음
class Emp:
    cn = 0
    def __init__(self, name, addr, sal):
        self.name = name
        self.addr = addr
        self.sal = sal
        Emp.cn += 1
        print('사원수 : %d' %Emp.cn)
        print('이름 :'+self.name+', 주소:'+self.addr+', 급여: '+self.sal)

p1 = Emp('홍길동', '덴마크', '1000')
p2 = Emp('홍아들', '노르웨이', '2000')

#함수 추가했을 때 output 
class Emp:
    cn = 0
    def __init__(self, name, addr, sal):
        self.name = name
        self.addr = addr
        self.sal = sal
        Emp.cn += 1
    def add_emp(self):
        print('사원수 : %d' %Emp.cn)
        print('이름 :'+self.name+', 주소:'+self.addr+', 급여: '+self.sal)

p1 = Emp('홍길동', '덴마크', '1000')
p1.add_emp()
p2 = Emp('홍아들', '노르웨이', '2000')
p2.add_emp()


#쌤답
class Employee:
   
   empCn = 0    #class변수

   def __init__(self, name, addr, salary): #형식 매개변수임 (NOT 인스턴스 변수) #__init__안에 있는 것들은 인스턴스를 생성할 때 초기화 된다.
      self.name = name   #인스턴스변수
      self.addr = addr   #인스턴스변수
      self.salary = salary  #인스턴스변수
      Employee.empCn += 1   #class이름.변수이름이 코드해석에 편리함
   
   def printCount(self):                   # 메소드 안에는 꼭 self를 포함하도록 한다.
     print("사원수 : %d" %Employee.empCn)   #class 변수값 출력

   def printEmployee(self):                # 메소드 안에는 꼭 self를 포함하도록 한다.
      print( "이름 : {} , 주소 : {},  급여 : {}".format(self.name, self.addr, self.salary)) #인스턴스 변수는 self.을 사용하도록 한다.


emp1 = Employee("홍길동","덴마크", 1000)
emp1.printCount()
emp1.printEmployee()


emp2 = Employee("홍아들","노르웨이", 2000)
emp2.printCount()
emp2.printEmployee()


# =============================================================================
# [문제 190]

id_number1 = "010101-3234567"
id_number2 = "990202-2123456"

2001 01 01 남성
1999 02 02 여성

# =============================================================================

#방법 
#1)인덱스 기준으로
#2) -split하여 

#답1
# -를 기준으로 split하기 
def id_process(id):
    first, second = id.split("-")  #split하여 first, second로 받을 수 있음
    gender = second[0]
    
    if gender == "1" or gender =="2":
        year = "19"+first[0:2]   #first[:2]까지 slicing해도 됨   
    else:
        year = "20"+first[0:2]
    
    if gender == "2" or gender == "4":
        gender = "여성"
    else:
        gender = "남성"
    
    month = first[2:4]
    day = first[4:6]
    
    return year, month, day, gender

id_process(id_number1)
id_process(id_number2)    
     
#답2
def id(i):     
    if i[7]=="1": 
        print('19'+i[0:2]+' '+i[2:4]+' '+i[4:6] + '남성')
    elif i[7]=="2":
        print('19'+i[0:2]+' '+i[2:4]+' '+i[4:6], '여성')
    elif i[7]=="3":
        print('20'+i[0:2]+' '+i[2:4]+' '+i[4:6], '남성')
    elif i[7]=="4":
        print('20'+i[0:2]+' '+i[2:4]+' '+i[4:6], '여성')       


id_number1 = "010101-3234567"    
id(id_number1)
id(id_number2)


# =============================================================================
# 다시 수업으로
# =============================================================================
class Employee:
    empCount = 0        #class 변수
    raise_ratio = 1.1   #rasie_ratio는 클래스변수인가? 인스턴스 변수인가? -> 인스턴스로 만들어짐!
    
    def __init__(self, name, salary):
        self.name = name
        self.salary = salary
        Employee.empCount += 1
        
    def showCount(self):
        print("전체 종업원의 수는 {}".format(Employee.empCount))
    
    def showEmp(self):
        print("이름 {}, 급여{}".format(self.name, self.salary))
    
    def raise_salary(self):
        print(self.raise_ratio)
        self.salary = int(self.salary * self.raise_ratio)

    
emp1 = Employee("홍길동", 1000)
emp1.showCount()
emp1.showEmp()
emp1.raise_salary()
emp1.showEmp()

emp1 = Employee("홍길동", 1000)
emp1.showCount()
emp1.showEmp()
emp1.raise_ratio = 1.2
emp1.raise_salary()
emp1.showEmp()

emp2 = Employee("박찬호", 2000)
emp2.showCount()
emp2.showEmp()
emp2.raise_salary()
emp2.showEmp()


#self.raise_ratio를 -> Employee.raise_ratio로 바꾸기 
class Employee:
    empCount = 0        
    raise_ratio = 1.1   
    
    def __init__(self, name, salary):
        self.name = name
        self.salary = salary
        Employee.empCount += 1
        
    def showCount(self):
        print("전체 종업원의 수는 {}".format(Employee.empCount))
    
    def showEmp(self):
        print("이름 {}, 급여{}".format(self.name, self.salary))
    
    def raise_salary(self):
        print(Employee.raise_ratio)
        self.salary = int(self.salary * Employee.raise_ratio)

emp1 = Employee("홍길동", 1000)
emp1.showCount()
emp1.raise_salary()
emp1.showEmp()
Employee.raise_ratio = 1.2
emp1.raise_salary()
emp1.showEmp()

emp2 = Employee("박찬호", 2000)
emp2.showCount()
emp2.showEmp()
emp2.raise_salary()
emp2.showEmp()

# =============================================================================
# 오후 수업
# =============================================================================
class Person:
    hobbys = [] #클래스 변수처럼 선언 
    def __init__(self, name):
        self.name = name
    def add_hobby(self, hobby):
        self.hobbys.append(hobby)  #hobbys에 hobby를 추가함/self가 있어도 클래스 변수가 될 수 있다.
    def show_info(self):
        print(self.name, self.hobbys)

p1 = Person("홍길동")
p1.add_hobby("음반수집")
p1.show_info()

p2 = Person("박찬호")
p2.show_info()   
p2.add_hobby("글쓰기")
p2.show_info()

#hobbys =[]를 __init__에 넣으면 클래스 변수가 아니라 인스턴스 변수가 될 수 있다.
class Person:
    #hobbys = [] #클래스 변수처럼 선언 
    def __init__(self, name):
        self.name = name
        self.hobbys = [] 
    def add_hobby(self, hobby):
        self.hobbys.append(hobby)  #hobbys에 hobby를 추가함/self가 있어도 클래스 변수가 될 수 있다.
    def show_info(self):
        print(self.name, self.hobbys)

p1 = Person("홍길동")
p1.add_hobby("음반수집")
p1.show_info()

p2 = Person("박찬호")
p2.show_info()   
p2.add_hobby("글쓰기")
p2.show_info()


#raise_ratio 중심으로 살펴보기 
class Employee:
    raise_ratio = 1.1  #클래스변수처럼 선언되어있더라도 이 변수는 인스턴스 변수로 사용될 수 있다. 
    def __init__(self, name, salary):
        self.name = name
        self.salary = salary
    
    def emp_info(self):                 #인스턴스 메소드
        print("이름 : ",self.name,"급여 : ",self.salary)
    
    def rasie_salary(self):             #인스턴스 메소드
        self.salary = int(self.salary*self.raise_ratio)

emp1 = Employee("홍길동", 1000)
emp1.emp_info()
print(emp1.raise_ratio) 
emp1.raise_ratio = 1.2 #인스턴스 변수 -> 자기영역에서만 1.2로 사용됨
print(emp1.raise_ratio)  #인스턴스 변수
emp1.rasie_salary()
emp1.emp_info()

emp2 = Employee("박찬호", 2000)
emp2.emp_info()
print(emp2.raise_ratio)  #인스턴스변수
emp2.rasie_salary()      #1.1인상
emp2.emp_info()


#클래스 메소드: 모든 인스턴스가 그 메소드를 적용해서 사용하는 것
# raise_ratio를 변경시 다른 인스턴스에서도 계속 적용되도록 만들기
class Employee:
    raise_ratio = 1.1  
    def __init__(self, name, salary):
        self.name = name
        self.salary = salary
    
    def emp_info(self):                 
        print("이름 : ",self.name,"급여 : ",self.salary)
    
    def rasie_salary(self):             
        self.salary = int(self.salary*self.raise_ratio)
    @classmethod    #@classmethod: 바로 밑에는 클래스 메소드라는 지시자        
    def change_raise_ratio(cls, ratio): #클래스 메소드에서는 cls.매개변수를 만들어야 함
        cls.raise_ratio = ratio #cls.매개변수를 만들어야 함 / #classmethod를 이용하여 위의 raise_ratio=1.1의 변경작업을 함
        print("인상률", round((ratio-1)*100), "%")

#@classmethod: 바로 밑에는 클래스 메소드라는 지시자        
#cls: 클래스 메소드를 의미하는 매개변수(self대신)
#이용: 온라인 게임시 내가 죽었을 때 상대방도 내가 죽은 것으로 나와야하기 때문에 클래스 메소드로 적용하여야 한다.        
emp1 = Employee("홍길동", 1000)     #1
emp1.emp_info()                     #2
print(emp1.raise_ratio)             #3
emp1.change_raise_ratio(1.2)        #4      #내 인스턴스에서 rasie_ratio를 1.2로 변경함 (원래 인스턴스 메소드 변수였으니, cls.를 사용하면서 class 변수로 적용된다.)
print(emp1.raise_ratio)             #5
emp1.rasie_salary()
emp1.emp_info()
print(emp1.raise_ratio)             #11
Employee.change_raise_ratio(1.6)    #12
print(emp1.raise_ratio)             #13

emp2 = Employee("박찬호", 2000)     #6
emp2.emp_info()                     #7
print(emp2.raise_ratio)             #8  #홍길동에서 변경된 raise_ratio 1.2로 변경되어서 나옴 
emp2.rasie_salary()      
emp2.emp_info()

emp2.change_raise_ratio(1.5)        #9
print(emp2.raise_ratio)             #10 #나만 적용되는 것이 아니라 다른 인스턴스 안에서도 적용된다.
print(emp2.raise_ratio)             #14


인스턴스 메소드: 인스턴스를 통해 호출되고 인수값은 인스턴스 자신을 자동으로 전달하는 self를사용해야 한다. 

클래스 메소드: 클래스를 통해 호출되고 @classmethod 데코레이터로 정의하고 클래스 자신을 자동으로 전달하는 인자 cls사용 

스택틱 메소드: 인자를 받지 않는다. (인수값을 받지 않는다.), 함수를 그냥 모아놓을 때 사용하는 것이 좋다. 
(예를들어 math라는 class를 만들고 여러 수학함수를 만들어 놓을 때 그때마다 @staticmethod 를 사용하면 인자값을 넣지 않아도 함수로써 이용이 가능하다.)


class test:
    num = 0
    @staticmethod       #호출하면서 값을 넣는다. /굳이 인스턴스화를 안해도 된다. 
    def add(x,y):
        return x+y
    
t = test
#인스턴스를 통해서 호출
t.add(1,1)
# 클래스를 통해서 호출
test.add(10,20)


class test:
    num = 0            #num=0과 num=x+y의 num은 서로 다른 num이다. 
    @staticmethod    
    def add(x,y):
        num = x+y
        return num
    
t.add(1,2)
test.add(10,21)


# count_viva = classmethod(count_viva)는 @classmethod(데코레이터 classmethod)와 같다. 
##classmethod
#방법1) classmethod로 재적용한다. count_viva = classmethod(count_viva) 
#방법2) 데코레이터 classmethod를 사용한다. 
class Viva:
    cnt = 0                     #클래스 변수
    def __init__(self, name):
        self.name = name #self.name 인스턴스 변수
        print("{}님이 게임방에 들어왔습니다.".format(self.name))
        Viva.cnt += 1
    
    #@classmethod    
    def count_viva(cls):                #인스턴스 상관없이 적용되고 있음
        print("현재{}명이 남았습니다.".format(cls.cnt))  #cls.cnt는 class 변수 / 클래스이름.변수이름(Viva.cnt)라고 해도 된다.
    count_viva = classmethod(count_viva) #classmethod로 재적용 
    
    def __del__(self):  #__del__생성자: 소멸자  # __init__밑에 적용해도 된다. #소멸자는 del하면 돌아가게 된다.
        print("{}님이 게임방에서 나갔습니다.".format(self.name))
        Viva.cnt -=1
        
        
man1 = Viva("홍길동")   #1
man1.count_viva()       #2 #Error남 -> 확인해서 고쳐야함 ㅠㅠ
del man1                #5 #del 인스턴스이름 
man1.count_viva()       #7

man2 = Viva("박찬호")    #3
man2.count_viva()       #4
del man2                #6


class Viva:
    cnt = 0                     #클래스 변수
    def __init__(self, name):
        self.name = name #self.name 인스턴스 변수
        print("{}님이 게임방에 들어왔습니다.".format(self.name))
        Viva.cnt += 1
    
    @classmethod    
    def count_viva(cls):                #인스턴스 상관없이 적용되고 있음
        print("현재{}명이 남았습니다.".format(cls.cnt))  #cls.cnt는 class 변수 / 클래스이름.변수이름(Viva.cnt)라고 해도 된다.
    
    def __del__(self):  #__del__생성자: 소멸자  # __init__밑에 적용해도 된다. #소멸자는 del하면 돌아가게 된다.
        print("{}님이 게임방에서 나갔습니다.".format(self.name))
        Viva.cnt -=1

 
# -*- coding: utf-8 -*-
"""
Created on Thu Oct 11 09:51:07 2018

@author: stu
"""
# =============================================================================
# 오전 수업
# =============================================================================

#
id_number1 = "010101-3123456"
id_number2 = "990101-2123456"

def id_process(id):
    gender = id[7]
    if gender == "1" or gender == "2":
        year = "19"+id[:2]
    else:
        year = "20"+id[:2]
    
    if gender == "2" or gender == "4":
        gender = "여성"
    else:
        gender = "남성"
    
    month = id[2:4]
    day = id[4:6]
    
    return year, month, day, gender

id_process(id_number1)
id_process(id_number2)   


#__str__: print라는 기능, 즉 인스턴스를 호출하게 되면 무조건 출력하게 됨 
#굳이 함수를 만들어 불러들여 출력하지 않아도 __str__을 통해 출력이 가능하다. 
class Person:
    
    def __init__(self, year, month, day, gender):
        self.year = year
        self.month = month
        self.day = day
        self.gender = gender 

    def __str__(self):
        return"{}년 {}월 {}일 성별은 {}입니다.".format(self.year, self.month, self.day, self.gender)

p = Person(2018, 10, 11, "남")
print(p)

#밑의 인수값을 넣어서 위의 클래스에서 정의된 함수를 통해서 return값을 출력하고 싶을 때 
id_number1 = "010101-3123456"
id_number2 = "990101-2123456"

#Error발생
p1 = Person(id_process(id_number1)) 
# *을 붙여 가변문자임을 명시한다. ; 함수앞에는 *을 꼭 넣어준다.
p1 = Person(*id_process(id_number1))
print(p1)


#클래스 메소드로 호출 하기
# 클래스 메소드 밖에서 클래스 변수를 선언하고자 한다면 cls.를 붙여야 한다. 
# 하지만    @classmethod안에서 선언되면 각각의 변수들에 굳이 cls.를 붙일 필요가 없다. 

class Person:
    
    def __init__(self, year, month, day, gender):
        self.year = year
        self.month = month
        self.day = day
        self.gender = gender 

    def __str__(self):
        return"{}년 {}월 {}일 성별은 {}입니다.".format(self.year, self.month, self.day, self.gender)
   
    @classmethod  #클래스 메소드로 바꾸기: 인스턴스 메소드로 사용하면 안된다. -> 이때는 클래스 메소드로 사용해야한다. 왜냐하면 모든 인스턴스에 메소드가 적용되기 위해서 / 클래스 메소드는 self대신 cls를 사용해야한다.
    def id_process(cls,id):                 #id_process(cls, id)
        gender = id[7]
        if gender == "1" or gender == "2":
            year = "19"+id[:2]
        else:
            year = "20"+id[:2]
        
        if gender == "2" or gender == "4":
            gender = "여성"
        else:
            gender = "남성"
        
        month = id[2:4]
        day = id[4:6]
        
        return cls(year, month, day, gender) #cls(변수들)
    
p1 = Person.id_process(id_number1)
print(p1)

p2 = Person.id_process(id_number2)
print(p2)



#상속
재사용의 방법

class Person:
    def __init__(self, name, age):
        self.name = name
        self.age = age
        print("{}객체를 만드는 중".format(self.name))
    def show_info(self):
        print("이름은 {}, 나이는 {}세이다.".format(self.name, self.age))
        
p1 = Person("홍길동", 20)
p1.show_info()


# 중복되는 코드는 따로 class에 만들어 놓고 상속받으면 유용하다.
# 학생이라는 class는 Person이라는 class를 상속받음
class Student(Person):  #class Student(Person): Person이라는 class를 상속받음
    def __init__(self, name, age, hakbun): 
        Person.__init__(self, name, age)  #생성자에서도 Person의 class를 받고자 할 때 
        self.hakbun = hakbun
        
    def show_info(self): 
        Person.show_info(self) #Person 클래스에서의 함수 show_info도 사용하고자 할때
        print("학번은 {}입니다.".format(self.hakbun))

s1 = Student("홍길동", 20, 20181011)
s1.show_info()

# 
class Professor(Person):
    def __init__(self, name, age, years):
        Person.__init__(self, name, age)
        self.years = years
    
    def show_info(self):
        Person.show_info(self)
        print("근무연수가 {}년 입니다.".format(self.years))
        
p1 = Professor("정교수", 40, 10)
p1.show_info()


# =============================================================================
# [문제191] Person 클래스를 생성하세요. 생성자는 이름, 나이, 성별을 만드세요.
Person 클래스 에는 printMe 메소드를 생성하셔서 이름, 나이 성별을 출력합니다.

Employees클래스를 생성한후 Person상속받습니다.
생성자는 이름, 나이, 성별, 주소, 생일입니다.
단 이름, 나이, 성별은 person에서 상속받으세요.
Employees 클래스에 printMe를 재구성하셔서 주소, 생일을 출력하세요.


myPerson = Person("홍길동","10", "남")
myPerson.printMe()

myEmployee = Employee("송준기", "2", "남", "서울", "2016년 01월 01일")
myEmployee.printMe()



이름은 홍길동 ,  나이는 10살 이고, 성별은 남 입니다.
이름은 송준기 ,  나이는 2살 이고, 성별은 남 입니다.
집 주소는  서울  생일은  2016년 01월 01일 입니다. 
# =============================================================================

#답1
class Person:
    def __init__(self, name, age, gender):
        self.name = name
        self.age = age
        self.gender = gender
    
    def printMe(self):
        print("이름은 {}, 나이는 {}살 이고, 성별은 {}입니다.".format(self.name, self.age, self.gender))
        #print( + + + ), +로  만들경우 인스턴스를 만들 때 꼭 문자열("")로 만들어 줘야한다. 

myPerson = Person("홍길동","10", "남")
myPerson.printMe()

class Employee:
    def __init__(self, name, age, gender, addr, birth):
        Person.__init__(self, name, age, gender)
        self.addr = addr
        self.birth = birth
        
    def printMe(self):
        Person.printMe(self)
        print("집 주소는 {} 생일은 {} 입니다.".format(self.addr, self.birth))
        
myEmployee = Employee("송준기", "2", "남", "서울", "2016년 01월 01일")
myEmployee.printMe()


#print( + + + ), +로  만들경우 인스턴스를 만들 때 꼭 문자열("")로 만들어 줘야한다. 

# =============================================================================
# 수업 
# =============================================================================
# Person의 int의 매개변수를 그대로 사용하고자 할 때 pass를 그냥 써주면 된다.
class Emp(Person):
    pass

e = Emp("홍길동", 10, "남")
e.printMe()



# 상속은 여러개를 받을 수 있다. 여러개의 상속을 받을 경우 괄호 안에 상속할 클래스를 나열하면 된다. 
class Emp(Person1, Person2):
    
    
# =============================================================================
# [문제192] Add 클래스에 두수를 더하는 값을 리턴하는 add 메소드 생성
Multiply 클래스에 두수를 곱한값을 리턴하는 multiply 메소드 생성
Divide 클래스에 두수를 나눈값을 리턴하는 divide메소드 생성
Calculator클래스에는 Add, Multiply, Divide 상속받고 두수를 뺀값을 리턴하는 sub 메소드 생성하세요.

# =============================================================================

class Add:
    def add(self, x, y):
        result = 0
        self.x = x
        self.y = y
        self.result = x + y
        return self.result

 
class Multiply:
    def multiply(self, x, y):   
        result = 1
        self.x = x
        self.y = y
        self.result = x * y
        return self.result
        
class Divide:
    def divide (self, x, y):   
        result = 1
        self.x = x
        self.y = y
        self.result = x / y
        return self.result
        
class Calculator(Add, Multiply, Divide):
    def sub(self, x, y):
        result = 0
        self.x = x
        self.y = y 
        self.result = x-y
        return(self.result)
    

                

cal = Calculator()
print(cal.add(10,20))
print(cal.multiply(10,20))


#쌤답
class Add:
    def add(self, x, y):
        return x + y
 
class Multiply:
    def multiply(self, x, y):
        return x*y
        
class Divide:
    def divide(self, x, y):
        return x/y      
        
class Calculator(Add, Multiply, Divide):
    def sub(self, x, y):
        return x-y

cal = Calculator()
print(cal.add(10,20))
print(cal.multiply(10,20))

# =============================================================================
# 오후수업
# =============================================================================

#인스턴스 함수임 (self, x, y)
class Calculator:
    def add(self, x, y):
        return x + y
    
    def sub(self, x, y):
        return x-y
    
    def multiply(self, x, y):
        return x*y    

    def divide(self, x, y):
        return x/y  
    


Calculator.add(1,2)     #오류
#Calculator.add(1,2)가 error가 난다.
#인스턴스 메소드이기 때문에 인스턴스화를 먼저 해야한다.
c = Calculator()
c.add(1,2)

■ staticmethod
#클래스 메소드, 인스턴스 메소드 모두 적용될 수 있는 것은 스태틱 메소드이다. 
#1) 클래스이름.메소드 가능(어떤 인스턴스에 상관없이 같이 사용할 수 있음) 2)인스턴스이름.메소드 가능 -> 클래스 또는 인스턴스로 모두 접근(access)이 가능하다.
# self, cls를 넣으면 안된다.
class Calculator:
    @staticmethod
    def add(x, y):
        return x + y
    @staticmethod
    def sub(x, y):
        return x-y
    @staticmethod
    def multiply(x, y):
        return x*y    
    @staticmethod
    def divide(x, y):
        return x/y  


# =============================================================================
# 모듈 만들고 이용하기
# =============================================================================
■ 모듈 만들고 이용하기
#클래스 메소드로 사용 가능
Calculator.add(1,2)     
#인스턴스 메소드로 사용 가능 
c = Calculator()
c.add(1,2)

■ 모듈식으로 저장하기
- 내가 만든 클래스나 메소드를 모듈로 만들기 
- 예시> c:\data\cal.py로 저장하기

-설정 
파일 형식: 모든파일
파일확장자: .py
인코딩: utf-8 

- import하기
import sys
#path확인
sys.path
#path가 안걸려 있을 경우 추가하기
sys.path.append("c:\data")

#cal 모듈 import하기
import cal
#cal이라는 모듈안에 클래스와 메소드 확인하기 
dir(cal)

#calculator를 인스턴스화하기  :모듈이름.클래스이름
c=cal.Calculator()
c.add(1,2)

#바로 클래스 이름을 쓰고 싶을 때 (from 모듈 import *)
from cal import *
c = Calculator()

#잘 안됨 ㅠ
a = add(1,2)
a.add()


# 모듈 이름으로 불러들이기
PI = 3.141592
class Math:
    def cal(self, r):
        return PI*(r**2)

def mySum(i,j):
    return i+j

#if __name__ =="__main__":   이 조건문은 import할 때 if이하의 로직이 돌아가지 않는다.
if __name__ =="__main__":
    print(PI)
    m = Math()
    print(m.cal(10))
    print(mySum(PI,10))
    
# import 하기
import math_1
math_1.PI
math_1.mySum(1,2)


#모듈안에 무엇이 들어있는지 확인하기
dir(math_1)

print(math_1.PI)
m = math_1.Math()
m.cal(10)
math_1.mySum(math_1.PI,10)

from math_1 import *
print(PI)
m1 = Math()
m1.cal(10)
mySum(PI, 10)


# =============================================================================
# 다중상속
# =============================================================================
■ 다중상속

class mother:
    def talk(self):
        print("대화를 합니다.")

class father:
    def running(self):
        print("달리기를 합니다.")
        
class child(mother, father):
    def play(self):
        print("난 노는게 제일 좋아")
        
m = mother()
m.talk()
f = father()
f.running()
c = child()
c.talk()
c.running()
c.play()
#child가 무슨 상속을 받았는지 확인하기
print(child.__mro__)


class Person:
    country = "한국" #country는 클래스 변수이면서 인스턴스 변수가 될 수 있다.
    def __init__(self, name):
        self.name = name
    def myPrint(self):
        print(self.name + "은 " + self.country+"사람이다")

p1 = Person("홍길동")
p1.myPrint()

p2 = Person("제임스")
p2.country = "핀란드" #인스턴스가 다르기 때문에 다르게 적용된다.
p2.myPrint()

Person.country = "영국" #클래스 변수가 된다. 
p2.myPrint()
p1.myPrint()

#
class Person:
    country = "한국" #country는 클래스 변수이면서 인스턴스 변수가 될 수 있다.
    def __init__(self, name):
        self.name = name
    def myPrint(self):
        print(self.name + "은 " + self.country+"사람이다")

p1 = Person("홍길동")    #1
p1.myPrint()             #4

p2 = Person("제임스")    #2
p2.country = "핀란드"    #6  #인스턴스가 다르기 때문에 다르게 적용된다.
p2.myPrint()            #7

Person.country = "영국" #3 #클래스 변수가 된다. 
p2.myPrint()            #5
p1.myPrint()

#country를 한국으로 항상 상수처럼 사용하기 : __country 
class Person:
    __country = "한국" #country는 클래스 변수이면서 인스턴스 변수가 될 수 있다.
    def __init__(self, name):
        self.name = name
    def myPrint(self):
        print(self.name + "은 " + self.__country+"사람이다")

p1 = Person("홍길동")    #1
p1.myPrint()             #4

p2 = Person("제임스")    #2
p2.country = "핀란드"    #6  #인스턴스가 다르기 때문에 다르게 적용된다.
p2.myPrint()            #7

Person.country = "영국" #3 #클래스 변수가 된다. 
p2.myPrint()            #5
p1.myPrint()



# -*- coding: utf-8 -*-
"""
Created on Fri Oct 12 09:47:37 2018

@author: stu
"""

[참조 : https://docs.python.org/ko/3/library/exceptions.html]

# =============================================================================
# [문제193] 양의 정수값만 입력 받아서 나누기를 수행하는 positive_divide 함수를 생성하세요.
# =============================================================================

#답1
def positive_divide():            
    try:    
        numerator = int(input("분자 숫자를 입력하세요 :"))
        denominator = int(input("분모 숫자를 입력하세요 :"))
 
        if(denominator < 0):  
            raise ValueError
        return  numerator / denominator
    except ValueError:
        print('오류  - 음수로 나눌수 없습니다.', denominator)
    except ZeroDivisionError as error:
        print('오류 -  0으로 나눌수 없습니다.',error)
            
positive_divide()

#답2 
def positive_divide(): 
    
    numerator = int(input("분자 숫자를 입력하세요 :"))
    denominator = int(input("분모 숫자를 입력하세요 :"))
    
    try:
        if denominator > 0:      
            result = numerator/denominator
            return result
        
        elif denominator < 0:
            raise Exception("오류 - 음수로 나눌 수 없습니다. -2")
        
        elif denominator == 0:
            raise Exception("오류 - 0으로 나눌 수 없습니다. division by zero")
    except Exception as error:
        print(error)

#쌤답 
def  positive_divide():
    try:
      
        x = int(input(' 분자 숫자를 입력하세요 : '))
        y = int(input(' 분모 숫자를 입력하세요 : '))
        
        if(y < 0):  
            raise ValueError
        return  x / y
    except ValueError:                          #내장되어있는 error
        print('오류  - 음수로 나눌수 없습니다.', y)
    except ZeroDivisionError as error:          #내장되어있는 error
        print('오류 -  0으로 나눌수 없습니다.',error)


# 클래스를 통해서 사용자 exception처리가 가능하다 
class NegativeDivisionError(Exception):     #Excetpion을 처리하기 위한 class를 만들어 놓음  
    def __init__(self, value):
        self.value = value
        
def  positive_divide():
    try:
        # n = NegativeDivisionError             -> 인스턴스화 해서 사용한 것을 씀; 그러나 굳이 하지 않아도 되기 때문에 #처리함 
        
        x = int(input(' 분자 숫자를 입력하세요 : '))
        y = int(input(' 분모 숫자를 입력하세요 : '))
        
        if(y < 0):  
            raise NegativeDivisionError(y)
        return  x / y
    except NegativeDivisionError as error:      #class에서 만든 error값을 만들어 error값을 그대로  
        print('오류  - 음수로 나눌수 없습니다.', error)
    except ZeroDivisionError as error:
        print('오류 -  0으로 나눌수 없습니다.',error)
        
# =============================================================================
# [문제194] 한주간동안 걸음수를 요일별로 그래프를 그리세요.
#         단 막대그래프 함수를 생성해서 인수값으로 걸음수, 요일을 입력하면 그래프가 그려지도록하세요.
# =============================================================================

# class walkPlot:
#          
#     def __init__(self, step, day):
#         self.step = step
#         self.day = day
#      
#     def walk(self):
#         walk = {self.step: self.day}
#         return walk
#     
#     def plot(self):
#         plt.bar()
#         plt.
#         
#     
#    
#     def plot(self):
#          
# 
# day1 = walkPlot(3000, "월")
# day1.walk()
# 
# day2 = walkPlot(5000, "화")
#day2.walk()


#쌤답
import matplotlib.pyplot as plt
from matplotlib import font_manager, rc
font_name = font_manager.FontProperties(fname="c:/Windows/Fonts/malgun.ttf").get_name()
rc('font', family=font_name)

def create_bar_chart(data, labels,bar):

    num_bars = len(data)

    positions = range(1, num_bars+1)
    if bar == 1:        
        plt.bar(positions, data, align='center')
        plt.xticks(positions, labels)   #기본은 1,2,3,4..로 나오지만 요일로 나오게 만들기 위해서 
        plt.xlabel('요일')  
        plt.ylabel('걸음수')
       
    else:
         plt.barh(positions, data, align='center')
         plt.yticks(positions, labels)
         plt.xlabel('걸음수')
         plt.ylabel('요일')
    

    plt.title('한주간 동안 걸음수') 
    plt.grid()
    plt.show()
    
if __name__=='__main__':
    step = [1090,2000,3000,4000,10000,50000,2000]
    labels = ['월','화','수','목','금','토','일']
    create_bar_chart(step,labels,2)

if __name__=='__main__':
    step = [1090,2000,3000,4000,10000,50000,2000]
    labels = ['월','화','수','목','금','토','일']
    create_bar_chart(step,labels,1)



# 클래스로 만들기 
import matplotlib.pylab as plt
from matplotlib import font_manager, rc
font_name = font_manager.FontProperties(fname="c:/Windows/Fonts/malgun.ttf").get_name()
rc('font', family=font_name)

class create_bar_chart:
    def __init__(self,data, labels, bar):
        self.data = data
        self.labels = labels
        self.bar = bar
        
    def create_bar_chart(self):
    
        num_bars = len(self.data)
    
        positions = range(1, num_bars+1)
        if self.bar == 1:
            plt.bar(positions, self.data, align='center')
            plt.xticks(positions, self.labels)
            plt.xlabel('요일')
            plt.ylabel('걸음수')
           
        else:
            plt.barh(positions, self.data, align='center')
            plt.yticks(positions, self.labels)
            plt.xlabel('걸음수')
            plt.ylabel('요일')
        
    
        plt.title('한주간 동안 걸음수') 
        plt.grid()
        plt.show()
    
if __name__=='__main__':
    step = [5000,6000,7500,10000,10000,20000,2000]
    labels = ['월','화','수','목','금','토','일']
    cbc = create_bar_chart(step,labels,1)
    cbc.create_bar_chart()


# =============================================================================
# 오후 수업
# =============================================================================
import collections

#Counter: 컨테이너 ['a','b','a','c','a','b'] 안에 있는 동일한 값의 자료가 몇개인지를 파악한다. (빈도수 체크)
#컨테이너라는 것은 자료형이라고 보면 된다. 
#결과 값은 dictionary형태로 key:value값응로 제공한다. 빈도수가 높은 것부터 진열된다. 
collections.Counter(['a','b','a','c','a','b'])

collections.Counter(['우리','나라','우리','대한민국','우리','행복'])

#update: 후에 추가해서 값을 출력할 수도 있다.
container = collections.Counter()
container.update('aaaabbbbbccczzzzzzz')
print(container)

#추가기능
container.update({'c':2, 'e':5}) #'c':는 sum 'e'는 추가가 됨
print(container)

for i in 'abcdefyz':
    print('%s : %d'%(i,container[i]))

#c는 dictionary형으로 만들어진다. 따라서 key와 c.items(), c.keys(), c.values()와 같은 메소드를 사용할 수 있다.
c = collections.Counter("hellow james")
print(c)
c.keys()
c.values()
c.items()

#dict_keys를 지우기
list(c.keys())
list(c.items())

# 글자하나씩 counting함 
ct = collections.Counter()
with open("c:\data\hello.txt", "r") as f: #객체는 f로 선언함
    for i in f:
        ct.update(i.rstrip().lower()) #영어는 대소문자를 구분하기 때문에, 소문자로 만들기 + 띄어쓰기 없애기

print(ct)

#상위 5위 이상 
for i, c in ct.most_common(5):
    print("%s : %d"%(i,c))
    

# =============================================================================
# 사용자 구축 사전 만들기 pip install customized_konlpy
# =============================================================================
# anaconda prompt에서 실행
pip install customized_konlpy

#
from konlpy.tag import Twitter

twitter = Twitter()

# 
txt = "텍스트 마이닝은 텍스트 형태의 데이터를 수학적 알고리즘에 기초하여 수집, 처리, 분석, 요약하는 연구기법을 통칭하는 용어이다."

#container 로 담아서 명사수 세기
collections.Counter(twitter.nouns(txt))

#사용자 구축사전  #add_dictionary는 지속되지 않기 때문에 add_dictionary()코드를 같이 가지고 돌려야 한다. 
from ckonlpy.tag import Twitter
twitter = Twitter()
twitter.add_dictionary('마이닝','Noun') 

#단어 추가한 후 container.Counter로 명사수 세기
collections.Counter(twitter.nouns(txt))

# -*- coding: utf-8 -*-
"""
Created on Mon Oct 15 09:50:40 2018

@author: stu
"""

▣ Numpy
- 과학계산을 위한 라이브러리를 다차원배열을 처리하는데 필요한 기능을 제공한다.
- numpy 배열은 동일한 타입의 값들을 갖는다. 
- 배열의 차원을 rank라고 한다. 
- 신경망을 할 때 Numpy가 필요함 

■ 설치
pip install numpy

■ 불러들이기
import numpy as np

■ numpy 배열 생성
- 파이썬의 리스트를 사용하는 방법

z1 = np.array([1,2,3])
print(z1)
type(z1) #numpy.ndarray: 다차원 배열의 의미
z1.dtype #다차원 배열에 들어가 있는 데이터 형; 32bit운영체제에서 사용하는 integer  => 4GB정도 변수를 처리할 수 있다. 
z1.shape

z2 = np.array([[1,2,3],[4,5,6]])
print(z2)
type(z2)
z2.dtype
z2.shape

lst = [[1,2,3],[4,5,6],[7,8,9]]
z3 = np.array(lst)
z3.shape
#slicing하기
z3[0,]  #0행을 보여줌 
z3[1]   #1행을 보여줌
z3[:,0] #모든행(:)의 0열을 보여줌
z3[:,1] #모든행(:)의 1열을 보여줌
z3[:,2] #모든행(:)의 2열을 보여줌 
z3[0:2, 0] #0, 1행의 0열을 보여줌
z3[1:,1:]  #1행부터 ~다, 1열부터 다~ 보여 줌
z3[1:,:1]  #1행부터 ~다, 0열만 
z[0:2, 0:2]

■ 정수 인덱싱(integer indexing)
numpy배열 n에 대해서 n[[row1, row2], [col1, col2]]는 
n[row1, col1], n[row2, col2]
-> 두번 작성해야할 것n[row1, col1], n[row2, col2]을 한번n[[row1, row2], [col1, col2]]에 작성할 수 있다. 

lst = [[1,2,3,4],[5,6,7,8],[9,10,11,12]]
n = np.array(lst)
n[0,1] #0행 1열
n[2,3] #2행 3열
n[[0,2],[1,3]]  #[행],[열]

■ 부울린 인덱싱(boolean indexing)
lst = [[1,2,3],[4,5,6],[7,8,9]]
n = np.array(lst)
b = np.array([[False, True, False],
              [True, False, True],
              [False, True, False]])
n[b] #n이라는 array를 기준으로 b라는 부울린 값의 True값만 값을 나타냄

#조건절에 true값만 뽑아내기
b = (n % 2 == 0)
n[b]
n[n%2 == 0]

■ numpy에서 제공하는 함수를 사용해서 만드는 방법
□ zeros()함수는 배열에 모두 0을 넣는 함수 
#3x3배열이 초기값으로 0이 출력됨
np.zeros((3,3))

□ ones()함수는 배열에 모두 1을 넣는 함수
#4x4배열이 초기값으로 1이 출력됨
np.ones((4,4))

□ full()함수는 사용자가 지정한 값을 넣는 함수 
#3x3배열이 초기값으로 사용자가 지정한 값인 2로 출력됨
np.full((3,3),2)

□ eye()함수는 대각선으로 1이고 나머지는 0인 2차원배열을 생성
np.eye(3)
np.eye(4)

□ range(n)함수는 0~n-1까지의 숫자를 생성하는 함수
np.array(range(20)) #1차원 배열 

□ .reshape: 다차원을 변형하는 함수  #cf. r의 배열의 차원 바꾸기: reshape
z= np.array(range(20)).reshape(4,5)
z.reshape((20,))
z.reshape((5,4))
z.reshape(5,4)

■ numpy 연산
x = np.array([1,2,3])
y = np.array([4,5,6])
#인덱스를 가지고 연산하는 방법
x[0] + y[0]
x[1] + y[1]
x[2] + y[2]
# x와 y가 배열 형태가 같기 때문에 내부적으로 같은 방끼리 연산 된다. 
x+y
np.add(x,y)

x-y
np.subtract(x,y)

#같은 방끼리 곱해짐. 행렬의 곱이 아님
x*y
np.multiply(x,y)

x/y
np.divide(x,y)

lst1 = [[1,2],[3,4]]
lst2 = [[5,6],[7,8]]

x = np.array(lst1)
y = np.array(lst2)

#x의 0행 0열, y의 0행0열의 합
#행과 열을 표현할 때 둘다 가능
x[0,0] + y[0,0]
x[0][0]+y[0][0]

#2차원 배열에서도 np.사칙연산 가능
x+y
np.add(x,y)

x-y
np.subtract(x,y)

x*y
np.multiply(x,y)

x/y
np.divide(x,y)


#행렬의 곱 
np.dot(x,y)

x     y
1,2   5,6   (1*5 + 2*7)  (1*6 + 2*8) =(19, 22)
3,4   7,8   (3*5 + 4*7)  (3*6 + 4*8) =(43, 50)

x = np.array([[1,2],[3,4]])
np.sum(x)          #전체합
np.sum(x, axis=0)  #axis=0 열을 기준으로 해서 sum을 함
np.sum(x, axis=1)  #axis=1 행을 기준으로 해서 sum을 함

np.mean(x)          #전체평균
np.mean(x, axis=0)  #열기준의 평균
np.mean(x, axis=1)  #행기준의 평균

np.var(x)          #전체분산
np.var(x, axis=0)  #열기준의 분산
np.var(x, axis=1)  #행기준의 분산

np.std(x)          #표준편차
np.std(x, axis=0)  #열기준의 표준편차
np.std(x, axis=1)  #행기준의 표준편차

np.max(x)           #최대값
np.max(x, axis=0)   #열기준의 최대값
np.max(x, axis=1)   #행기준의 최대값

np.min(x)           #최소값
np.min(x, axis=0)   #열기준의 최소값
np.min(x, axis=1)   #행기준의 최소값 

x       색인값
1, 2    (0, 1)
3, 4    (2, 3)
#최소원소의 색인값
np.argmin(x)
np.argmin(x, axis=0)  #[0,0] 0행 1열이 아니라 1,3(0,1), 2,4(0,1)임 
np.argmin(x, axis=1)  #[0,0] 0행 1열이 아니라 1,2(0,1), 3,4(0,1)임 
#최대원소의 색인값
np.argmax(x)
np.argmax(x, axis=0)  #[0,0] 0행 1열이 아니라 1,3(0,1), 2,4(0,1)임 
np.argmax(x, axis=1)  #[0,0] 0행 1열이 아니라 1,2(0,1), 3,4(0,1)임 

#누적합
np.cumsum(x)
np.cumsum(x, axis=0) #열기준 누적합
np.cumsum(x, axis=1) #행기준 누적합
#cf. 한계확률 구할 때 열기준의합, 행기준의 합이 필요하다. 주변확률을 생각해야 하기때문에 

#누적곱
np.cumprod(x)
np.cumprod(x, axis=0)
np.cumprod(x, axis=1)

#전체곱
np.prod(x)
np.prod(x, axis=0)
np.prod(x, axis=1)

■ numpy자료형
int, float, bool, complex

□ 정수형(integer)
int8, int16, int32, int64
int8 = 2**7
int16 = 2**15
int32 = 2**31
int64 = 2**63

□ 실수형(float)
float16, float32, float64

□ 복소수(complex): 부동소숫점으로 표시하는 복소수
complex64, complex128

x = np.float32(1.0)
print(x)
print(type(x))
x.dtype

■ .arange() 함수
z1 = np.arange(5)
z1.dtype

z2 = np.arange(5, dtype="f") #dtype을 통해서 자료형을 선택할 수 있음
z2.dtype

#cf arange :0부터 그 숫자만큼 출력

#실수형로 시작점 3, 끝점 4까지 표현
np.arange(3,5, dtype="f")
#실수형으로 3,9까지 표현  (증가분은 1씩 증가)
np.arange(3,10, dtype="f")
# 시작점 2부터 3이전까지를 0,2씩 증가한 값을 출력
np.arange(2,3,0.2)

arr = np.arange(10)
arr
arr.shape #1차원배열
#5행2열로 만들기
arr.reshape(5,2)  #기본값은 행우선으로 만들어진다.
arr.reshape((5,2), order="C") #행우선(기본값)
arr.reshape((5,2), order="F") #열우선

arr = np.arange(10).reshape((5,2), order="F")
arr

■ .flatten():2차원배열을 1차원배열로 평탄화시키는 방법
arr #열우선
arr.flatten() #기본값(행우선)
arr.flatten('C') #행우선
arr.flatten('F') #열우선

arr.ravel()
arr.ravel('C')
arr.ravel('F')

arr1 = np.array([[1,2,3], [4,5,6]])
arr2 = np.array([[7,8,9],[10,11,12]])


np.concatenate([arr1, arr2], axis=0) #열기준으로 붙이겠다.
np.concatenate([arr1, arr2], axis=1) #행으로 붙이겠다.

np.hstack((arr1, arr2)) #np.concatenate([arr1, arr2], axis=1)와 같은 값 #행기준
np.vstack((arr1, arr2)) #np.concatenate([arr1, arr2], axis=0)와 같은 값 #열기준

#합쳐놓은 것을 다시 자르기 위해서는 slicing을 하면된다.

■ numpy브로드캐스트(broadcast)
np.broadcast

x=np.array([[1,2],[3,4]])
y=10 

#차원이 다르기 때문에 값이 더해지지 않는다. 그러나 y가 x모양에 맞게 만들어져 연산작업을 함 
#브로드캐스트가 없으면 loop를 통해 연산작업을 해줘야한다. 
x+y


w = np.array([10,20])
x*w

■ 난수값 표현
□ rand: 0~1 사이에 균일한 확률분포로 실수 난수를 생성하는 함수
np.random.rand(10)
np.random.rand(3,5)

□ randn: 기대값 0이고 표준편차 1인 표준 정규분포를 나타내는 난수를 생성하는 함수
np.random.randn(3,5)

□ randint: 균일한 분포의 정수 난수
np.random.randint(low, high=None, size=None)
np.random.randint(10, size=10) # 10: 0~10 사이  #size=10: 10개
np.random.randint(10,20, size=10) #10,20: 작은값:10 큰값:20 #size=10:10개
np.random.randint(10,20, size=(3,5)) #size를 3x5행렬로 표현

■ .repeat()
arr = np.arange(3)
arr.repeat(2)
arr.repeat([2,3,4]) #0은 2번, 1은 3번, 2는 4번을 반복하고 싶음

arr = np.random.randint(10,20, size=(2,5))
arr
arr.repeat(2)
arr.repeat(2, axis=0)
arr.repeat(2, axis=1)

■ np.tile  #cf. repeat과 비교하기
np.tile(arr, 2) #덩어리로 반복하기 

■ np.unique(): 유일값만 뽑아냄 
np.unique([11,11,2,3,2,12,12])

u = np.array(['a','b','a','a','b','c'])
np.unique(u)
#값과 빈도수가 동시에 출력 (값에 대한 빈도수가 return됨)
np.unique(u, return_counts=True) 

index, count = np.unique(u, return_counts=True)
print(index)
print(count)
#위의 값과 동일
#x, y = np.unique(u, return_counts=True)
#print(x)
#print(y)

#2차원 배열일 때
u = np.array([[1,0,0],[1,0,0],[2,3,4]])
np.unique(u)
np.unique(u, axis=0) #0행과 1행이 중복되어 하나로 출력됨(열기준으로 보기)
np.unique(u, axis=1) #주의하기: 없으면 값이 출력되지 않아야 하는데 순서가 바뀌어 출력됨 -> 모호성 발생. 따라서 이부분을 쓸 때는 조심하자!

u = np.array([[1,0,0],[1,0,0],[1,0,0]])
np.unique(u)
np.unique(u, axis=0)
np.unique(u, axis=1)

#u = np.array([[1,0,1],[1,2,1],[1,3,1]])
#np.unique(u)
#np.unique(u, axis=0)
#np.unique(u, axis=1)

■ np.maximum()  /np.minimum() /np.add()
#data 수가 같아야 함(현재 data1과 data2는 각각 10개임 ); 동일한 때만 가능함
data1 = np.arange(0,20,2)
data2 = np.arange(0,30,3)

#data1, data2각각의 인덱스의 값을 비교해서 최대값을 뽑아내기 
np.maximum(data1, data2)
#data1, data2각각의 인덱스의 값을 비교해서 최소값을 뽑아내기 
np.minimum(data1, data2)
#더하기
np.add(data1, data2)
#합집합
np.union1d(data1, data2)
#교집합
np.intersect1d(data1, data2)
#차집합
np.setdiff1d(data1, data2)

arr = np.array([5,4,1,3,2])
#오름차순으로 되어있는 인덱스 번호를 return해줌 
arr.argsort() #array([2, 4, 3, 1, 0], dtype=int64) 1은 2번인덱스, 2은 4번인덱스, ... 5는 0번인덱스

#오름차순정렬
ix= arr.argsort()      #ix= arr.argsort()[::]와 같은 값 출력; 오름차순 정
arr[ix]

ix= arr.argsort()[::]   #ix= arr.argsort() 과 같은 값 출력; 오름차순 정
arr[ix]

#내림차순정렬
ix= arr.argsort()[::-1] #-1: 제일 뒤에서부터를 의미함
arr[ix]


■ numpy의 배열을 pandas로 변환
lst = [[1,2,3], [4,5,6],[7,8,9]]
arr = np.array(lst)

import pandas as pd

df = pd.DataFrame(arr)

df.index
df.columns
#loc, ix: 인덱스 번호와 컬럼이름을 가지고 값을 출력할 수 있음
#1번 행의 0열과 1열을 출력함
df.loc[1,[0,1]]
df.ix[0:2,[0,1]]
#인덱스 번호만 가지고 할 수 있음
df.iloc[1,[0,1]]



# -*- coding: utf-8 -*-
"""
Created on Tue Oct 16 09:53:55 2018

@author: stu
"""

#KNN
#- K값을 많이 주면 overfitting이 됨
#- 거리계산(유클리드 거리계산)
#- 음수값 (멘하턴 거리)에 절대값처리함 
#https://doorbw.tistory.com/175

import math
-수학에 관련된 함수들은 math에 거의 다 들어 있음 

▣ kNN(k Nearest Neighbors)
- 거리유사도 측정
- 유클리드거리(Euclidean distance)를 사용 
-> k값을 정하는 것이 가장 어려운 문제이다. 
- 다수결의 의미는 잘못된 분류가 될 수 있음을 의미할 수 있다. 
- k값을 구할 때는 전체모집단의 수를 제곱근으로 수행하면 된다. 
- 보편적으로 k값은 5개~20개를 선택하게 된다. 짝수보다는 홀수로 하는 것이 좋다. 

토마토 단맛 6 아삭한 맛 6
목표변수는 과일, 채소, 단백질인지 분류하기 -> supervised learning 


재료   단맛   아삭한맛    음식종류          토마토와의 거리 
-------------------------------------------------------------------------
포도     8        5       과일            math.sqrt((6-8)**2 + (4-5)**2) = 2.23
콩       3        7       채소            math.sqrt((6-3)**2 + (4-7)**2) = 4.24
견과     3        6       단백질          math.sqrt((6-3)**2 + (4-6)**2) = 3.61
오렌지   7        3       과일            math.sqrt((6-7)**2 + (4-3)**2) = 1.41


k=1 : 1NN -> 가장 가까운 하나만 뽑기 (오렌지)
- 오렌지 토마토 거리는 1.4로 가까운 이웃하여 과일로 분류한다.

k=3 : 3NN -> 가장 가까운 세개 뽑기 (오렌지, 포도, 견과) -> (과일, 과일, 단백질) -> 가장 많은 음식종류로 분류됨: 과일
- 오렌지, 포도, 견과 세가지 사이에 다수결로 정한다. 
- 과일이 2/3이기 때문에 과일로 분류한다. 


# =============================================================================
# [문제196] knn 프로그램을 작성하세요.
        
#      pointlist[(1,1),(1,0),(2,0),(0,1),(2,2),(1,5),(2,3)]
#       
#
#        <수행>
#        knn([2,1],2,pointlist)
#
#        <결과>
#	[(1, 1), (2, 0)]

# =============================================================================
#목표 변수가 없음 -> 따라서 주변에서 가장 가까운 점수를 가까운 것을 뽑아낸다. 


#def knn(value, k, pointlist):
#    pointlist = [(1,1),(1,0),(2,0),(0,1),(2,2),(1,5),(2,3)]
#    neighbor = []
#    for i in pointlist:
#        distance = math.sqrt((value[0]-i[0])**2+(value[1]-i[1])**2
#        neighbor.append(distance)      
#    print(neighbor)
#          
#    print(sorted(neighbor))

import operator

pointlist = [(1,1),(1,0),(2,0),(0,1),(2,2),(1,5),(2,3)]
def knn(value, k, pointlist):
    n = {}
    for i in pointlist:
        distance = math.sqrt((value[0]-i[0])**2+(value[1]-i[1])**2)
        n[i]=distance
    
    sorted_distance = sorted(n.items(), key=operator.itemgetter(1))
    print(sorted_distance)
    res = []
    print(sorted_distance[0][0])
    print(sorted_distance[1][0])
    
    for j in sorted_distance:
        if len <
            j[0]
        
        if len(sorted_distance) < k:           
            
            res.append(j[len()][0]) 
            print (res)
    
knn([2,1],2,pointlist)



#쌤답
import numpy as np
import operator    #dictionary 정렬할 때 필요
from math import sqrt

point = [2,1]
k = 2
pointlist=[(1,1),(1,0),(2,0),(0,1),(2,2),(1,5),(2,3)] #리스트이면서 tuple


def knn(point, lists, k):       #point, lists, k: 형식매개변수
    
    dic={}
    
    for p in lists:        
        d = dist(point, p)
        dic[p]=d    # dic[p]:키값 d(거리계산값):value값 
    
  
    res = []
    sorted_dic = sorted(dic.items(), key=operator.itemgetter(1))  #dictionary정렬값 /key=operator.itemgetter(1): value값을 기준으로 정렬해줌 (import operator 필요)
    

      
    for key in sorted_dic:
        if len(res) < k:
            
            res.append(key[0])
            
    return res

 
def dist(x, y):         #list변수값으로 받고, array로 
    x = np.array(x)
    y = np.array(y)
    
    return  sqrt(sum(pow(x - y,2)))  #sum,pow: 기본으로 내장된 함수 

knn(point,pointlist,k)        

# =============================================================================
# 수업
# =============================================================================
■ kNN: 거리를 구하고, 오름차순 정렬을 하고, k개수 만큼 자르고, 다수결로 그 값을 추출한다. 

# numpy를 통해서 바꾸기 
a = [4, 3, 5, 7, 6, 8]
indices = [0, 1, 4] 

■ np.take(a, indices): a라는 list에서 0번 인덱스 값, 1번 인덱스 값, 4번 인덱스값을 뽑아내기 
np.take(a, indices)

#
lst1 = [2,1]
lst2 = [(1,1),(1,0),(2,0),(0,1),(2,2),(1,5),(2,3)] 

point1 = np.array(lst1)
point2 = np.array(lst2)
 
distances = np.sqrt(np.sum((pow(point1 - point2, 2)), axis=1))  #행을 기준으로 합 #numpy, math 모두 sqrt를 가지고 있음 

#array를 정렬 
distances.argsort() #오름차순으로 정렬한 값을 인덱스값으로 보여줌 
distances.argsort()[:3]

indices = distances.argsort()[:3]    #indices값은 지금 array임 
nn = np.take(lst2, indices, axis=0)  #축을 0으로 설정하면 뽑아내고자 하는 값을 뽑아낼 수 있음
nn

#첫번째 값이 level이라고 가정하기
    #nn = np.take(lst2, indices, axis=0)  #축을 0으로 설정하면 뽑아내고자 하는 값을 뽑아낼 수 있음
    #Out[330]: 
    #array([[1, 1],
    #       [2, 0],
    #       [2, 2]])

#빈도체크: 첫번째 열을 기준으로 빈도수 체크 1:1 2:2
#collections의 count method 사용하기  -> 인덱싱, 슬라이싱을 통해 가능

from collections import Counter
#모든 행의 1열을 뽑아냄 
nn[:,0] #array([1, 2, 2])
c = Counter(nn[:,0]) #Counter({1: 1, 2: 2})
#빈도가 높은 하나의 값 
c.most_common(1)
# key값만 뽑아내기 
freq = c.most_common(1)[0][0]
# 다수결 값을 불러내기 
nn[nn[:,0]==freq]


# =============================================================================
# [문제197] 키, 몸무게에 따른 성별을 분류해주세요.
# 
# 키, 몸무게 데이터
# [[158, 64],
# [170, 86],
# [183, 84],
# [191, 80],
# [155, 49],
# [163, 59],
# [180, 67],
# [158, 54],
# [170, 67]]
# 
# 성별 레벨
# ['male', 'male', 'male', 'male', 'female', 'female', 'female', 'female', 'female']
# 
# 
# [155, 70] 성별을 분류하세요.
# 'female'
# =============================================================================
# 성별레벨 : 목표변수가 있음

가장 가까운 거리 계산 -> 정렬작업 -> 그중 3개를 뽑아 -> 다수결의 원칙을 통해 -> 남자인지 여자인지 구분하기

def tw(tall, weight):
    
    tw1 = [tall, weight]
    tw2 = [[158, 64],
    [170, 86],
    [183, 84],
    [191, 80],
    [155, 49],
    [163, 59],
    [180, 67],
    [158, 54],
    [170, 67]]

    gender =['male', 'male', 'male', 'male', 'female', 'female', 'female', 'female', 'female']
    
    #array형식으로 바꾸기 
    eg = np.array(tw1)
    sp = np.array(tw2)
    
    #거리구하기
    distances = np.sqrt(np.sum((pow(eg - sp, 2)), axis=1))
    distances
    
    #distances정렬하고 k = 3으로 뽑기
    distances.argsort()[:3]
    indices = distances.argsort()[:3]
    indices
    
    # tw2의 k=3을 뽑아낸 값을 gender값과 합쳐 gender값 추출하기
    k3 = np.take(gender, indices, axis=0)
    k3
    
    #frequency 구하기 
    from collections import Counter
    c = Counter(k3)
    c.most_common(1)
    
    # key값만 뽑아내기 
    key = c.most_common(1)[0][0]
    print(key)

tw(155,70)

#==============================================================================
#쌤답
x_train = [[158, 64],
[170, 86],
[183, 84],
[191, 80],
[155, 49],
[163, 59],
[180, 67],
[158, 54],
[170, 67]]

label=['male', 'male', 'male', 'male', 'female', 'female', 'female', 'female', 'female']

y = np.array([[155,70]])

#거리계산
distances = np.sqrt(np.sum(pow(x_train-y,2), axis=1))    
# k=3 일때
indices = distances.argsort()[:3]
# label값 구하기
nn = np.take(label, indices)
# 다수결: collections의 counter생각하기
b =Counter(nn)
b.most_common(1)[0][0]


# =============================================================================
▣ sklearn.neighbors 모듈
from sklearn.neighbors import KNeighborsClassifier

■ 인스턴스화
clf = KNeighborsClassifier(n_neighbors =3)
□ .fit 메소드
clf.fit(x_train, label)
□ .predict 메소드: 예측메소드
clf.predict(np.array([155,70]).reshape(1,-1))[0]
    # [155,70]: 1차원
    # x_train: 2차원 
    # 비교하는 값을 2차원 모양으로 바꿔줘야함 -> 1행 2열로 만들어 줘야함 -> reshape(1,2) 을 하나 reshape(1,-1)은 같은 값을 말함; 
    #reshape(1,-1)-1은 차원을 바꿔준다. 
    #[0]을 하는 이유는 female정보만 뽑아내기
#clf.predict(np.array([155,70]).reshape(1,2))[0]    
#reshape을 사용하지 않고 2차원으로 만들어주기 [[]]로 만들기
#clf.predict(np.array([[155,70]]))[0]
    
    
# -*- coding: utf-8 -*-
"""
Created on Wed Oct 17 09:51:01 2018

@author: stu
"""

# =============================================================================
# [문제198] 상품구매여부를 knn으로 분류해주세요.
#
# =============================================================================
import csv

file = open("c:/data/buy.csv","r")
buy_csv = csv.reader(file)
next(buy_csv)

buy_list=[]
for i in buy_csv:
    buy_list.append(i)
print(buy_list)
buy_list

#train_set만들기
train_set=[]
for i in range(len(buy_list)):
    
    train_set.append(buy_list[i][:2])
    train_set[0]

#int(train_set[0][1])
#
#train_integer=[]
#for i in range(len(train_set)):
#    train_integer.append(int(train_set[i][0]))
#
#    #int(train_set[i][1]))
#print(train_integer)
#    


train_set=[]
for i in range(len(buy_list)):
    train_set.append(int(buy_list[i][:2]))
print(train_set)


#label만들기
label=[]
for i in range(len(buy_list)):
    label.append(buy_list[i][2])
print(label)

#예측하기    
from sklearn.neighbors import KNeighborsClassifier
import numpy as np

clf = KNeighborsClassifier(n_neighbors =3)

clf.fit(train_set, label)

clf.predict(np.array([25,120]).reshape(1,-1))[0]
clf.predict(np.array([25,280]).reshape(1,-1))[0]

# =============================================================================
#pandas사용: utf-8로 바꾸기
#쌤답 

from sklearn.neighbors import KNeighborsClassifier
from sklearn.preprocessing import scale
import pandas  as  pd
import numpy as np

df = pd.read_csv("c:/data/buy.csv")

#scale: 표준정규화 작업의 method                
x_train = np.array([scale(df['나이']),scale(df['월수입'])]).T #.T:전치행렬
label = list(df['상품구매여부'])
age_mean = np.mean(df['나이'])
age_std = np.std(df['나이'])

pay_mean = np.mean(df['월수입'])
pay_std = np.std(df['월수입'])

K = 3
clf = KNeighborsClassifier(n_neighbors=K)
clf.fit(x_train,label)
#입력 값도 표준화된 값으로 넣어준다. scale작업=(입력값-평균)/표준편차
prediction_label = clf.predict(np.array([[(40-age_mean)/age_std, (500-pay_mean)/pay_std]]))[0]
prediction_label


# -*- coding: utf-8 -*-
"""
Created on Thu Oct 18 13:46:32 2018

@author: stu
"""

20181018


# 워드 클라우드 추가설명(종현오빠 질문)
- 내가 추출한 빈도수를 가지고 워드클라우드를 만들고싶다

from wordcloud import WordCloud,STOPWORDS

import matplotlib.pyplot as plt

data={'국민':26,'대통령':33,'대한민국':9,'좋은나라':50}

wordcloud=WordCloud(font_path='c:\Windows\Fonts\malgunbd.ttf',stopwords=STOPWORDS,
         background_color='white',width=1000,height=800).generate_from_frequencies(data)

plt.figure(figsize=(10,10))
plt.imshow(wordcloud)
plt.axis('off')
plt.show()


# 훈이오빠의 질문
- 긍정의 반응, 부정의 반응
- https://www.lucypark.kr/docs/2015-pyconkr/#1      참고하면 좋을 자료

from nltk.tokenize import word_tokenize

import nltk

from konlpy.tag import Twitter

pos_tagger=Twitter()

train=[('홍길동은 좋아','긍정'),('강아지는 무지 좋아','긍정'),('수업이 재미없어','부정'),
   ('홍길동은 이쁜 강아지야','긍정'),('난 수업 마치고 홍길동이랑 놀거야','긍정'),
   ('오늘 하루는 너무 짜증스러운 날이야','부정'),('하루가 너무 짜증스러운 날이야','부정'),
   ('날이 맑아서 좋아','긍정'),('오늘 지하철에 사람이 너무 많아서 짜증이 난다','부정'),
   ('비가 오니 짜증난다','부정'),('친구가 짜증낸다','부정'),('하늘이 맑아서 행복하다','긍정'),
   ('공기가 맑아서 좋다','긍정'),('밝게 인사해주니 행복하다','긍정')]


allword=set(word for sentence in train
                for word in word_tokenize(sentence[0]))      단어사전의 중복성 제거를 위해 set하기

LookupError: 
**********************************************************************
  Resource punkt not found.
  Please use the NLTK Downloader to obtain the resource:

import nltk
nltk.download('punkt')
  
  Searched in:
    - 'C:\\Users\\stu/nltk_data'
    - 'C:\\nltk_data'
    - 'D:\\nltk_data'
    - 'E:\\nltk_data'
    - 'C:\\Users\\stu\\Anaconda3\\nltk_data'
    - 'C:\\Users\\stu\\Anaconda3\\share\\nltk_data'
    - 'C:\\Users\\stu\\Anaconda3\\lib\\nltk_data'
    - 'C:\\Users\\stu\\AppData\\Roaming\\nltk_data'
    - ''
**********************************************************************

nltk.download('punkt')               다운 받고 다시하기
[nltk_data] Downloading package punkt to
[nltk_data]     C:\Users\stu\AppData\Roaming\nltk_data...
[nltk_data]   Unzipping tokenizers\punkt.zip.
Out[28]: True

         allword=set(word for sentence in train
                for word in word_tokenize(sentence[0]))
                
allword            단어사전
Out[30]: 
{'강아지는',
 '강아지야',
 '공기가',
 '난',
 '난다',
 '날이',
 '날이야',
 '너무',
 '놀거야',
 '마치고',
 '많아서',
 '맑아서',
 '무지',
 '밝게',
 '비가',
 '사람이',
 '수업',
 '수업이',
 '오늘',
 '오니',
 '이쁜',
 '인사해주니',
 '재미없어',
 '좋다',
 '좋아',
 '지하철에',
 '짜증난다',
 '짜증낸다',
 '짜증스러운',
 '짜증이',
 '친구가',
 '하늘이',
 '하루가',
 '하루는',
 '행복하다',
 '홍길동은',
 '홍길동이랑'}

t=[({word : (word in word_tokenize(x[0])) for word in allword},x[1]) for x in train]

t[0]         사전의 단어가 첫번째 문장에 있는가? 있으면 True
Out[34]: 
({'오니': False,
  '좋아': True,
  '짜증스러운': False,
  '행복하다': False,
  '인사해주니': False,
  '맑아서': False,
  '짜증이': False,
  '비가': False,
  '마치고': False,
  '재미없어': False,
  '친구가': False,
  '강아지는': False,
  '난다': False,
  '하늘이': False,
  '강아지야': False,
  '너무': False,
  '무지': False,
  '수업': False,
  '날이': False,
  '날이야': False,
  '하루가': False,
  '밝게': False,
  '홍길동이랑': False,
  '이쁜': False,
  '하루는': False,
  '오늘': False,
  '놀거야': False,
  '짜증난다': False,
  '난': False,
  '많아서': False,
  '사람이': False,
  '홍길동은': True,
  '지하철에': False,
  '좋다': False,
  '공기가': False,
  '수업이': False,
  '짜증낸다': False},
 '긍정')

classifier=nltk.NaiveBayesClassifier.train(t)

classifier
Out[37]: <nltk.classify.naivebayes.NaiveBayesClassifier at 0x1c7f4278>

classifier.show_most_informative_features()
Most Informative Features
                      너무 = False              긍정 : 부정     =      1.9 : 1.0      '너무'가 없을 때 긍정과 부정의 비율 (긍정>부정)
                     맑아서 = False              부정 : 긍정     =      1.5 : 1.0
                      좋아 = False              부정 : 긍정     =      1.5 : 1.0
                      오늘 = False              긍정 : 부정     =      1.5 : 1.0
                     날이야 = False              긍정 : 부정     =      1.5 : 1.0
                   짜증스러운 = False              긍정 : 부정     =      1.5 : 1.0      '짜증스러운'이 없을 때 긍정과 부정의 비율(긍정>부정)
                    홍길동은 = False              부정 : 긍정     =      1.3 : 1.0
                    행복하다 = False              부정 : 긍정     =      1.3 : 1.0
                     많아서 = False              긍정 : 부정     =      1.2 : 1.0
                     짜증이 = False              긍정 : 부정     =      1.2 : 1.0


test='난 수업을 마치면 홍길동이랑 놀거야'

test_f={word:(word in word_tokenize(test)) for word in allword}

classifier.classify(test_f)
Out[45]: '긍정'

classifier.classify({word:(word in word_tokenize('오늘 왠일이니 짜증난다')) for word in allword})
Out[47]: '부정'

classifier.classify({word:(word in word_tokenize('하루가 너무 길다')) for word in allword})
Out[49]: '부정'

# 좋긴한데 개선이 필요함
# 조사가 붙으면 다 다른 글자로봄 명사 조사 구분이 안됨
# 형태소 분석을 먼저 해서 명사와 조사를 나눈 후에 분류하면 좋겠음


pos_tagger=Twitter()

def tokenize(doc):
    return ['/'.join(t) for t in pos_tagger.pos(doc,norm=True,stem=True)]



train_doc=[(tokenize(row[0]),row[1]) for row in train]

train_doc
[(['홍길동/Noun', '은/Josa', '좋다/Adjective'], '긍정'),
 (['강아지/Noun', '는/Josa', '무지/Noun', '좋다/Adjective'], '긍정'),
 (['수업/Noun', '이/Josa', '재미없다/Adjective'], '부정'),
 (['홍길동/Noun', '은/Josa', '이쁘다/Adjective', '강아지/Noun', '야/Josa'], '긍정'),
 (['난/Noun', '수업/Noun', '마치/Noun', '고/Josa', '홍길동/Noun', '이랑/Josa', '놀다/Verb'], '긍정'),
 (['오늘/Noun', '하루/Noun', '는/Josa', '너무/Adverb', '짜증스럽다/Adjective', '날/Noun', '이야/Josa']', '부정'),
 (['하루/Noun', '가/Josa', '너무/Adverb', '짜증스럽다/Adjective', '날/Noun', '이야/Josa']', '부정'),
 (['날/Noun', '이/Josa', '맑다/Adjective', '좋다/Adjective'], '긍정'),
 (['오늘/Noun', '지하철/Noun', '에/Josa', '사람/Noun', '이/Josa', '너무/Adverb', '많다/Adjective', '짜증/Noun', '이/Josa', '나다/Verb']', '부정'),
 (['비/Noun', '가/Josa', '오니/Noun', '짜증나다/Adjective'], '부정'),
 (['친구/Noun', '가/Josa', '짜증/Noun', '내다/Verb'], '부정'),
 (['하늘/Noun', '이/Josa', '맑다/Adjective', '행복하다/Adjective'], '긍정'),
 (['공기/Noun', '가/Josa', '맑다/Adjective', '좋다/Adjective'], '긍정'),
 (['밝다/Verb', '인사/Noun', '해주다/Verb', '행복하다/Adjective'], '긍정')]

tokens=[t for d in train_doc for t in d[0]]

tokens
Out[54]: 
['홍길동/Noun',
 '은/Josa',
 '좋다/Adjective',
 '강아지/Noun',
 '는/Josa',
 '무지/Noun',
 '좋다/Adjective',
 '수업/Noun',
 '이/Josa',
 '재미없다/Adjective',
 '홍길동/Noun',
 '은/Josa',
 '이쁘다/Adjective',
.....


def term_exists(doc):
    return{word:(word in set(doc)) for word in tokens}

train_x=[(term_exists(d),c) for d,c in train_doc]

train_x[0]
Out[58]: 
({'홍길동/Noun': True,
  '은/Josa': True,
  '좋다/Adjective': True,
  '강아지/Noun': False,
  '는/Josa': False,
  '무지/Noun': False,
  '수업/Noun': False,
  '이/Josa': False,
  '재미없다/Adjective': False,
  '이쁘다/Adjective': False,
  '야/Josa': False,
  '난/Noun': False,
  '마치/Noun': False,
  '고/Josa': False,
  '이랑/Josa': False,
  '놀다/Verb': False,
  '오늘/Noun': False,
  '하루/Noun': False,
  '너무/Adverb': False,
  '짜증스럽다/Adjective': False,
  '날/Noun': False,
  '이야/Josa': False,
  '가/Josa': False,
  '맑다/Adjective': False,
  '지하철/Noun': False,
  '에/Josa': False,
  '사람/Noun': False,
  '많다/Adjective': False,
  '짜증/Noun': False,
  '나다/Verb': False,
  '비/Noun': False,
  '오니/Noun': False,
  '짜증나다/Adjective': False,
  '친구/Noun': False,
  '내다/Verb': False,
  '하늘/Noun': False,
  '행복하다/Adjective': False,
  '공기/Noun': False,
  '밝다/Verb': False,
  '인사/Noun': False,
  '해주다/Verb': False},
 '긍정')

classifier=nltk.NaiveBayesClassifier.train(train_x)

classifier.show_most_informative_features()
Most Informative Features
                  가/Josa = True               부정 : 긍정     =      3.0 : 1.0      '가'가 있을 때 긍정과 부정의 비율(부정>긍정)
                  날/Noun = True               부정 : 긍정     =      2.1 : 1.0
               너무/Adverb = False              긍정 : 부정     =      1.9 : 1.0
            좋다/Adjective = False              부정 : 긍정     =      1.9 : 1.0
                  가/Josa = False              긍정 : 부정     =      1.7 : 1.0      '가'가 없을 때 긍정과 부정의 비율(긍정>부정)
            맑다/Adjective = False              부정 : 긍정     =      1.5 : 1.0
                홍길동/Noun = False              부정 : 긍정     =      1.5 : 1.0
                 이야/Josa = False              긍정 : 부정     =      1.5 : 1.0
                 오늘/Noun = False              긍정 : 부정     =      1.5 : 1.0
         짜증스럽다/Adjective = False              긍정 : 부정     =      1.5 : 1.0


test=[('홍길동이랑 놀거야')]

test_doc=tokenize(test[0])

test_f={word:(word in tokens) for word in test_doc}

classifier.classify(test_f)
Out[65]: '긍정'


test=[('오늘 왠일이니 짜증난다')]

test_doc=tokenize(test[0])

test_f={word:(word in tokens) for word in test_doc}

classifier.classify(test_f)
Out[66]: '부정'


# =============================================================================
# 오후수업 
# =============================================================================

■ 자료형에 따라 통계기법이 달라진다. 

#의사결정나무
#- cross table을 만들어서 chai-square 검증을 할 수 도 있고 
#- 어떤 변수를 사용하는가가 중요(cf 스무고개 생각하기)
#- if then - else 구조를 띤다. 
#- 어떤 알고리즘을 쓰느냐가 중요하다.
#- 필요한 3개 알고리즘: 카이제곱 검정, 엔트로피, 지니지수

▣ 의사결정트리
- 의사결정규칙(Decision rule)을 나무구조(Tree)로 도표화하여 분류(classification)하고 에측(prediction)을 수행하는 방법 

■ 활용분야
- 은행분야: 도산업체 분류(예측) 관거의 데이터로 부터 도산기업과 도산하지않은 기업을 찾아내는 방법 
- 카드발급대상자: 신용불량자 분류(예측)
- 통신: 이탈고객(해지자, 번호이동) 분류, 새로운 서비스 대상 고객 선정 
- 쇼핑: Direct mailing 대상 고객 선정

■ 결정트리 장점
- 지도학습(분류, 예측)의 데이터마이닝 기법
- 적용결과에 의해 if-then 표현하는 규칙이 생성 
- 규칙의 이행이 쉽고 SQL로도 할 수 있다. 
- 많은 분야에서는 결정을 내리게 된데 대한 이유를 설명하는 능력이 중요하다(해석력)

■ 분류나무(classification tree=결정트리)
- 목표변수: 범주형(긍정vs.부정, 도산vs.정상, 좋음 vs.나쁨)
- 분류 알고리즘
    CART: 지니지수(Gini index)
    C5.0: 엔트로피지수(Entropy index)
    CHAID: 카이제곱통계량(Chi-Square statistic)

#두 변수 간의 분석
#1) 분산분석
#2) 상관분석: 머신러닝이의 핵심 -> 3) 회귀분석
#4) 교차분석
    
■ 교차분석
- 교차분석은 범주형(명목척도 , 서열척도)으로 구성된 자료들간의 연관관계를 확인하기 위해 교차표를 만들어 관계를 확인하는 방법 
- 변수들의 빈도를 확인하고 그 빈도를 이용하여 상호 연관성을 판단한다.(빈도를 이용하는 이유는 명목척도이기 때문에)
- 이때 검정통계량으로 카이제곱(χ²)통계량을 이용하기 때문에 카이제곱검정이라고 한다. 
- 카이제곱(Chi-square)검정을 하기 위해서 교차표, 관측빈도, 기대빈도(행의 합과 열의 합을 가지고 주변확률을 구하여 기대빈도를 만든다.), 카이제곱통계량, 카이제곱분포의 자유도((행의 수 -1) * (열의 수-1))가 있다. 

□ 교차표 
- 2개의 조사요인에 대한 자료값을 각가 행과 열로 배열하여 교차되는 항목에 대한 빈도를 나타낸 표를 교차표라 한다. 
- 교차표의 행과 열에 범주형(명목척도)변수를 구분하여 넣으면 서로 연관성이 있는 빈도를 확인할 수 있다. 
예) 지역1과 지역2로 구분하여 최신 스마트폰의 구매 의사에 대한 각각의 행과 열에 해당하는 빈도를 표시한 교차표 

                    구 매 의 사
                있음      |       없음          |  행의 합
----------------------------------------------------------
지역 1  |       154       |        52           |    206
지역 2  |         7       |       112           |    119
----------------------------------------------------------
열의 합 |       161       |       164           |    325


□ 관측빈도(observed frequency)
  154       |        52
    7       |       112         
- 교차표를 작성할 때에는 직접 수집한 데이터를 기준으로 빈도를 입력해야 하는데 이처럼 실제로 수집된 데이터의 빈도를 관측빈도라고 한다. 

□ 기대빈도(expected frequency)
- 기대빈도는 전체빈도 n에 대하여 행과 열의 합을 기준으로 보았을 때 각 교차되는 셀에 몇 번의 빈도가 확인될 수 있을지를 예상하는 기대값이다. 
                  행의 합 * 열의 합
-  기대빈도  =  ----------------------
                    관측수

(206*161)/325= 102.05   |   (206*164)/325 = 103.95
(119*161)/325= 58.95    |   (119*164)/325 =  60.05
지역1 구매의사 있음의 기대빈도: (206*161)/325= 102.05  
지역1 구매의사 없음의 기대빈도: (206*164)/325 = 103.95

지역2 구매의사 있음의 기대빈도: (119*161)/325= 58.95
지역2 구매의사 없음의 기대빈도: (119*164)/325 = 60.05


                    구 매 의 사
                있음      |       없음          |  행의 합
----------------------------------------------------------
지역 1  |       154       |        52           |    206
기대빈도|       102       |        104          |
지역 2  |         7       |       112           |    119
기대빈도|        59       |        60           |
----------------------------------------------------------
열의 합 |       161       |       164           |    325


관측빈도 - 기대빈도의 차이값 

카이제곱 통계량(카이제곱검정)
- 카이제곱통계량이란 관측빈도와 기대빈도사이의 유의한 차이가 있는지를 확인하는 통계량을 의미한다. 
                     (관측빈도-기대빈도)²
- 카이제곱(χ²) = Σ ---------------------------
                         기대빈도
χ² = ((154-102)**2/102) + ((52-104)**2/104) + ((7-59)**2/59) + ((112-60)**2/60) 
   = 143.41

□ 카이제곱분포에서의 자유도 
- 카이제곱검정을 실시하는 경우에는 p값을 이용할수 있으며, 카이제곱분포의 유의수준과 자유도에 따라 결과를 판단한다. 
- 교차표에서 구성된 범주에 대한 자유도를 계산하는 방법은 교차표의 (행의 수 -1)*(열의 수 -1)
- df = (2-1)*(2-1) = 1


■ 독립성 검정(independence test)
1. 가설수립: 각 범주가 서로 독립적인지 아닌지에 대한 검정이므로 귀무가설은 독립적인것이다. 

Ho (Null Hypothesis): 귀무가설, 영가설
- 귀무가설은 일반적으로 믿어온 사실을 가설로 설정한다.
- 귀무가설은 당연한 사실이나 연구할 의미가 없는 가설로 설정한다.
H₁ (Anti Hypothesis): 대립가설, 연구가설
- 공공연하게 사실로 받아들여진 현상에 대립되는 가설로 연구를 통한 대립가설의 조사는 의미가 있다. 

Ho: 지역과 구매의사는 독립이다. (지역과 구매의사는 아무 의미가 없다.)
H₁: 지역과 구매의사는 독립적이지 않다. (지역과 구매의사는 아무 의미가 있다.)

2. 교차표, 교차빈도
3. 기대빈도
4. 카이제곱통계량
5. 자유도
6. 임계치: 카이제곱 분표에서 α=0.01(99%)유의수준, 자유도(df=1), 임계치는 6.63이므로 143.3보다 작다
7. 결론: 귀무가설을 기각하고 대립가설을 채택한다. 





# -*- coding: utf-8 -*-
"""
Created on Fri Oct 19 10:01:31 2018

@author: stu
"""
정보이론(information theory)

information 
degree of suprise (놀람의 정도)

■ 엔트로피(entropy)
- 무질서
- 열역학의 제 2법칙
- entropy는 정보량의 평균 

- -Σp * log2p
    (- 테니스 유무에 대한 예/아니요의 확률을 기준으로)
        - "예" 확룔 9/14
        - 9/14 * log2(9/14)
        - "아니요" 확률 5/14
        - 5/14 * log2(5/14)
        - log 값을 구하기 위해 import numpy as np
        -9/14 * np.log2(9/14) - 5/14 * np.log2(5/14)
        Out[3]: 0.9402859586706311
    (- 습도 유무에 대한 예/아니요의 확률을 기준으로)

        테니스 유무
습도    아니요   예
높음     4       3     7
보통     1       6     7
         5       9     14
      
import numpy as np
엔트로피(전체)        
-9/14 * np.log2(9/14) - 5/14 * np.log2(5/14)
Out[6]: 0.9402859586706311
엔트로피(높음)
-3/7*np.log2(3/7)-4/7*np.log2(4/7)
Out[7]: 0.9852281360342515
엔트로피(보통)
-6/7*np.log2(6/7)-1/7*np.log2(1/7)
Out[8]: 0.5916727785823275       

정보이득 = 전체엔트로피 - 7/14*엔트로피(높음) - 7/14*엔트로피(보통) 
         = 0.94 - (7/14)*0.98 - (7/14)*0.59
         = 0.154    Out[9]: 0.15499999999999997



모든 변수에 관한 정보 이득값을 계산하고 가장 높은 정보이득값을 가진 변수를 선택한다. 

(테니스 유무는 고정이며 각각의 컬럼과 정보이득값을 구한다) -> 정보이득이 큰 값을 기준으로 의사결정 트리에 먼저 사용된다. 
 
import padnas as pd
df = pd.read_csv("c:/data/tree.csv")
#바람
        테니스 유무
바람    아니요   예
강함     3       3     6
약함     2       6     8
         5       9     14
정보이득(바람) = 전체엔트로피 - 6/14*엔트로피(강함)-8/14*엔트로피(약함)
#              = 0.94 - (6/14)*0.98 - (8/14)*0.59
#              = 0.18  Out[20]: 0.18285714285714288

엔트로피(강함)
-3/6*np.log2(3/6)-3/6*np.log2(3/6)
Out[26]: 1.0
엔트로피(보통)
-2/8*np.log2(2/8)-6/8*np.log2(6/8)
Out[27]: 0.8112781244591328     

cf. 브라질vs중국 축구 브라질 vs.프랑스 축구에 대한 의사결정트리 순위 구하기
브라질이 이길 확률의 놀라움 정도
-np.log(0.99) = 0.01        Out[22]: 0.01005033585350145
중국이 이길 확률의 놀라움 정도
-np.log(0.01) = 4.6         Out[24]: 4.605170185988091
0.99*-np.log(0.99) + 0.01*-np.log(0.01) = 0.05 Out[31]: 0.056001534354847345

-브라질이 이길 확률의 놀라움의 정도
-np.log(0.5) = 0.69     Out[36]: 0.6931471805599453
-프랑스가 이길 확률의 놀라움의 정도 
-np.log(0.5) = 0.69     Out[36]: 0.6931471805599453
0.5*-np.log(0.5) + 0.5*-np.log(0.5) = 0.69  Out[35]: 0.6931471805599453

-정보의 이득값에 따라 무엇을 먼저 의사결정트리에 넣을 지 순위를 정한다. 
0.05 < 0.69


■ 지니지수
1 - Σp²


#습도 
         테니스 유무
습도    아니요   예
높음     4       3     7
보통     1       6     7
         5       9     14

습도(높음)의 지니지수 
1 - pow(3/7, 2) - pow(4/7, 2) = 0.49    Out[37]: 0.489795918367347
습도(낮음)의 지니지수 
1 - pow(6/7, 2) - pow(1/7, 2) = 0.24    Out[38]: 0.24489795918367355

습도 지니 기대값
= (7/14) * 0.49 + (7/14) * 0.24 = 0.365   Out[39]: 0.365


#바람
        테니스 유무
바람    아니요   예
강함     3       3     6
약함     2       6     8
         5       9     14
바람(강함)의 지니지수 
1 - pow(3/6, 2) - pow(3/6, 2) = 0.5    Out[40]: 0.5
바람(약함)의 지니지수 
1 - pow(6/8, 2) - pow(2/8, 2) = 0.375   Out[41]: 0.375   

바람 지니 기대값
= (6/14)*0.5 + (8/14)*0.38 = 0.43     Out[42]: 0.4314285714285714

■ 지니기대값과 최적 변수: 모든 변수에 관해 지니 기대값을 계산하고 최소 기대값을 가진 변수를 최적 변수로 선택한다. 
  습도  바람
0.365 < 0.43  
-> 습도를 최적 변수로 선택한다. 

■ 
cf. 카이제곱, 자유도 1 
습도 카이제곱: 2.8      (p값 0.09정도)
바람 카이제곱: 0.94     (p값 0.4~5정도)

카이제곱과 자유도를 통해 p값을 찾아 p값이 최소값인 값을 찾아 최적변수로 선택한다. 
습도     바람
0.09 < 0.4~0.5


# cf. python에서는 카이제곱에 대한 method는 있으나 s
# cf. R은 table을 통해 교차테이블을 만들고, summary를 하면 자유도, p값, 분포도를 모두 출력해준다. 

# =============================================================================
#
# =============================================================================

import pandas as pd

#붓꽃 품종 분류
붓꽃의 꽃잎(petal), 꽃받침(sepal)의 폭, 길이를 측정하여 품종을 예측
붓꽃의 품종은 150종류 이상있고 크게 3가지로 분류된다.
setosa, versicolor, virginica

dataset = pd.read_csv("c:/data/iris.csv")
dataset.head()
x = dataset.drop('Name', axis=1)
y = dataset['Name']
x
y   #y: label값 

from sklearn.model_selection import train_test_split
x_train, x_test, y_train, y_test = train_test_split(x,y,test_size =0.20)
x_train
x_test
y_train
y_test 

from sklearn.tree import DecisionTreeClassifier
classifier = DecisionTreeClassifier()
classifier.fit(x_train, y_train)
y_pred = classifier.predict(x_test)
y_pred #품종정보 출력

from sklearn.metrics import classification_report
print(classification_report(y_test, y_pred))

#5.1, 3.5, 1.4, 0.2, Iris-setosa
classifier.predict([[5.1, 3.5, 1.4, 0.2,]])
Out[78]: array(['Iris-setosa'], dtype=object)
classifier.predict([[5.1, 3.5, 1.4, 0.2,]])[0]
Out[79]: 'Iris-setosa'

#5.9, 3.0, 5.1, 1.8
classifier.predict([[5.9,3.0,5.1,1.8]])
Out[80]: array(['Iris-virginica'], dtype=object)
classifier.predict([[5.9,3.0,5.1,1.8]])[0]
Out[81]: 'Iris-virginica'

#6.7, 3.1, 4.7, 1.5
classifier.predict([[6.7, 3.1, 4.7, 1.5]])[0]
Out[82]: array(['Iris-versicolor'], dtype=object)
classifier.predict([[6.7, 3.1, 4.7, 1.5]])[0]
Out[83]: 'Iris-versicolor'

#
classifier.predict([[6.7, 3.1, 4.7, 1.5]])[0]

classifier.score(x_train, y_train)  #학습 데이터셋 정확도
classifier.score(x_test, y_test)    #검증용 데이터셋 정확도

#dataset의 중요성 

#dataset 안에 있는 name열만 빼놓고 예측해야 함 
label = classifier.predict(dataset.ix[:,:4])
dataset.ix[:,:4] == pd.Series(label) #데이터형을 일치시키기 Series 
#label은 현재 numpy의 array형식 

#잘못된 예측된 값
dataset[dataset.ix[:,4] != pd.Series(label)]

#
label[dataset.ix[:,4] != pd.Series(label)]

##트레이닝 셋만 가지고 학습이 잘 되어있는지 확인하기    
#dataset[dataset.ix[:,4] != pd.Series(label)]
#
##데이터 셋을 트레이닝 데이터만 가지고 해보기 


#
from sklearn.model_selection import train_test_split
x_train, x_test, y_train, y_test = train_test_split(x,y,test_size =0.10)

from sklearn.tree import DecisionTreeClassifier
classifier = DecisionTreeClassifier()
classifier.fit(x_train, y_train)
y_pred = classifier.predict(x_test)

from sklearn.metrics import classification_report
print(classification_report(y_test, y_pred))


''' R 
iris = read.csv("c:/data/iris.csv")

#iris structure
str(iris)

#r에서는 주의해야할 사항
-문자로 불러들여 목표변수를 설정하면 에러가 난다. 

summary(iris)

#정규화 함수
normalize <- function(x){return((x-min(x))/(max(x)-min(x)))}
#정규화 함수를 통해서 범주화는 0~1에서 사이의 값으로 보여준다. - 단위를 맞추기 위해
#cf.학습이 잘 안되면 정규화 작업을 했는지 한번 확인해 본다.
normalize(c(1,2,3,4,5))
normalize(c(10,20,30,40,50))

normalize(c(12,24,35,47,59))

#컬럼에 대한 slicing, normalize함수를 이용해서 
iris_n <- as.data.frame(lapply(iris[1:4], normalize))

summary(iris_n)

#빈도값 확인: 각각의 건수를 확인하기 
table(iris$Name)

# training set:70 , test set:30으로 표본추출할 때 인덱싱이 필요하다. -> sample method 사용하기

#2: indexing 번호 1,2로 구성#replace=True -> 복원추출 #prob(0.7,0.3)
#cf. sample(3, nrow(iris), replace=True, prob=c(0.6, 0.3, 0.1))
set.seed(1234) #할 때마다 random값이 변화되는 것을 방지하기 위해 사용
iris_sample <- sample(2,nrow(iris), replace=TRUE,prob = c(0.7,0.3))
iris_training <-iris[iris_sample==1, 1:5]
iris_test <- iris[iris_sample==2, 1:5]

#붓꽃이 균일하게 잘 분리되어 있는지 확인하기
nrow(iris_training)
table(iris_training$Name)
table(iris_test$Name)



#의사결정트리 패키지 설치
install.packages("tree")
library(tree)
help(tree)

#step1 :tree형성(Growing tree)
#tree(종속변수~독립변수1+독립변수2+..., data=변수)
#tree(종속변수~.,data=변수) .은 독립변수를 다 이용하겠음
treemodel <- tree(Name~., data=iris_training)
treemodel 
#treemodel 출력값 -> 지니계수에 따르면 petal length가 가장 영향을 많이 끼치는 독립변수임 
    node), split, n, deviance, yval, (yprob)
    * denotes terminal node
    
    1) root 99 217.500 Iris-virginica ( 0.33333 0.32323 0.34343 )  
    2) PetalLength < 2.6 33   0.000 Iris-setosa ( 1.00000 0.00000 0.00000 ) *
      3) PetalLength > 2.6 66  91.430 Iris-virginica ( 0.00000 0.48485 0.51515 )  
    6) PetalWidth < 1.75 35  24.880 Iris-versicolor ( 0.00000 0.88571 0.11429 )  
    12) PetalLength < 4.9 30   8.769 Iris-versicolor ( 0.00000 0.96667 0.03333 )  
    24) SepalLength < 5.3 5   5.004 Iris-versicolor ( 0.00000 0.80000 0.20000 ) *
      25) SepalLength > 5.3 25   0.000 Iris-versicolor ( 0.00000 1.00000 0.00000 ) *
      13) PetalLength > 4.9 5   6.730 Iris-virginica ( 0.00000 0.40000 0.60000 ) *
      7) PetalWidth > 1.75 31   8.835 Iris-virginica ( 0.00000 0.03226 0.96774 )  
    14) SepalLength < 6.15 5   5.004 Iris-virginica ( 0.00000 0.20000 0.80000 ) *
      15) SepalLength > 6.15 26   0.000 Iris-virginica ( 0.00000 0.00000 1.00000 ) *

#의사결정트리 그림그리기
plot(treemodel)
text(treemodel)

#의사결정트리 스텝
step1 :tree형성(Growing tree) - 독립변수들로 키워나가는 작업을 한다. 너무 많이 키워나가면 과적합(overfitting)이 발생한다.
step2 :tree 가지치기(pruning tree) - 과적합(overfitting)을 해결하기위해서 가지치기를 한다. 
step3 :최종모형 


#>step2 :tree 가지치기(pruning tree) - 과적합(overfitting)을 해결하기위해서 가지치기를 한다.
#tree가지치기  #FUN=prune 제공해주는 함수
cv <- cv.tree(treemodel, FUN=prune.misclass)
cv

#가지치기한 cv에서  #$k 의 값을 $size값에 대응시켜본다. inf는 = 6/  0 = 4 / 1= 3/ 2=27 / 1=33
cv값 = $k값 / 노드수 = $size값 
cv(cost complexity parameter) 복답도계수의 값이 최소가 되는 노드수를 선택
plot(cv)
# size=3 인 이상이후로 부터는 node 수를 더 많이 만들어도 값이 같기 때문에 그 이상이 되는 노드수는 과적합이라고 할 수 있다.


#step3: 최종모형
p <- prune.misclass(treemodel, best=3) #best=3  -> 3개노드
plot(p)
text(p)

#예측값
tree_pred <- predict(p, iris_test, type="class")
expect <- tree_pred

#test값
actual <- iris_test$Name

#test값과 예측값과 비교하기
data.frame(actual, expect)

#library(caret): 오분류하기 위한 교차표를 쉽게 만들어 주는 라이브러리
install.packages("caret")
library(caret)

#교차표가 만들어짐 
confusionMatrix(expect, actual)
  #reference: 실제범주 / prediction: 예측범주 
  #Confusion Matrix and Statistics

                      Reference
    Prediction        Iris-setosa Iris-versicolor Iris-virginica
    Iris-setosa              17               0              0
    Iris-versicolor           0              18              1  #오분류값
    Iris-virginica            0               0             15

    
str(iris)
#factor값의 값 확인하기 
levels(iris$Name)
table(iris$Name)

# createDataPartition: 목표변수를 균일하게 training값, test값을 나누기 (단순히 의사결정트리에서만 사용되는 것이 아니라 kNN에서도 사용될 수 있음)
iris_idx <- createDataPartition(iris$Name, p=0.8, list=FALSE) #list=FALSE: factor형으로 뽑기 -> 이렇게 지정하지 않으면 list로 값을 출력한다.
train <- iris[iris_idx,]
str(train)
nrow(train)
table(train$Name)

#test set만들기
test <- iris[-iris_idx,]
str(test)
nrow(test)
table(test$Name)

#다시 의사결정트리 만들기
treemodel <- tree(Name~., data=test)
treemodel
  #node), split, n, deviance, yval, (yprob)
  * denotes terminal node
  
  1) root 30 65.920 Iris-setosa ( 0.33333 0.33333 0.33333 )  
  2) PetalLength < 2.95 10  0.000 Iris-setosa ( 1.00000 0.00000 0.00000 ) *
    3) PetalLength > 2.95 20 27.730 Iris-versicolor ( 0.00000 0.50000 0.50000 )  
  6) PetalLength < 4.8 9  0.000 Iris-versicolor ( 0.00000 1.00000 0.00000 ) *
    7) PetalLength > 4.8 11  6.702 Iris-virginica ( 0.00000 0.09091 0.90909 )  
  14) SepalLength < 6.35 5  5.004 Iris-virginica ( 0.00000 0.20000 0.80000 ) *
    15) SepalLength > 6.35 6  0.000 Iris-virginica ( 0.00000 0.00000 1.00000 ) *  

plot(treemodel)
text(treemodel)


#rpart
install.packages(rpart)
library(rpart)
iris_rpart <- rpart(Name~., data=train, control=rpart.control(minsplit = 2))  #minsplit = 2 최소 split은 2개로 
iris_rpart  

  n= 120 #120개
  
  node), split, n, loss, yval, (yprob)
  * denotes terminal node
  
  1) root 120 80 Iris-setosa (0.33333333 0.33333333 0.33333333)  
  2) PetalLength< 2.45 40  0 Iris-setosa (1.00000000 0.00000000 0.00000000) *
    3) PetalLength>=2.45 80 40 Iris-versicolor (0.00000000 0.50000000 0.50000000)  
  6) PetalWidth< 1.65 39  1 Iris-versicolor (0.00000000 0.97435897 0.02564103)  
  12) PetalLength< 5.35 38  0 Iris-versicolor (0.00000000 1.00000000 0.00000000) *
    13) PetalLength>=5.35 1  0 Iris-virginica (0.00000000 0.00000000 1.00000000) *
    7) PetalWidth>=1.65 41  2 Iris-virginica (0.00000000 0.04878049 0.95121951) *

install.packages("rpart.plot")
library(rpart.plot)

#의사결정트리 그리기  
#step1
rpart.plot(iris_rpart)


#step2: cv값을 구하는 것처럼 cptable을 통해서 cp값을 sp
iris_rpart$cptable

오분류가 최소값이 되는 살펴보면서 결정하도록 한다. 그러나 이때 split이 너무 과하지 않게 되도록 결정한다. 이때 cptable을  참고한다. 
cp가 가장 작은 것: 0.01 ->  nsplit=3  -> error:0.0375  #error값에 큰 차이가 나지 않음
cp가 0.0125 -> nsplit=2  -> error -> error: 0.0250 

iris_prune <- prune(iris_rpart, cp=0.0125) #cp값 0.125를 기준으로 가지치기 
rpart.plot(iris_prune)

expect <- predict(iris_prune, test, type="class")
actual <- test$Name

confusionMatrix(expect, actual)
  Confusion Matrix and Statistics
  
  Reference
  Prediction        Iris-setosa Iris-versicolor Iris-virginica
  Iris-setosa              10               0              0
  Iris-versicolor           0              10              3 #오분류
  Iris-virginica            0               0              7
  
install.packages("rattle")
library(rattle)
rpart <- rpart(Name~., data=iris, method="class")
#rpart
  n= 150 
  
  node), split, n, loss, yval, (yprob)
  * denotes terminal node
  
  1) root 150 100 Iris-setosa (0.33333333 0.33333333 0.33333333)  
  2) PetalLength< 2.45 50   0 Iris-setosa (1.00000000 0.00000000 0.00000000) *
    3) PetalLength>=2.45 100  50 Iris-versicolor (0.00000000 0.50000000 0.50000000)  
  6) PetalWidth< 1.75 54   5 Iris-versicolor (0.00000000 0.90740741 0.09259259) *
    7) PetalWidth>=1.75 46   1 Iris-virginica (0.00000000 0.02173913 0.97826087) *

fancyRpartPlot(rpart, main= "iris")

##Rpart는 "카트"라는 알고리즘을 사용한다.  -> 카트라는 의사결정의 분류가 있는데, cart와 rpart가 있다. 
#Rpart는 ANOVA(분산분석)를 사용한다. 
#tree로 학습을 시킬 때 느리거나 오류율이 높다면 Rpart를 사용하는 것이 좋다. Rpart가 처리속도가 더 빠르고 설명변수는 Rpart가 더 잘 짜져있음

#party의 장점 : 가지치기를 하지 않아도 됨(tree와 Rpart는 가지치기를 step2에서 꼭 해줘야 함)
#p값을 이용함(p-test을 이용해서 수행)
#제약:독립변수가 31개 이상은 되지 않음 
install.packages("party")
library(party)

partymodel = ctree(Name~., data=train)
plot(partymodel)

expect <- predict(partymodel, test)
actual <- test$Name
confusionMatrix(expect, actual)

#의사결정트리를 고를 때는 tree, Rpart, party모두 한번씩 고려해서 잘나온 값을 사용한다. 
#tree, Rpart: 지니계수를 이용
#party: p-value를 사용 
#CART는 지니계수를 사용해서 회귀를 함
#C.ZERO : 

#cf. Tree algorithms: ID3, C4.5, C5.0 and CART 
http://scikit-learn.org/stable/modules/tree.html


'''


# -*- coding: utf-8 -*-
"""
Created on Mon Oct 22 09:51:50 2018

@author: stu
"""
#Graphviz2.38
http://www.graphviz.org

물리적 주소
C:\Program Files (x86)\Graphviz2.38\bin

#시스템 환경변수에 path를 설정해야함 
내컴퓨터> 속성> 고급시스템설정> 환경변수 > path > 편집 > 시스템 변수값path: 맨끝 ;C:\Program Files (x86)\Graphviz2.38\bin

#Anaconda Prompt
pip install pydotplus

pip install graphviz


#spyder
import pydotplus
import graphviz
from sklearn.tree import export_graphviz 
from IPython.display import Image 

import pandas as pd

# =============================================================================
# # 10/22/Fri
# #붓꽃 품종 분류
# 붓꽃의 꽃잎(petal), 꽃받침(sepal)의 폭, 길이를 측정하여 품종을 예측
# 붓꽃의 품종은 150종류 이상있고 크게 3가지로 분류된다.
# setosa, versicolor, virginica
# 
# dataset = pd.read_csv("c:/data/iris.csv")
# dataset.head()
# x = dataset.drop('Name', axis=1)
# y = dataset['Name']
# x
# y   #y: label값 
# 
# from sklearn.model_selection import train_test_split
# x_train, x_test, y_train, y_test = train_test_split(x,y,test_size =0.20)
# x_train
# x_test
# y_train
# y_test 
# 
# from sklearn.tree import DecisionTreeClassifier
# classifier = DecisionTreeClassifier()
# classifier.fit(x_train, y_train)
# y_pred = classifier.predict(x_test)
# y_pred #품종정보 출력
# 
# from sklearn.metrics import classification_report
# print(classification_report(y_test, y_pred))
# =============================================================================

#위의모형에 대해 graph를 그리기
dot_data = export_graphviz(classifier, out_file=None, feature_names=['SepalLength', 'SepalWidth', 'PetalLength', 'PetalWidth'], class_names=['Iris-setosa', 'Iris-virginica', 'Iris-virsicolor'], filled=True, rounded =True, special_characters=True)
#feature_names에 대해서는 list 변수로 넣는다. (넣지않으면 x로 y나옴 )
#class_name에 (넣지 않으면 0,1,2.로 나옴)
#filled =True
#rounded= True, 그래프 모양 
#special_characters=True

graph = pydotplus.graph_from_dot_data(dot_data)
Image(graph.create_png())
Image(graph.create_jpg())

# PetalLength
# 의사결정트리에서 gini값이 기본임 
# 의사결정트리에서 criterion을 "entropy"로 , max_depth는 가지치기의 개수라고 생각하면 됨
classifier = DecisionTreeClassifier(criterion="entropy", max_depth=2) 
classifier.fit(x_train, y_train)

# =============================================================================

import pandas as pd
titanic = pd.read_csv("c:/data/titanic.csv")
titanic
titanic.head()

#survived: 목표변수 -> 생존여부 (0:사망, 1:생존) , 종속변수
#나머지 변수들: 독립변수 
#sklearn에 들어갈 독립변수들은 문자변수가 사용될 수 없고, 숫자변수만 사용가능
    #gender -> 0과 1로 변경작업 필요(on-hot-encoding)

#여성은 0, 남성은 1로 encoding (조건제어문 if를 사용하지 않고도 .map과 dictionary형을 통해 값을 바꿀 수 있다.)
titanic['gender'] = titanic.gender.map({'female':0, 'male':1})

#Null값 체크하기 - 모든 컬럼의
titanic.isnull()

#모든 NaN이 하나라도 있으면 True로 return함
titanic.isnull().any()

#NaN의 갯수 정보 보기 -> True에 해당하는 개수 정보 세기
titanic.isnull().sum()

# age의 NaN의 개수 
titanic.isnull().sum()['age']
titanic['age'].isnull().sum()

#전체 NaN의 sum
titanic.isnull().sum().sum()

#age의 NaN값만 뽑아내기 
titanic[titanic['age'].isnull()]

#NaN은 보통 중앙값으로 대체한다. (평균으로 대체하기도 함)

#fillna : Nan 채우기 fillna(값, inplace=True) #inplace=True는 바로 적용시키기 / 옵션을 선택하지 않으면 미리보기
titanic.age.fillna(titanic.age.median())
titanic.age.fillna(titanic.age.median(), inplace =True)

titanic['age'].isnull

#
titanic.head()

#embarked 탑승항구
C(Cherbourg), Q(Queenstown), S(Southampton)

#embarked 탑승항구의 변수를 dummy변수를 만들고자 할 때  - (on-hot-encoding사용: 0과 1로)
    #(on-hot-encoding: 독립변수가 종속변수에 영향을 주는지에 대해 체크할 때 하는 encoding) 
    #C(Cherbourg)이 들어간 것은 1, 아닌 것은 0
    #Q(Queenstown)이 들어간 것은 1, 아닌 것은 0
    #S(Southampton)이 들어간 것은 1, 아닌 것은 0
#pandas의 기능 ->위의 탑승학구가 세개의 독립변수로 만들어짐
embarked_dummies = pd.get_dummies(titanic.embarked, prefix="embarked")
embarked_dummies 
   #embarked_dummies의 세개의 변수가 생김 (dataframe으로 만들어짐)

embarked_dummies.drop(embarked_dummies.columns[0], axis=1, inplace=True)
embarked_dummies 

#기존의 emarked와 새 독립변수를 같은 dataframe에 합치기 #axis=0는 위아래로 합침
titanic = pd.concat([titanic, embarked_dummies], axis=1)

titanic 

#컬럼정보확인
titanic.columns

#영향을 주는 독립변수를 따로 모아서 데이터프레임을 별도로 지정하기 
feature_cols = ['pclass','gender','age','embarked_Q', 'embarked_S']
titanic[feature_cols]

x = titanic[feature_cols]
x.head()

#종속변수
y = titanic.survived

from sklearn.tree import DecisionTreeClassifier
 
model = DecisionTreeClassifier(criterion='gini', max_depth=3) #criterion='gini'는 default값 
model = DecisionTreeClassifier(criterion='entropy', max_depth=3) 
model.fit(x,y)

# 중요성이 높은 속성들 -> gender, plcass, age, embarked_S ( embarked_Q는 전혀 영향을 주지 않음) -> 다음의 순수로 의사결정트리 
pd.DataFrame({'feature': feature_cols, 'importance': model.feature_importances_})

classifier = DecisionTreeClassifier()
classifier.fit(x,y)

dot_data = export_graphviz(classifier, out_file=None, feature_names=['pclass','gender','age','embarked_Q', 'embarked_S'], class_names=[], filled=True, rounded =True, special_characters=True)


graph = pydotplus.graph_from_dot_data(dot_data)
Image(graph.create_png())


'''
#######R##############

iris = read.csv("c:/data/iris.csv")

#iris structure
str(iris)

#r에서는 주의해야할 사항
-문자로 불러들여 목표변수를 설정하면 에러가 난다. 

summary(iris)

#정규화 함수
normalize <- function(x){return((x-min(x))/(max(x)-min(x)))}
#정규화 함수를 통해서 범주화는 0~1에서 사이의 값으로 보여준다. - 단위를 맞추기 위해
#cf.학습이 잘 안되면 정규화 작업을 했는지 한번 확인해 본다.
normalize(c(1,2,3,4,5))
normalize(c(10,20,30,40,50))

normalize(c(12,24,35,47,59))

#컬럼에 대한 slicing, normalize함수를 이용해서 
iris_n <- as.data.frame(lapply(iris[1:4], normalize))

summary(iris_n)

#빈도값 확인: 각각의 건수를 확인하기 
table(iris$Name)

# training set:70 , test set:30으로 표본추출할 때 인덱싱이 필요하다. -> sample method 사용하기

#2: indexing 번호 1,2로 구성#replace=True -> 복원추출 #prob(0.7,0.3)
#cf. sample(3, nrow(iris), replace=True, prob=c(0.6, 0.3, 0.1))
set.seed(1234) #할 때마다 random값이 변화되는 것을 방지하기 위해 사용
iris_sample <- sample(2,nrow(iris), replace=TRUE,prob = c(0.7,0.3))
iris_training <-iris[iris_sample==1, 1:5]
iris_test <- iris[iris_sample==2, 1:5]

#붓꽃이 균일하게 잘 분리되어 있는지 확인하기
nrow(iris_training)
table(iris_training$Name)
table(iris_test$Name)



#의사결정트리 패키지 설치
install.packages("tree")
library(tree)
help(tree)

#step1 :tree형성(Growing tree)
#tree(종속변수~독립변수1+독립변수2+..., data=변수)
#tree(종속변수~.,data=변수) .은 독립변수를 다 이용하겠음
treemodel <- tree(Name~., data=iris_training)
treemodel 
#treemodel 출력값 -> 지니계수에 따르면 petal length가 가장 영향을 많이 끼치는 독립변수임 
    node), split, n, deviance, yval, (yprob)
    * denotes terminal node
    
    1) root 99 217.500 Iris-virginica ( 0.33333 0.32323 0.34343 )  
    2) PetalLength < 2.6 33   0.000 Iris-setosa ( 1.00000 0.00000 0.00000 ) *
      3) PetalLength > 2.6 66  91.430 Iris-virginica ( 0.00000 0.48485 0.51515 )  
    6) PetalWidth < 1.75 35  24.880 Iris-versicolor ( 0.00000 0.88571 0.11429 )  
    12) PetalLength < 4.9 30   8.769 Iris-versicolor ( 0.00000 0.96667 0.03333 )  
    24) SepalLength < 5.3 5   5.004 Iris-versicolor ( 0.00000 0.80000 0.20000 ) *
      25) SepalLength > 5.3 25   0.000 Iris-versicolor ( 0.00000 1.00000 0.00000 ) *
      13) PetalLength > 4.9 5   6.730 Iris-virginica ( 0.00000 0.40000 0.60000 ) *
      7) PetalWidth > 1.75 31   8.835 Iris-virginica ( 0.00000 0.03226 0.96774 )  
    14) SepalLength < 6.15 5   5.004 Iris-virginica ( 0.00000 0.20000 0.80000 ) *
      15) SepalLength > 6.15 26   0.000 Iris-virginica ( 0.00000 0.00000 1.00000 ) *

#의사결정트리 그림그리기
plot(treemodel)
text(treemodel)

#의사결정트리 스텝
step1 :tree형성(Growing tree) - 독립변수들로 키워나가는 작업을 한다. 너무 많이 키워나가면 과적합(overfitting)이 발생한다.
step2 :tree 가지치기(pruning tree) - 과적합(overfitting)을 해결하기위해서 가지치기를 한다. 
step3 :최종모형 


#>step2 :tree 가지치기(pruning tree) - 과적합(overfitting)을 해결하기위해서 가지치기를 한다.
#tree가지치기  #FUN=prune 제공해주는 함수
cv <- cv.tree(treemodel, FUN=prune.misclass)
cv

#가지치기한 cv에서  #$k 의 값을 $size값에 대응시켜본다. inf는 = 6/  0 = 4 / 1= 3/ 2=27 / 1=33
cv값 = $k값 / 노드수 = $size값 
cv(cost complexity parameter) 복답도계수의 값이 최소가 되는 노드수를 선택
plot(cv)
# size=3 인 이상이후로 부터는 node 수를 더 많이 만들어도 값이 같기 때문에 그 이상이 되는 노드수는 과적합이라고 할 수 있다.


#step3: 최종모형
p <- prune.misclass(treemodel, best=3) #best=3  -> 3개노드
plot(p)
text(p)

#예측값
tree_pred <- predict(p, iris_test, type="class")
expect <- tree_pred

#test값
actual <- iris_test$Name

#test값과 예측값과 비교하기
data.frame(actual, expect)

#library(caret): 오분류하기 위한 교차표를 쉽게 만들어 주는 라이브러리
install.packages("caret")
library(caret)

#교차표가 만들어짐 
confusionMatrix(expect, actual)
  #reference: 실제범주 / prediction: 예측범주 
  #Confusion Matrix and Statistics

                      Reference
    Prediction        Iris-setosa Iris-versicolor Iris-virginica
    Iris-setosa              17               0              0
    Iris-versicolor           0              18              1  #오분류값
    Iris-virginica            0               0             15

    
str(iris)
#factor값의 값 확인하기 
levels(iris$Name)
table(iris$Name)

# createDataPartition: 목표변수를 균일하게 training값, test값을 나누기 (단순히 의사결정트리에서만 사용되는 것이 아니라 kNN에서도 사용될 수 있음)
iris_idx <- createDataPartition(iris$Name, p=0.8, list=FALSE) #list=FALSE: factor형으로 뽑기 -> 이렇게 지정하지 않으면 list로 값을 출력한다.
train <- iris[iris_idx,]
str(train)
nrow(train)
table(train$Name)

#test set만들기
test <- iris[-iris_idx,]
str(test)
nrow(test)
table(test$Name)

#다시 의사결정트리 만들기
treemodel <- tree(Name~., data=test)
treemodel
  #node), split, n, deviance, yval, (yprob)
  * denotes terminal node
  
  1) root 30 65.920 Iris-setosa ( 0.33333 0.33333 0.33333 )  
  2) PetalLength < 2.95 10  0.000 Iris-setosa ( 1.00000 0.00000 0.00000 ) *
    3) PetalLength > 2.95 20 27.730 Iris-versicolor ( 0.00000 0.50000 0.50000 )  
  6) PetalLength < 4.8 9  0.000 Iris-versicolor ( 0.00000 1.00000 0.00000 ) *
    7) PetalLength > 4.8 11  6.702 Iris-virginica ( 0.00000 0.09091 0.90909 )  
  14) SepalLength < 6.35 5  5.004 Iris-virginica ( 0.00000 0.20000 0.80000 ) *
    15) SepalLength > 6.35 6  0.000 Iris-virginica ( 0.00000 0.00000 1.00000 ) *  

plot(treemodel)
text(treemodel)


#rpart
install.packages(rpart)
library(rpart)
iris_rpart <- rpart(Name~., data=train, control=rpart.control(minsplit = 2))  #minsplit = 2 최소 split은 2개로 
iris_rpart  

  n= 120 #120개
  
  node), split, n, loss, yval, (yprob)
  * denotes terminal node
  
  1) root 120 80 Iris-setosa (0.33333333 0.33333333 0.33333333)  
  2) PetalLength< 2.45 40  0 Iris-setosa (1.00000000 0.00000000 0.00000000) *
    3) PetalLength>=2.45 80 40 Iris-versicolor (0.00000000 0.50000000 0.50000000)  
  6) PetalWidth< 1.65 39  1 Iris-versicolor (0.00000000 0.97435897 0.02564103)  
  12) PetalLength< 5.35 38  0 Iris-versicolor (0.00000000 1.00000000 0.00000000) *
    13) PetalLength>=5.35 1  0 Iris-virginica (0.00000000 0.00000000 1.00000000) *
    7) PetalWidth>=1.65 41  2 Iris-virginica (0.00000000 0.04878049 0.95121951) *

install.packages("rpart.plot")
library(rpart.plot)

#의사결정트리 그리기  
#step1
rpart.plot(iris_rpart)


#step2: cv값을 구하는 것처럼 cptable을 통해서 cp값을 sp
iris_rpart$cptable

오분류가 최소값이 되는 살펴보면서 결정하도록 한다. 그러나 이때 split이 너무 과하지 않게 되도록 결정한다. 이때 cptable을  참고한다. 
cp가 가장 작은 것: 0.01 ->  nsplit=3  -> error:0.0375  #error값에 큰 차이가 나지 않음
cp가 0.0125 -> nsplit=2  -> error -> error: 0.0250 

iris_prune <- prune(iris_rpart, cp=0.0125) #cp값 0.125를 기준으로 가지치기 
rpart.plot(iris_prune)

expect <- predict(iris_prune, test, type="class")
actual <- test$Name

confusionMatrix(expect, actual)
  Confusion Matrix and Statistics
  
  Reference
  Prediction        Iris-setosa Iris-versicolor Iris-virginica
  Iris-setosa              10               0              0
  Iris-versicolor           0              10              3 #오분류
  Iris-virginica            0               0              7
  
install.packages("rattle")
library(rattle)
rpart <- rpart(Name~., data=iris, method="class")
#rpart
  n= 150 
  
  node), split, n, loss, yval, (yprob)
  * denotes terminal node
  
  1) root 150 100 Iris-setosa (0.33333333 0.33333333 0.33333333)  
  2) PetalLength< 2.45 50   0 Iris-setosa (1.00000000 0.00000000 0.00000000) *
    3) PetalLength>=2.45 100  50 Iris-versicolor (0.00000000 0.50000000 0.50000000)  
  6) PetalWidth< 1.75 54   5 Iris-versicolor (0.00000000 0.90740741 0.09259259) *
    7) PetalWidth>=1.75 46   1 Iris-virginica (0.00000000 0.02173913 0.97826087) *

fancyRpartPlot(rpart, main= "iris")

##Rpart는 "카트"라는 알고리즘을 사용한다.  -> 카트라는 의사결정의 분류가 있는데, cart와 rpart가 있다. 
#Rpart는 ANOVA(분산분석)를 사용한다. 
#tree로 학습을 시킬 때 느리거나 오류율이 높다면 Rpart를 사용하는 것이 좋다. Rpart가 처리속도가 더 빠르고 설명변수는 Rpart가 더 잘 짜져있음

#party의 장점 : 가지치기를 하지 않아도 됨(tree와 Rpart는 가지치기를 step2에서 꼭 해줘야 함)
#p값을 이용함(p-test을 이용해서 수행)
#제약:독립변수가 31개 이상은 되지 않음 
install.packages("party")
library(party)

partymodel = ctree(Name~., data=train)
plot(partymodel)

expect <- predict(partymodel, test[1:4]) #종속변수를 넣지 말아야하므로 test[1:]
actual <- test$Name
confusionMatrix(expect, actual)

#의사결정트리를 고를 때는 tree, Rpart, party모두 한번씩 고려해서 잘나온 값을 사용한다. 
#tree, Rpart: 지니계수를 이용
#party: p-value를 사용 
#CART는 지니계수를 사용해서 회귀를 함
#C.ZERO : 

#cf. Tree algorithms: ID3, C4.5, C5.0 and CART 
http://scikit-learn.org/stable/modules/tree.html
'''


# -*- coding: utf-8 -*-
"""
Created on Wed Oct 24 13:49:22 2018

@author: stu
"""

> R 
# =============================================================================
'''2018. 10. 24. Wed
지도학습: 목표변수(종속변수)가 있어서 이에 대한 labeling을 하고 이에 대해 분류함
비지도학습: 독립변수들만 있는 상태에서 cluster하고자 함 '''

''' 오늘의 학습주제: K-means '''

군집합
- 데이터 클러스터(cluster, 유사한 아이템의 그룹)로 자동 분리하는 비지도학습의 머신러닝이다. (unsupervised learning)
- 군집화는 데이터 안에서 발견되는 자연스런 그룹에 대한 통찰력을 제공
- 클러스터 안에 있는 아이템들은 서로 아주 비슷해야 하지만 클러스터 밖에 있는 아이템과 아주 달라야 한다. 
- 자율분류로 언급되는 것은 레이블이 없는 예시를 분류하기 때문이다. 

군집화 활용 범위
- 마케팅 캠페인을 위해 유사한 인구 통계나 구매 패턴을 가진 그룹으로 고객을 세분화
- 알고 있는 클러스터 밖의 사용패턴을 찾아 무단 네트워크 침입과 같은 이상 행동을 탐지 (보안분야)
- 유사한 값을 갖는 특징을 적은 개수의 동질적인 범주로 그룹핑해 초대형 데이터셋을 단순화 할 수 있다.

#cf. kNN: k-다수결의 문제를 가짐, k값을 가지고 성능을 조정함

k-means algorithm
# step1. k: 그룹으로 나누어야 할 군집의 개수 (거리계산을 통해 군집 개수에 따라 나눔)
# step2. means 각 군집들의 평균으로 위치를 위동
# step3. 다시 이동한 위치에서 거리 계산을 통해 군집을 다시 나눔 
# step4. 각 군집들의 평균으로 위치를 이동 
# --------------------------------------------
# step5. 새로운 데이터가 들어온다고 가정하기 
# step6. 새로운 데이터의 거리 계산을 통해 군집을 분류함
# step7. 새로운 데이터를 반영한 거리의 군집 평균인 위치의 중심이동을 함 
# ......
# 이를 반복하면서 각각의 그룹을 만든다. 
#cf. 거리의 값이 같을 경우 분류시 힘들다. -> 문제점을 가짐 
- n개의 예시를 k개의 클러스터 중 하나에 할당하는데 이때 k는 사전에 결정되는 수 
- 클러스터 내의 차이를 최소화하고 클러스터 간의 차이는 최대화한다. 

적당한 k값은? 
k = sqrt(n/2)
# cf. 목표하는 개수를 생각하면서 k값을 돌려보는 것도 나쁘지 않다.

c <- c(3,4,1,5,7,9,5,4,6,8,4,5,9,8,7,8,6,7,2,1)
row <- c("A", "B", "C","D","E","F","G","H","I","J")
col <- c("X", "Y")

data <- matrix(c, nrow=10, ncol=2, byrow=TRUE, dimnames = list(row,col))
data

plot(data)

#목표변수가 없는 상황에서 2개로 군집화하기
library(stats)

#2개로 
km <- kmeans(data, 2)
km
    # > km
    # K-means clustering with 2 clusters of sizes 5, 5
    # 
    # Cluster means:
    #   X   Y
    # 1 7 8.0
    # 2 3 3.8
    # 
    # Clustering vector:
    #   A B C D E F G H I J 
    #   2 2 1 2 1 2 1 1 1 2 
    # 
    # Within cluster sum of squares by cluster:
    #   [1]  8.0 20.8
    # (between_SS / total_SS =  74.5 %)
    # 
    # Available components:
    #   
    #   [1] "cluster"      "centers"      "totss"        "withinss"     "tot.withinss" "betweenss"    "size"         "iter"         "ifault"      

#평균에 대한 마지막 위치정보
km$centers
#
km$cluster
#군집화한 data 정보를 기존의 정보에 붙여넣기
cbind(data, km$cluster)

#point찍기
plot(data)
points(km$centers[,1],km$centers[,2], pch=3, cex=1.5, lwd=2)


#############################
grade <- read.csv("c:/data/academy.csv")

수학과 영어
math <- grade$수학점수
english <- grade$영어점수

c <- cbind(math, english)

#2개로 분류하기
km <- kmeans(c, 2)
km$cluster

cbind(c, km$cluster)

plot(c)
points(km$centers[,1],km$centers[,2], pch=15, cex=1.5, lwd=1)

#4개로 분류하기
km <- kmeans(c, 4)


#############################
#쌤이랑 같이하기
academy <- read.csv("c:/data/academy.csv")
academy2 <- academy[,c(3,4)]
plot(academy2)

km <- kmeans(academy2, 4)
points(km$centers[,1], km$centers[,2], pch=3, cex=1.5, lwd=2)

km$cluster

##############
군집화 시각화
install.packages("factoextra")
library(factoextra)
#k-menas를 가지고 군집화 그림을 그림 
fviz_cluster(km, data=academy2, stand=F, ellipse.type = "t", geom="point")
help(fviz_cluster)
fviz_cluster(km, data=academy2, stand=F, ellipse.type = "convex", geom="point")


# =============================================================================
Python> 


from sklearn.cluster import KMeans
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt

iris = pd.read_csv("c:\data\iris.csv")

#산점도를 통해서 흩어져 있는 정도 보기
#분류하고자 할 때 무엇을 가지고 분류해야할 지 선택할 때 산점도를 이용하도록 한다. 
plt.scatter(iris.SepalLength, iris.SepalWidth, s=40)
plt.title("Sepal")

plt.scatter(iris.PetalLength, iris.PetalWidth, s=40)
plt.title("Petal")

# 3가지 분류로 분류하기
model = KMeans(n_clusters=3)
#데이터를 가지고 학습시키기(이름빼고)
model.fit(iris.ix[:,0:4])
#레벨확인하기-> 3개 레벨로 만들어져 있음 
model.labels_
#Out[17]: 
#array([1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
#       1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
#       1, 1, 1, 1, 1, 1, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
#       0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
#       0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 2, 2, 2, 2, 0, 2, 2, 2,
#       2, 2, 2, 0, 0, 2, 2, 2, 2, 0, 2, 0, 2, 0, 2, 2, 0, 0, 2, 2, 2, 2,
#       2, 0, 2, 2, 2, 2, 0, 2, 2, 2, 0, 2, 2, 2, 0, 2, 2, 0])

colormap = np.array(['red','blue','black'])
plt.scatter(iris.PetalLength, iris.PetalWidth, c=colormap[model.labels_], s=40) #color: 3가지색으로 분류되어있기 때문에 c=colormap[model.labels_]
plt.title("K Means Classification")



model.labels_

# kMeans에 init='k-means++': k값을 3개라 하면 어디에 표시자를 달것인가? 가장 첫번째에 데이터에 달고, 다음 두번째 데이터에 달고... 등
model.labels_



# =============================================================================
academy 데이터가지고 KMeans

academy = pd.read_csv("c:/data/academy.csv")

from pandas import Series, DataFrame
grade = DataFrame([academy["수학점수"], academy["영어점수"]])
grade = grade.T


#plt.scatter(academy.수학점수, academy.영어점수)
plt.scatter(grade.수학점수, grade.영어점수)

# k=4
#모델만들기
model = KMeans(n_clusters=4)
model.fit(grade.ix[:,0:1])
model.labels_

#scatter plot 그리기
colormap = np.array(['red','blue','green','black'])
plt.scatter(grade.수학점수, grade.영어점수, c=colormap[model.labels_], s=10) 
plt.title("K Means Classification")


# k=2
model = KMeans(n_clusters=2)
model.fit(grade.ix[:,0:1])

colormap = np.array(['red','blue'])
plt.scatter(grade.수학점수, grade.영어점수, c=colormap[model.labels_], s=10) 
plt.title("K Means Classification")


# =============================================================================
academy = pd.read_csv("c:/data/academy.csv")

academy.columns

model = KMeans(n_clusters=4)
model.fit(academy.ix[:,2:4])
model.labels_
#모델의 중심좌표 -> array형식으로 출력됨 
model.cluster_centers_

#
colormap = np.array(['red','blue','black','yellow'])
plt.scatter(academy.ix[:,2], academy.ix[:,3], c=colormap[model.labels_], s=30) 
centers = pd.DataFrame(model.cluster_centers_)
plt.scatter(centers.ix[:,0], centers.ix[:,1], s=50, marker='D', c='g')
plt.title("K Means Classification")
plt.show()

#k값을 변화주어 시뮬레이션 돌리기
ks = range(1,10)
inertia = []
for k in ks:
    model = KMeans(n_clusters=k)
    model.fit(academy.ix[:,2:4])
    inertia.append(model.inertia_)

inertia 
#k=1 일때 값은 커져 있음 그러다가 점점점 더디게 줄어듦
#Out[68]: 
#[24978.596153846152,
# 11716.462519936204,
# 8097.708683473389,
# 5145.44890077243,
# 3659.014880952381,
# 2445.419047619048,
# 1892.002380952381,
# 1493.169047619048,
# 1266.2690476190478]
# inertia가 작은 것이 응집도가 좋은 것이라 할 수 있다. 

plt.plot(ks, inertia, '-o')
plt.xlabel("number of cluster K")
plt.ylabel("inertia")
plt.xticks(ks)
plt.show()

#k값(그룹의 개수를)을 결정할 때 graph가 확 꺾여지는 지점으로 잡으면 좋다. (위의 데이터에서는 3-4으로 k값을 넣어서 비교해 본다.)

inertia value 
- 각 중심점에서 군집의 데이터간의 거리를 합산한 것으로 군집의 응집도를 나타내는 값이다. 
- 이 값이 작을수록 응집도가 높게 군집화가 잘 되었다고 평가한다. 




# -*- coding: utf-8 -*-
"""
Created on Mon Oct 29 09:50:48 2018

@author: stu
"""

▣ 연관성 분석
두개의 변수가 서로 독립적인가 아니면 이들간에 어떠한 연관성이 존재하는가를 파악하는 분석방법

명목, 서열(질적자료): 교차분석(카이스퀘어검정)
등간, 비율(양적자료): 상관분석(피어슨상관분석)

■ 공분산(covariance)
- 두 변수가 얼마나 함께 변하는지를 측정
- cov(x, y) > 0 : x와 y의 변화가 같은 방향으로 변화가 된다.
즉, 한 변수가 커질 때 다른 변수가 함께 커지거나 한 변수가 작아질 때 다른 변수가 함께 작아지는 경우는 변화의 방향이 같다. 
- cov(x, y) < 0 : x와 y의 변화가 다른 방향으로 변화가 된다. 
한 변수가 커질 때 다른 변수가 작아지거나 한 변수가 작아질 때 다른 변수가 커지는 경우는 변화의 방향이 다르다는 의미가 된다.
- cov(x, y) = 0: 두 변수의 값이 서로 상관없이 움직일 경우 공분산은 0이다. 

- 모집단의 공분산: N
                [(개별 x측정치 - x의 평균) * (개별 y측정치 - y의 평균)]합
공분산(x, y) = ----------------------------------------------------------
                                    N    
    
- 표본의 공분산 : n-1
                [(개별 x측정치 - x의 평균) * (개별 y측정치 - y의 평균)]합
공분산(x, y) = ----------------------------------------------------------
                                    n - 1   
             Σ((x-x평균) *(y-y평균))
cov(x,y) = ---------------------------- 
                    n - 1
                    
                    
## R>>>>>>>>>>>>>>
x <- c(184, 170, 180)
y <- c(85, 70, 82)

> (((184-178)*(85-79))+((170-178)*(70-79))+((180-178)*(82-79)))/2
[1] 57

> cov(x,y)
[1] 57

## python >>>>>>>>>> 
x = [184, 170, 180]
y = [85, 70, 82]

import numpy as np
np.mean(x)
np.mean(y)

# numpy를 이용하기 때문에 행렬을 통해 값이 뽑아지기 때문에 필요한 행렬의 값을 같이 적어야 한다.
np.cov(x,y)[0][1]


import pandas as pd
df= pd.concat([pd.DataFrame(x), pd.DataFrame(y)], axis=1)
df
df.columns = ['x','y']
df['x'].cov(df['y'])

■ 상관계수: 각각의 데이터에 따른 단위가 다르기 때문에 공분산을 표준화 시키는 작업이 필요하다. 따라서 상관계수를 구해야한다. 

▣ 상관분석(correlation analysis)
- 변수들 간의 연관성을 파악하기 위해 사용하는 분석기법중의 하나로 변수간의 선형관계 정도로를 분석하는 통계기법이다. 
- 두 변수 사이의 관련성을 파악하는 방법

■ 상관계수
- 두 변수간의 관련성의 정도를 의미 
- 계산방법: 피어슨 상관계수, 스피어만 상관계수(서열척도의 상관분석을 해야할 때), 겐달 순위상관계수
- 상관계수값이 크면 데이터간의 관계가 존재한다는 의미
- 한쪽 값이 커질 때 다른 쪽 값이 커지는 정도 
- 상관 -1 <= r <= 1
        공분산(x,y)    
- r = -------------------------- 
        루트(x분산 * y분산) 
        
cf. 루트(x분산 * y분산)-> 표준편차
                Σ(x-x의 평균)*(y-y의 평균)
                --------------------------
                            n-1
  = -------------------------------------------------
      루트((Σ(x-x의 평균)제곱)  * (Σ(y-y의 평균)제곱))

  
### python
import math
(((184-178)*(85-79))+((170-178)*(70-79))+((180-178)*(82-79)))/math.sqrt(((184-178)**2+(170-178)**2+(180-178)**2)*((85-79)**2+(70-79)**2+(82-79)**2))

df['x'].corr(df['y'])


# =============================================================================
#  [문제] 학생 10명의 키와 몸무게를 측정한 자료이다. 자료를 분석하여 키와 몸무게의 선형관계를 나타내는 상관관계를 구하고, 그 유의성을 유의수준(α) 0.05에서 검정하세요. 
# height <- c(176, 172, 182, 160, 163, 165, 168, 163, 182, 182)
# weight <- c(72, 72, 70, 43, 48, 54, 51, 52, 73, 88)
# =============================================================================
# R>>>>
height <- c(176, 172, 182, 160, 163, 165, 168, 163, 182, 182)
weight <- c(72, 72, 70, 43, 48, 54, 51, 52, 73, 88)

mean(height)
mean(weight)

plot(height, weight)
cov(height, weight)
cor(height, weight)

▣ 가설검정
- Ho (귀무가설): 키와 몸무게 간에 선형관계가 없다(키와 몸무게의 상관계수는 0이다)
- H₁ (대립가설, 연구가설): 키와 몸무게 간에 선형관계가 있다.(키와 몸무게의 상관계수는 0이 아니다)


- 유의수준(α) 0.05
- t분포의 자유도 n-2
- df = 10-2 =8
                      /           \
                     /             \
                    /               \
                   /                 \
                  /                   \  
                 /                     \
                /                       \
               /                         \
              /                           \
             /                             \
            /                               \
           /                                 \
          /                                   \
-------------|-----------------------------|-------------
        t(α/2,n-2)                    t(α/2,n-2)        cf. α/2: 양쪽 두개 중 한 부분이기 때문에 2로 나눈다.
        t(0.0258, 8)                  t(0.0258, 8)
        2.306                         2.306

t = r * sqrt((n-2)/1-r²) 
  = 0.91*sqrt(8/(1-((0.91)^2)))
  = 6.207
  
■ 결과해석
- 유의수준(α) 0.05로 하여 검정한 결과 검정통계량 t값(6.207)이 우측 임계치(2.306)보다 크므로 귀무가설을 기각하고 대립가설을 채택한다. 
- 즉, 키와 몸무게의 상관계수 0.91은 5% 유의수준에서 검정한 결과 통계적으로 유의하다. 

■ R에서 제공하는 t검정 
cor.test(height, weight, method ="pearson", alternative = "two.sided") 
#기본값이 양측검정임(alternative = "two.sided")
help(cor.test)

# Pearson's product-moment correlation
# 
# data:  height and weight
# t = 6.193, df = 8, p-value = 0.0002614
# alternative hypothesis: true correlation is not equal to 0
# 95 percent confidence interval:
# 0.6553010 0.9787161
# sample estimates:
# cor 
# 0.909622 

#
cor.test(height, weight, method ="pearson", alternative = "two.sided") 
cor.test(height, weight, method ="pearson", alternative="greater")
cor.test(height, weight, method ="pearson", alternative="less")

#alternative
two.sided : x,y집단이 서로 같은지 비교
less : x집단이 y집단보다 작은지 비교(x less than y)
greater: x집단이 y집단보다 큰지 비교(x greater than y)

#method
method = pearson, kendall, spearman

□ 양측검정을 하더라도 r에서 p-value는 단측검정의 p-value값으로 출력한다. 

■ Python에서 제공하는 t검정 (pearsonr)
height = [176, 172, 182, 160, 163, 165, 168, 163, 182, 182]
weight= [72, 72, 70, 43, 48, 54, 51, 52, 73, 88]

from scipy.stats import pearsonr

#
pearsonr(height, weight)
Out[44]: (0.9096220430530334, 0.00026141557536073885) -> 상관계수, p-value

□ 양측검증은 양측에 p-value가 있기 때문에 p-value값을 유의수준 값과 비교한다.
-> 이 경우 p-value값이 유의수준 값보다 작기 때문에 귀무가설을 기각하고 대립가설을 채택한다. 
-> pvalue = 0.0002614이기 때문에 유의수준 0.05라고 하고
0.0002614 < 0.05 가 되어 귀무가설을 기각하고 대립가설을 채택한다.

□ 단측검증 p-value를 유의수준 값과 바로 비교하면 된다.  


▣ 회귀분석(Regression )
인과관계를 분석하는 방법

□ 인과관계
- 어떤 변수가 어떤 변수에게 어떤 영향을 주는지를 판단 
□ 상관관계
- 변수와 변수가 어떤 연관이 있는지, 방향성을 나타낸다. 

■ 인과관계 조건
1. x가 변할 때 y도 변한다.
    교육연수(독립변수) - 생활만족도(종속변수)
2. 시간적으로 선행되어야 한다.(독립변수가 종속변수보다 선행되어야 한다.)
    교육연수가 먼저 선행되어야 한다.
3. 외생변수를 통제(다른 요인들을 통제하고 인과관계를 분석)
    교육연수 -> 생활만족도 
        다른요인(성별, 직업, 거주지, 근무연수 등)

■ 회귀분석(regression)
독립변수 -> 종속변수 
광고비 -> 매출액
매출액 -> 광고비
담배량 -> 폐암
배기량 -> 연료소비량 
온도 -> 아이스크림 판매량

■ 독립변수의 수
1개 일때: 단순회귀분석
2개 이상일 때: 다중회귀분석 

■ 독립변수의 척도 
등간, 비율: 일반회귀분석
명목, 서열: 가변수회귀분석(dummy변수회귀분석: on-hot encoding)

■ 독립변수와 종속변수관계
- 선형
- 비선형

1. 회귀분석을 할때 산점도를 그려보는 것도 좋다. 
x가 커지면서 y도 커진다.(선형)
x가 커지면서 y도 작아진다.(선형)
x가 커지면서 y도 커지다가 작아진다. (비선형) 

2. 모델 선을 그려본다.
최소제곱법을 이용해서 선을 그린다. 
y = ax+b (일차원방정식)
y = 종속변수
x = 독립변수
a = 회귀계수(기울기)  *가장 중요한 값임 
b = 절편(y의 시작점)

직선의 방정식의 기울기를 구하려면 
y = ax      a = y/x

편차제곱의 합 
    Σ(y-y평균)^2
= -----------------
    Σ(x-x평균)^2

            Σ((x-x평균)*(y-y평균))          x와 y 공분산 
기울기 = ---------------------------- = ------------------
                Σ(x-x평균)^2                   x분산      
            cov(x,y)
       = -----------------
            var(x)

b = y의평균 - 기울기*x의 평균 

height <- c(176, 172, 182, 160, 163, 165, 168, 163, 182, 182)
weight <- c(72, 72, 70, 43, 48, 54, 51, 52, 73, 88)

키 185일 때 몸무게는?
  
y = ax + b

a: 기울기
cov(height, weight)/ var(height) = 1.51
      cov(height, weight)
a = -----------------------
        var(heihgt)

y = mean(weihgt)  
y <-mean(weight)
x = mean(height)
x <-mean(height)
b = y - a * x  
#b <- y-1.51*x
b= mean(weight) - ((cov(height,weight)/var(height))) *mean(height)
> b
[1] -197.9022

기울기를 줄이기 위해 미분을 해야함 -> 편미분 필요 

■ 예측모형 만들기(linear model)
□ 단일회귀분석 
lm(weight~height) #linear model lm(종속변수~독립변수)

# Call:
#   lm(formula = weight ~ height)
# 
# Coefficients:
#   (Intercept)       height  
# -197.902        1.519  

기울기: 1.519  
y = 1.519*185 + (-197.902)
> y
[1] 83.113

□ 다중회귀분석 
lm(weihgt~height+독립변수2+독립변수3+....)

# =============================================================================

##R >>>>>>>>>
#score파일: txt파일 이기때문에 read.table을 사용하고, 나머지 옵션을 사용함
score <- read.table("c:/data/score.txt",header=T, sep=",")
score

#앞에 score$를 계속 사용하지 않기 위해 attach를 사용할 수 있다. 
attach(score)

□ 단일회귀분석 
#공분산 [1] 70.6
cov(IQ,성적)

#상관계수 [1] 0.9102242
cov(IQ, 성적)/ (sd(IQ)*sd(성적))
cor(IQ,성적)

#회귀분석
l <- lm(성적~IQ)
# Call:
#   lm(formula = 성적 ~ IQ)
# 
# Coefficients:
#   (Intercept)           IQ  
# -5.2918       0.6714  

IQ가 130일때 시험성적 예측?
# -5.2918: 절편 / 0.6714: 기울기
성적 = 130*0.6714+(-5.2918)
     = 81.9902 

#산점도와 회귀라인 그리기  
plot(IQ, 성적, pch=20, col="red")
abline(l, col="blue")
#cf. 신경망에서 abline을 산점도에 맞게 fitting되도록 오차범위를 줄이는 것이 중요하다. -> 경사하강법 

#간단하게 절편과 기울기보기 
coef(l)

#성적과 다니는 학원의수의 상관관계
lm(성적~다니는학원수)

plot(다니는학원수, 성적, pch=20, col="red")
abline(lm(성적~다니는학원수), col="blue")

□ 다중회귀분석 
lm(성적~IQ+다니는학원수+게임하는시간+TV시청시간)
# Call:
#   lm(formula = 성적 ~ IQ + 다니는학원수 + 게임하는시간 + TV시청시간)
# 
# Coefficients:
#   (Intercept)            IQ  다니는학원수  게임하는시간    TV시청시간  
# 23.2992        0.4684        0.7179       -0.8390       -1.3854  

y = ax1 + bx2 + cx3+ dx4 + z
= (135*0.4684)+(5*0.7919)+(1*-0.8390)+(1*-1.3854)+23.2992
= 88.2683

 
# =============================================================================
#python >>>>>>>>>
전기 생산금액과 전기사용량의 상관관계 
from scipy import stats

#월별 전기 생산금액(억원)
x = [3.52,2.58,3.31,4.07,4.62,3.98,4.29,4.83,3.71,4.61,3.90,3.20]
#월별 전기사용량(백만kwh)
y = [2.48,2.27,2.47,2.77,2.98,3.05,3.18,3.46,3.03,3.25,2.67,2.53]

#단순(선형)회귀분석 (x:독립변수, y종속변수)
stats.linregress(독립변수,종속변수)
stats.linregress(x,y)
# Out[54]: LinregressResult(slope=0.4956032360182905, intercept=0.9195814280689418, rvalue=0.8929235125385305, pvalue=9.238421943157891e-05, stderr=0.07901935226531728)

#새로운 변수들로 뽑아내기 
slope, intercept, r_value, p_value, stderr = stats.linregress(x,y)
- slope: 기울기
- intercept: 절편
- r_value: 상관계수
- p_value: p값
- stderr: error에 대한 표준편차(관측값과 abline의 오차률에 대한 표준편차)

# 생산금액: 4억원이라 할 때 사용량은?
y = 4*slope + intercept
y  
Out[61]: 2.901994372142104

# 가설검정
Ho(귀무가설): 전기생산금액과 전기사용량은 상관관계가 없다.
H₁(대립가설): 전기생상금액과 전기사용량은 상관관계가 있다. 

유의수준(α) 
p-value(9.238421943157891e-05)가 유의수준 값보다 (0.05)보다 작으므로 귀무가설을 기각하고 대립가설을 채택한다. 
#cf. p-value: 양측검정값  

#plot그리기
import matplotlib.pyplot as plt 

#월별 전기 생산금액(억원)
x = [3.52,2.58,3.31,4.07,4.62,3.98,4.29,4.83,3.71,4.61,3.90,3.20]
#월별 전기사용량(백만kwh)
y = [2.48,2.27,2.47,2.77,2.98,3.05,3.18,3.46,3.03,3.25,2.67,2.53]

#산점도와 회귀선 그리기 
plt.scatter(x,y)
#x변수를 array값으로 만들기
x1 = np.array(x)
plt.plot(x1, slope*x1 + intercept, c="red", linewidth="0.5")

# =============================================================================
#ozone <- read.csv("c:/data/ozone.csv")
#
#ozone.nafill 
#
#
#ozone과 temp관계
#attach(Ozone)
#
##Ozone의 na값 평균으로 대체 
#Ozone1 <- replace(Ozone, is.na(Ozone), mean(Ozone, na.rm=T))
#
##Temp의 na값 평균으로 대체
#Temp1 <- replace(Temp, is.na(Temp), mean(Temp, na.rm=T))
#
#
## na 값을 평균값으로 치환했을 때 
#l1<-lm(Ozone1~Temp1)
#
#plot(Ozone1,Temp1, pch=20, col="red")
#abline(l1, col="blue")
#
#
##
#l <-lm(Ozone~Temp)
#
#plot(Ozone1,Temp1, pch=20, col="red")
#abline(l1, col="blue")

# =============================================================================
# python >>>>>>>
□ 단일회귀분석
import pandas as pd

df = pd.read_csv("c:/data/ozone.csv")
df.head()

df.count()

#df에 열단위의 na의 건수 세기(컬럼별 결측값 개수)
df.isnull().sum()

#행단위로 na의 건수 보기(행단위로 결측값 개수)
df.isnull().sum(1)

#결측값을 제거한 데이터 만들기
df2 = df.dropna(axis=0)
df2.isnull().sum()

x = df2["Temp"].values
y = df2["Ozone"].values

stats.linregress(x,y)

#
귀무가설: 오존과 온도는 상관관계가 없다. (온도가 오존에 영향을 주지 않는다.)
대립가설: 오존과 온도는 상관관계가 있다. (온도가 오존에 영향을 준다.)

#유의수준을 0.05라고 가정할때 
p-value(1.552677229392932e-17)는 0.05보다 작기 때문에 귀무가설을 기각하고 대립가설을 채택한다. 

#cf-na를 0로 했을 때 
df['Ozone'].fillna(0, inplace=True)
df['Temp'].fillna(0, inplace = True)

slope, intercept, rvalue, pvalue, stderr = stats.linregress(x,y)

#온도가 화씨 80도 일때 오존량 예측?
y = slope*x + intercept 
  = slope*80 + intercept 
  = 47.48272006175401


# =============================================================================
# python >>>>>>>
□ 다중회귀분석
#score파일을 encoding을 utf-8로 바꿔 저장하기

score = pd.read_csv("c:/data/score.txt")

stats.linregress(score.ix[:,2], score['성적'])

slope, intercept, rvalue, pvalue, stderr = stats.linregress(score.ix[:,2], score['성적'])

#회귀모형 만들기  - 다중회귀모형
from sklearn import linear_model

#모델 만들기
reg = linear_model.LinearRegression()

#fit하기  (다중회귀분석)
reg.fit(score.ix[:,2:6], score['성적'])

# 각 변수에 대한 기울기(reg.coef_) , 절편(intercept_) 확인하기
print("절편: \n", reg.intercept_)
print("기울기: \n", reg.coef_)



# -*- coding: utf-8 -*-
"""
Created on Tue Oct 30 10:09:14 2018

@author: stu
"""

▣ 회귀분석(Regression)
- 독립변수(X)와 종속변수(Y)의 관계식을 구하는 기법 
- 독립변수(영향을 주는 변수)가 한 단위 증가할 때 종속변수(영향을 받는 변수)가 얼마나 영향을 받는지 분석하는 방법
- 회귀식(y=ax+b), 회귀계수(a)

■ 단순회귀분석: 독립변수가 1개인 회귀모형 
예) 기업의 광고집행액(X)을 이용하여 그 기업의 매출액(Y)을 예측하는 모형

■ 다중회귀분석: 독립변수가 2개 이상인 회귀모형
예) 학생의 학원 수(X1)과 하루 평균학습시간(X2)을 이용하여 그 학생의 성적(Y)을 예측하는 모형

- 회귀분석은 대상 변수들은 양적자료(등간, 비율)

          Y값의 증가량
기울기 = ---------------
          X값의 증가량

X: 독립변수
Y: 종속변수

X값에 따라 Y값이 달라진다. 

회귀식 
Y = aX + b
a = 회귀계수, 기울기
b = Y의 절편 

        (X-X평균)(Y-Y평균)의 합          (x,y)의 공분산
a =  ---------------------------  =   ------------------
        (X-X평균)제곱의 합                (x)의 분산

b = y의평균 - (기울기*x의평균)

x =2, 4, 6, 8
y = 71, 83, 91, 97

#python >>>>
x =[2, 4, 6, 8]
y = [71, 83, 91, 97]

import numpy as np
import pandas as pd
np.mean(x)
Out[6]: 5.0

np.mean(y)
Out[7]: 85.5

a = ((2-5)*(71-85.5) + (4-5)*(83-85.5) + (6-5)*(91-85.5) + (8-5)*(97-85.5))/((2-5)**2+(4-5)**2+(6-5)**2+(8-5)**2)
a 
Out[23]: 4.3

b = 85.5 -(4.3*5)
b 
Out[25]: 64.0

3시간 공부했을 때 성적을 예측?
y = 43.3*3-64
y
Out[27]: 65.899

# =============================================================================
#>> method를 이용해서 구해보기
import math

df = pd.concat([pd.DataFrame(x), pd.DataFrame(y)], axis=1)
df.columns = ['x','y']

df['x'].corr(df['y'])

from scipy import stats

stats.linregress(x,y)

slope, intercept, rvalue, pvalue, stderr = stats.linregress(x,y)

y = slope*x + intercept

# =============================================================================
# 프로그램으로 짜기 

import numpy as np
x = np.array([2,4,6,8])
y = np.array([71,83,91,97])

x_mean = np.mean(x)
y_mean = np.mean(y)

#리스트 내장객체로 프로그램만들기
denominator = sum([(i- x_mean)**2 for i in x])
#함수로 만들어보기 
def func(x, x_m, y, y_m):   #x, x_m, y, y_m: 형식매개변수이므로 밖의 변수의 이름과 다르다.
    s = 0
    for i in range(len(x)):
        s += (x[i]-x_m) * (y[i]-y_m)        #누적합만들기
    return s

numerator = func(x, x_mean, y, y_mean)
numerator 
Out[49]: 86.0

a = numerator/denominator
b = y_mean -(a*x_mean)

print("기울기: ",a)
print("절편: ",b)

#최소제곱법으로 plot과 회귀선 그리기 
import matplotlib.pyplot as plt
%matplotlib inline
#%matplotlib inline: 화면에 안나올 수도 있기 때문에 화면에 출력하겠다는 의미 

plt.scatter(x,y)
plt.plot(x, a*x+b, c="red")

#오차 출력하기
print("실제값 :", y)          # 실제값 : [71 83 91 97]
print("예측값: ", a*x+b)      # 예측값:  [72.6 81.2 89.8 98.4]
print("오차: ", y-(a*x+b))    # 오차:  [-1.6  1.8  1.2 -1.4]

# 
■ 평균제곱근오차(root mean square error) rmse
주어진 선의 오차를 평가하는 오차평가 알고리즘
오차 = 실제값 - 예측값
                       Σ(실제값-예측값)²        (편차제곱의 합)
평균제곱오차(mse) = -----------------------  = ----------------- 
                            n                        n
                            
평균제곱오차를 하게 되면 숫자가 커지기 때문에 root를 사용하여 값을 줄이는 방법으로서 평균제곱근오차가 나옴
                               Σ(실제값-예측값)²        
평균제곱근오차(rmse) = sqrt -----------------------  
                                    n   
                                    
평균제곱근오차를 줄이는 것이 중요하다.

np.sqrt(sum((y-a*x-b)**2)/len(y))

np.sqrt(np.mean((y-a*x-b)**2))


# =============================================================================
▣ logistic regression
- 분류를 하는데 있어서 가장 흔한 경우는 이분법을 기준으로 분류하는 경우
예) 특정 고객이 물건을 구매할지(1), 안 할것인지(0)
    어떤 기업이 부도가 날것인지(1), 안 날것인지(0)
    내일 비가 올 것인지(1), 안 올것인지(0)
- 적용분야
    기업의 부도예측, 주가, 환율, 금리 등의 UP/DOWN예측 모형    
- 숫자를 기반으로 하는 분석방법
    
import pandas as pd
from sklearn.linear_model import LogisticRegression

iris = pd.read_csv("c:/data/iris.csv")

x = iris.ix[:,:-1]
y = iris['Name']

#
logreg = LogisticRegression()
logreg.fit(x,y) #x:독립변수, y:종속변수

new_observation = [[5.1,3.5,1.4,0.2]]
logreg.predict(new_observation)
#Out[95]: array(['Iris-setosa'], dtype=object)

new_observation = [[6.9,3.2,5.7,2.3]]
logreg.predict(new_observation)
#Out[97]: array(['Iris-virginica'], dtype=object)

new_observation = [[7.0,3.2,4.7,1.4]]
logreg.predict(new_observation)
#Out[109]: array(['Iris-versicolor'], dtype=object)

# =============================================================================
# 자율학습
# =============================================================================


titanic = pd.read_csv("c:/data/titanic.csv")
titanic.head()
t

#동물
zoo = pd.read_csv("c:/data/zoo.csv")
zoo.head()

x = zoo.ix[:,2:17]
y = zoo.ix[:,-1]

logreg = LogisticRegression()
logreg.fit(x,y)

new_observation = [[0,0,1,0,0,0,1,1,1,0,0,4,1,0,1,1]]
logreg.predict(new_observation)

lark=[[1,1,0,1,0,0,0,1,1,0,0,2,1,0]]
logreg.predict(lark)

housefly=[[0,1,0,1,0,0,0,0,1,0,0,6,0,0]]
logreg.predict(housefly)

# =============================================================================
# statsmodels
# =============================================================================

statsmodels
검정 및 추정(test and estimation)
회귀분석(regressio analysis)
시계열분석(time-series analysis)

import statsmodels.api as sm
import pandas as pd

df = pd.read_csv("c:/data/titanic.csv")
df.head()
성별(gender), 나이(age), 객실등급(pclass), 요금(fare)이 생존에 어느 정도의 영향을 미치는가? 

회귀분석에는 연속형 자료/
성별(gender) - one-hot encoding으로/ dummy table로 
gender.replace


cols = ['survived', 'age', 'fare']

#
분류할 수 있는 컬럼들은 더미 컬럼으로 만든다. 
pclass 1,2,3의 들어 갈 경우 => pclass_1(0/1), pclass_2(0/1), paclass3(0/1)
dummy_pclass = pd.get_dummies(df['pclass'], prefix='pclass')
#Out[221]: 
#     pclass_1  pclass_2  pclass_3
#0           0         0         1
#1           1         0         0
#2           0         0         1
#3           1         0         0
#4           0         0         1
#5           0         0         1
#6           1         0         0
#7           0         0         1
#8           0         0         1

dummy_gender = pd.get_dummies(df['gender'], prefix='gender')
#Out[223]: 
#     gender_female  gender_male
#0                0            1
#1                1            0
#2                1            0
#3                1            0
#4                0            1

#data 합치기  (concat, join 등 이용 가능)
data = df[cols].join(dummy_pclass)
data = data.join(dummy_gender)

#NaN이 있으면 회귀분석이 안되고 -> 결과값이 NaN으로 나온다. 
#따라서 NaN값을 처리해줘야한다. -> NaN값을 어떻게 처리할 것인가? 1. 버릴것인가? drop.nan 2.나이값을 대체함 -> 최저? 최고? 평균?! 
#NaN값 개수 구하기
data.isnull().sum()

1. median으로 구한 경우
data1 = data.copy()

#데이터가 같은 메모리를 참조하고 있으므로, deep copy를 하애함 
id(data)    #Out[233]: 205596712
id(data1)   #Out[234]: 222309736

# 중심경향을 파악하기 위해서는 중앙값이 더 나으므로 
data1['age'].fillna(data1['age'].median(skipna=True), inplace=True) #inplace=True: 값을 적용하기
data1.isnull().sum()

#독립변수 컬럼 
train_cols = data1.columns[1:]

#logistic regression
logit = sm.Logit(data1['survived'],data1.ix[:,1:])
result = logit.fit()

# 분석된 결과 출력
result.summary2()
#Coef.: 회귀계수  - 큰값이 가장 영향을 많이 줌 
Out[246]: 
<class 'statsmodels.iolib.summary2.Summary'>
"""
                         Results: Logit
=================================================================
Model:              Logit            Pseudo R-squared: 0.321     
Dependent Variable: survived         AIC:              817.3956  
Date:               2018-10-30 15:36 BIC:              846.1497  
No. Observations:   891              Log-Likelihood:   -402.70   
Df Model:           5                LL-Null:          -593.33   
Df Residuals:       885              LLR p-value:      3.2405e-80
Converged:          1.0000           Scale:            1.0000    
No. Iterations:     6.0000                                       
-----------------------------------------------------------------
                   Coef.  Std.Err.    z    P>|z|   [0.025  0.975]
-----------------------------------------------------------------
age               -0.0329   0.0074 -4.4271 0.0000 -0.0475 -0.0183
fare               0.0008   0.0021  0.3611 0.7180 -0.0034  0.0049
pclass_1           1.5328      nan     nan    nan     nan     nan
pclass_2           0.4622      nan     nan    nan     nan     nan
pclass_3          -0.7497      nan     nan    nan     nan     nan
gender_female      1.9249      nan     nan    nan     nan     nan
gender_male       -0.6798      nan     nan    nan     nan     nan
=================================================================
"""
#의사결정트리를 쓰지 않아도 회귀분석을 통해 Coef를 통해 가장 영향을 많이 주는 독립변수를 확인할 수 있다. 

#계산이 잘 나오질 않을 경우 동일하게 가중치를 주기도 한다. 
#가중치 설정 
data1['intercept'] = 1.0 

#독립변수 컬럼 
train_cols = data1.columns[1:]

#logistic regression
logit = sm.Logit(data1['survived'],data1.ix[:,1:])
result = logit.fit()

# 분석된 결과 출력
result.summary2()
Out[255]: 
<class 'statsmodels.iolib.summary2.Summary'>
"""
                               Results: Logit
============================================================================
Model:                   Logit               Pseudo R-squared:    0.321     
Dependent Variable:      survived            AIC:                 817.3956  
Date:                    2018-10-30 15:44    BIC:                 846.1497  
No. Observations:        891                 Log-Likelihood:      -402.70   
Df Model:                5                   LL-Null:             -593.33   
Df Residuals:            885                 LLR p-value:         3.2405e-80
Converged:               1.0000              Scale:               1.0000    
No. Iterations:          10.0000                                            
----------------------------------------------------------------------------
               Coef.    Std.Err.      z    P>|z|      [0.025       0.975]   
----------------------------------------------------------------------------
age           -0.0329       0.0074 -4.4271 0.0000       -0.0475      -0.0183
fare           0.0008       0.0021  0.3611 0.7180       -0.0034       0.0049
pclass_1       1.3064          nan     nan    nan           nan          nan
pclass_2       0.2358          nan     nan    nan           nan          nan
pclass_3      -0.9761          nan     nan    nan           nan          nan
gender_female  1.5854 2952743.2140  0.0000 1.0000 -5787268.7698 5787271.9405
gender_male   -1.0194 2952743.2140 -0.0000 1.0000 -5787271.3745 5787269.3358
intercept      0.5660          nan     nan    nan           nan          nan
============================================================================

"""

#data1[train_cols]: 설명변수 (독립변수) / data1['survived']목적변수 
data1['predict'] = result.predict(data1[train_cols])

data1[data1['predict']>=0.9]
data1[data1['predict']>=0.7]    

# =============================================================================
# R>>>>>>>>>>>

help(cars)
str(cars)

speed: 차속도(단위 mi/h)
dist: 제동거리(단위 feet)
#dist: 종속변수, speed: 독립변수
lmresult <- lm(dist~speed, data=cars)
lmresult
summary(lmresult)
# > summary(lmresult)
# 
# Call:
#   lm(formula = dist ~ speed, data = cars)
# 
# Residuals:
#   Min      1Q  Median      3Q     Max 
# -29.069  -9.525  -2.272   9.215  43.201 
# 
# Coefficients:
#   Estimate Std. Error t value Pr(>|t|)    
# (Intercept) -17.5791     6.7584  -2.601   0.0123 *  
#   speed         3.9324     0.4155   9.464 1.49e-12 ***
#   ---
#   Signif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1
# 
# Residual standard error: 15.38 on 48 degrees of freedom
# Multiple R-squared:  0.6511,	Adjusted R-squared:  0.6438 
# F-statistic: 89.57 on 1 and 48 DF,  p-value: 1.49e-12

#####
# 절편: (Intercept) -17.5791 
# 회귀계수: 3.9324 
# p-value: 1.49e-12 -> 유의수준 0.05를 기준으로 봤을 때 귀무가설을 기각하고 대립가설을 채택한다. 따라서 속력과 제동거리의 상관관계가 있다. 

coef(lmresult)

plot(cars$speed, cars$dist)
abline(lmresult, col='red')

speed <- c(50,60,70,80,90,100)
df <- data.frame(speed)

■점추정 (speed에 따른 예측된 거리 계산)
point_estimation <- predict(lmresult, df)
cbind(df, point_estimation)

■구간추정 (speed에 따른 예측된 구간추정)
interval_estimation <- predict(lmresult,df,interval="confidence", level=0.95)
cbind(df, interval_estimation)
fit:점추정, lwr:구간최소값, upr:구간 최대값 
# > cbind(df, interval_estimation)
# speed      fit      lwr      upr
# 1    50 179.0413 149.8060 208.2766
# 2    60 218.3654 180.8489 255.8820
# 3    70 257.6895 211.8651 303.5139
# 4    80 297.0136 242.8670 351.1602
# 5    90 336.3377 273.8603 398.8151
# 6   100 375.6618 304.8480 446.4755

#60mi/h 속도인 경우 제동거리를 예측하면
점추정: 218.3654 feet
구간추정: 180.8489 feet~255.8820 feet사이일 확률이 95%이다. 



# -*- coding: utf-8 -*-
"""
Created on Wed Oct 31 09:46:09 2018

@author: stu
"""
# =============================================================================
# [문제199] 보험데이터를 이용해서 보험료에 가장 영향을 주는 독립변수가 무엇인지 확인하세요.
# =============================================================================
import statsmodels.api as sm
import pandas as pd

df = pd.read_csv("c:/data/insurance.csv")


#종속변수
charges = df.ix[:,-1]

#독립변수

df.head()
## 
cols = ['age','bmi','children']

##one-hot encoding: sex, smoker, region
dummy_sex = pd.get_dummies(df['sex'], prefix='sex')
dummy_smoker = pd.get_dummies(df['smoker'], prefix='smoker')
dummy_region = pd.get_dummies(df['region'], prefix='region')

#data 합치기 
data = df[cols].join(dummy_sex)
data = data.join(dummy_smoker)
data = data.join(dummy_region)

#null 값 확인하기
data.isnull().sum()

#
data1 = data.join(charges)
data1.isnull().sum()


#독립변수 컬럼
train_cols = data.columns

#logisitic regression: ValueError: endog must be in the unit interval.
logit = sm.Logit(df['charges'],)

logit = sm.Logit(data1['charges'], data1.ix[:,:-1])

# =============================================================================

import math
from scipy import stats

#단일 회귀 모형 
#각각 독립변수의 하나씩 linregression 
#age
stats.linregress(data.ix[:,0],charges)
Out[110]: LinregressResult(slope=257.7226186668955, intercept=3165.885006063025, rvalue=0.2990081933306477, pvalue=4.886693331718491e-29, stderr=22.5023892867703

#bmi
stats.linregress(data.ix[:,1],charges)
Out[111]: LinregressResult(slope=393.87303079739524, intercept=1192.9372089611497, rvalue=0.1983409688336289, pvalue=2.459085535116683e-13, stderr=53.25073835210321)

#children
stats.linregress(data.ix[:,2],charges)
Out[112]: LinregressResult(slope=683.0893824813649, intercept=12522.495549644096, rvalue=0.06799822684790487, pvalue=0.012852128520136412, stderr=274.2018326126803)

#sex_female /sex_male
stats.linregress(data.ix[:,3],charges)
Out[113]: LinregressResult(slope=-1387.1723338865486, intercept=13956.751177721895, rvalue=-0.05729206220202543, pvalue=0.036132721005929666, stderr=661.3308807850439)
stats.linregress(data.ix[:,4],charges)
Out[115]: LinregressResult(slope=1387.1723338865484, intercept=12569.578843835347, rvalue=0.05729206220202542, pvalue=0.036132721005929715, stderr=661.3308807850439)

#smoker_no/ smoker_yes
stats.linregress(data.ix[:,5],charges)
Out[116]: LinregressResult(slope=-23615.963533676637, intercept=32050.231831532845, rvalue=-0.7872514304984772, pvalue=8.271435842179102e-283, stderr=506.0752903935149)
stats.linregress(data.ix[:,6],charges)
Out[117]: LinregressResult(slope=23615.963533676633, intercept=8434.268297856206, rvalue=0.7872514304984771, pvalue=8.271435842179102e-283, stderr=506.075290393515)

#region_northeast    0
stats.linregress(data.ix[:,7],charges)
Out[119]: LinregressResult(slope=179.40581081381077, intercept=13226.978705571993, rvalue=0.00634877128015607, pvalue=0.8165263815339816, stderr=773.098520385663)
#region_northwest    0
stats.linregress(data.ix[:,8],charges)
Out[121]: LinregressResult(slope=-1126.4650941640384, intercept=13544.04046813327, rvalue=-0.039904864040438005, pvalue=0.14459698799364254, stderr=771.6895403197774)
#region_southeast    0
stats.linregress(data.ix[:,9],charges)
Out[122]: LinregressResult(slope=2012.4799925698546, intercept=12722.93144504004, rvalue=0.07398155156575988, pvalue=0.006782698910658689, stderr=742.1866482510707)
#region_southwest    0
stats.linregress(data.ix[:,10],charges)
Out[123]: LinregressResult(slope=-1219.7658242269438, intercept=13566.70320151925, rvalue=-0.043210028991684774, pvalue=0.11414659361882144, stderr=771.5833691494033)



#회귀모형 만들기  - 다중회귀모형
from sklearn import linear_model

#모델 만들기
reg = linear_model.LinearRegression()

#fit하기  (다중회귀분석)
reg.fit(data, charges)

# 각 변수에 대한 기울기(reg.coef_) , 절편(intercept_) 확인하기
reg.intercept_
Out[126]: -666.9377199366445

reg.coef_
Out[127]: 
array([   256.85635254,    339.19345361,    475.50054515,     65.6571797 ,
-65.6571797 , -11924.26727096,  11924.26727096,    587.00923503,
234.0453356 ,   -448.01281436,   -373.04175627])



# =============================================================================
#R>>>>>>>>>>>
insurance <- read.csv("c:/data/insurance.csv")

str(insurance)

#상관계수: 서로 연관여부를 확인가능 (교차표로)
cor(insurance[c("age","bmi","children","charges")])
# > cor(insurance[c("age","bmi","children","charges")])
#               age       bmi   children    charges
# age      1.0000000 0.1092719 0.04246900 0.29900819
# bmi      0.1092719 1.0000000 0.01275890 0.19834097
# children 0.0424690 0.0127589 1.00000000 0.06799823
# charges  0.2990082 0.1983410 0.06799823 1.00000000

#시각화
install.packages("psych")
library(psych)

pairs.panels(insurance[c("age","bmi","children","charges")])
#자기자신의 부분에서는 분포도로 히스토그램으로 그려줌 

#다중회귀분석으로 보기
ins_model = lm(charges~., data=insurance)
ins_model
#보험료에 영향을 줄 수 있는 요소가 된다. smokeryes가 가장 영향을 준다. (기울기 값이 그 만큼 영향을 준다.)
# Call:
#   lm(formula = charges ~ ., data = insurance)
# 
# Coefficients:
#   (Intercept)              age          sexmale              bmi         children        smokeryes
#       -11938.5            256.9           -131.3            339.2            475.5          23848.5
# regionnorthwest  regionsoutheast  regionsouthwest
#         -353.0          -1035.0           -960.1


insurance$bmi30 <- ifelse(insurance$bmi >=30, 1 ,0)
ins_model2 = lm(charges~age+children+bmi+sex+smoker+bmi30*smoker+region, data=insurance)
# Call:
#   lm(formula = charges ~ age + children + bmi + sex + smoker + 
#        bmi30 * smoker + region, data = insurance)
# 
# Coefficients:
#   (Intercept)              age         children              bmi          sexmale        smokeryes  
#       -4745.5            263.2            520.4            115.0           -491.2          13402.4  
#         bmi30  regionnorthwest  regionsoutheast  regionsouthwest  smokeryes:bmi30  
#       -865.1           -266.8           -825.0          -1224.3          19794.9  

ins_model = lm(charges~age+children+bmi+sex+smoker,data=insurance)
ins_model
# 
# Call:
#   lm(formula = charges ~ age + children + bmi + sex + smoker, data = insurance)
# 
# Coefficients:
#   (Intercept)          age     children          bmi      sexmale    smokeryes  
# -12052.5        257.7        474.4        322.4       -128.6      23823.4  

# =============================================================================
import pandas as pd

df = pd.read_csv("c:/data/insurance.csv")
df.head()

dummy_sex = pd.get_dummies(df['sex'], prefix='sex')
dummy_smoker = pd.get_dummies(df['smoker'], prefix='smoker')
cols = ['age', 'bmi', 'children', 'charges']

data = dummy_smoker.join(dummy_sex)
data = df[cols].join(data)
data

import statsmodels.formula.api as smf
lm = smf.ols(formula="charges~age+smoker_yes+sex_male+bmi+children",data=data).fit()
print(lm.params)



# =============================================================================
# 인공지능  
# =============================================================================

▣ 인공지능 <- 머신러닝 <- 신경망(딥러닝)

▣ 퍼셉트론(perceptron)
- 인공뉴런(인공적으로 만든 신경세포)
- 1957년에 만든 알고리즘 
- 프랑크 로젠블라트가 퍼셉트론 알고리즘을 고안했다. 
- 퍼셉트론은 딥러닝(신경망)의 기원
- 다수의 신호를 입력받아 하나의 신호를 출력한다. 
- 신호의 흐름을 표현할 때 두가지 값을 갖는다. 
- 0: 신호가 흐르지 않는다. 
- 1: 신호가 흐른다. 

■ 퍼셉트론 동작
x: 입력값(입력신호) 
w: weight 가중치
Θ: theta 임계값
y: 출력

y = 0 w1 * x1 + w2 * x2 <= Θ  (입력값과 가중치값을 계산한 결과 임계값보다 작거나 같을 경우 출력값은 zero로 출력한다.)
y = 1 w1 * x1 + w2 * x2 > Θ  

w1 * x1 + w2 * x2 값이  Θ(임계값) 이하일 때는 0을 출력하고 임계값 보다 클때는 1을 출력한다. 

■ 논리회로
컴퓨터는 두가지 디지털값 0,1을 입력해서 하나의 값을 출력하는 회로가 모여 만들어지는데 이 회로를 gate(게이트)라고 한다. 

□ AND게이트
x1      x2      y
------------------
0       0       0
0       1       0
1       0       0
1       1       1

□ AND게이트를 퍼셉트론으로 표현
y = 0 w1 * x1 + w2 * x2 <= Θ 
y = 1 w1 * x1 + w2 * x2 > Θ  

w1 = 0.5 , w2 = 0.5 , Θ = 0.7

AND(0,0) = 0 
AND(0,1) = 0
AND(1,0) = 0
AND(1,1) = 1 

def AND(x1,x2): 
    w1 = 0.5 
    w2 = 0.5
    theta = 0.7    
    result = w1*x1 + w2*x2
    if result <= theta:
        return 0
    elif result > theta:
        return 1

AND(0,0)  
AND(0,1) 
AND(1,0)
AND(1,1) 

#AND(0,0)  
#Out[237]: 0
#
#AND(0,1) 
#Out[238]: 0
#
#AND(1,0)
#Out[239]: 0
#
#AND(1,1) 
#Out[240]: 1

□ OR게이트
x1      x2      y
------------------
0       0       0
0       1       1
1       0       1
1       1       1


□ OR게이트를 퍼셉트론으로 표현
def OR(x1,x2): 
    w1 = 0.5
    w2 = 0.5
    theta = 0.4
    result = w1*x1 + w2*x2
    if result <= theta:
        return 0
    elif result > theta:
        return 1

OR(0,0)  
OR(0,1) 
OR(1,0)
OR(1,1) 
#임계값을 0.7이라고 했을때 OR게이트 값이 나오지 않기 때문에 임계값을 조정하든 가중치를 조정하여야 OR게이트 값이 나온다. 
#현재는 임계값을 0.4을 조정함
#만약에 임계값이 고정이다고 하면 Weight값을 조정해야한다. 
#OR(0,0)  
#Out[252]: 0
#
#OR(0,1) 
#Out[253]: 1
#
#OR(1,0)
#Out[254]: 1
#
#OR(1,1) 
#Out[255]: 1

□ NAND(NOT AND)게이트를 퍼셉트론으로 표현
x1      x2      y
------------------
0       0       1
0       1       1
1       0       1
1       1       0

def NAND(x1,x2): 
    w1 = -0.5
    w2 = -0.5
    theta = -0.7
    result = w1*x1 + w2*x2
    if result <= theta:
        return 0
    elif result > theta:
        return 1

NAND(0,0)  
NAND(0,1) 
NAND(1,0)
NAND(1,1) 

□ XOR (eXclusive OR) 배타적논리합
x1      x2      y
------------------
0       0       0
1       0       1
0       1       1
1       1       0

x1과 x중 어느 한쪽이 1일때만 1을 출력하는 배타적논리회로이다.
단 퍼셉트론은 XOR  게이트를 구현할 수 없다. 

■ 퍼셉트론의 한계
- 직선 하나로 XOR게이트의 출력을 구분할 수 없다.
- 페셉트론(단층퍼셉트론)은 직선하나로 나눈 영역만 표현할 수 있는 한계가 있다. 
- 민스키가 기존 퍼셉트론의 문제점을 지적햇는데 XOR분류를 못한다는 문제점을 지적하고 인공지능의 겨울기가 시작되었다. 


▣ 다층퍼셉트론(Multi layer perceptron)
x1      x2      OR    NAND     AND
----------------------------------------
0       0       0       1       0
1       0       1       1       1
0       1       1       1       1
1       1       1       0       0

다층 퍼셉트론(OR, NAND를 만들어)으로 AND연산 작업을 하면 XOR를 만들 수 있다.
1. x1와 x2를 통해 OR층을 만듦
2. x1와 x2를 통해 NAND층을 만듦
3. 중간에 만든 OR와 NAND를 AND계산 작업을 함

선형: 직선의 영역을 선형영역
비선형: 곡선의 영역을 비선형영역

■ 다층퍼셉트론(Multi layer perceptron)
- 단층퍼셉트론은 XOR게이트를 표현할 수 없었다.
- 즉, 단층퍼셉트론은 비선형영역을 분리할 수 없다. 
- 기존(OR, NAND, AND)게이트를 조합하여 층을 쌓으면 XOR게이트를 구현할 수 있다. 

XOR(0,0) = 0
XOR(0,1) = 1
XOR(1,0) = 1
XOR(1,1) = 0

def XOR(x1, x2):
    s1 = OR(x1,x2)
    s2 = NAND(x1, x2)
    y = AND(s1, s2)
    return y

XOR(0,0) 
XOR(0,1)
XOR(1,0)
XOR(1,1)

- 미분을 통해서(기울기 조정) 오차값을 줄이는 작업을 해야 한다. 
- y= ax + b라 할때, 은닉층 , weight(a) , bias 값(b) 를 해서 비선형 문제를 해결함 



# -*- coding: utf-8 -*-
"""
Created on Thu Nov  1 10:01:09 2018

@author: stu
"""


# =============================================================================

■ 은닉층(Hidden layers)
x1      x2      or(s1)      nand(s2)        and  y
----------------------     ------------   -----------
0       0       0              1              0
0       1       1              1              1
1       0       1              1              1
1       1       1              0              0


y = ax + b

■ bias(편향)
가중치와 편향을 도입한 퍼셉트론식 
Θ를 -b로 치환하면 
y = a1x1 + a2x2 + b 

y = 0  w1*x1 + w2*x2  <= Θ
y = 1  w1*x1 + w2*x2  >  Θ

y = 0  w1*x1 + w2*x2  <= -b
y = 1  w1*x1 + w2*x2  >  -b

#퍼셉트론식, 신경망의 식 
y = 0  w1*x1 + w2*x2 + b  <= 0
y = 1  w1*x1 + w2*x2 + b  >  0

import numpy as np

x = np.array([0,1])
w = np.array([0.5,0.5])
b = -0.7

x[0]*w[0]+x[1]*w[1]+b
np.sum(x*w)+b

def OR(x1,x2): 
    x = np.array([x1,x2])
    w = np.array([0.5,0.5])
    b = -0.2
    tmp = np.sum(w*x)+b
    if tmp <= 0:
        return 0
    else:
        return 1
    
OR(0,0)
OR(0,1)
OR(1,0)
OR(1,1)

#bias값이 달라지면 값이 달라진다.
def AND(x1,x2): 
    x = np.array([x1,x2])
    w = np.array([0.5,0.5])
    b = -0.7
    tmp = np.sum(w*x)+b
    if tmp <= 0:
        return 0
    else:
        return 1
    
AND(0,0)
AND(0,1)
AND(1,0)
AND(1,1)

#bias값의 조정을 어떻게 하느냐, weight값을 어떻게 조정하느냐에 따라 함수가 달라질 수 있다.

def NAND(x1,x2): 
    x = np.array([x1,x2])
    w = np.array([-0.5,-0.5])
    b = 0.7
    tmp = np.sum(w*x)+b
    if tmp <= 0:
        return 0
    else:
        return 1
    
NAND(0,0)
NAND(0,1)
NAND(1,0)
NAND(1,1)

def XOR(x1, x2):
  s1 = OR(x1,x2)
  s2 = NAND(x1, x2)
  y = AND(s1, s2)
  return y

XOR(0,0) 
XOR(0,1)
XOR(1,0)
XOR(1,1)


▣ 인공신경망(ANN, Artificial Neural Network)
인간의 뇌구조를 모방하여 모델링한 수학적 모델이다. 

■ 신경세포(Neuron 뉴런)
- 뉴런의 입력은 다수이고 출력은 하나이며, 여러 신경세포로 부터 전달되어 온 신호들은 합산되어 출력된다.
- 합산된 값이 설정값(threshold) 이상이면 출력신호가 생기고 이하이면 출력신호가 없다.
- 세포체(cell body) - 노드(node)
- 수상돌기(dendrites) - 입력(input)
- 축삭(axon) - 출력(output)
- Synapse weight (가중치)


 affine sum: 최종적 output을 내기 위해 모든 값을 sum 값 (밑의 sum)
 
            weight w
- input x ----------------> sum(σ) ------------> output y
                
                             ^
                             |
                            bias
                
σ = w*x + b = 0.6*3 + 1 = 2.8
x = 0.6
w= 3
b =1

affine sum이 너무 작으면 신호를 보내지 못하기 때문에, activate function을 적용해 신호의 크기를 크게 해줘야 한다. 


▣ 활성화 함수(actvatio function)
- synapse는 전달된 전기신호가 최소한의 작은 자극값을 초과하여 활성화되어 다음 뉴런으로 전기신호를 전달한다.
- 활성화 함수는 이것을 모방하여 값이 작을 때는 출력값을 작은값으로 막고 일정한 값을 초과하면 출력값이 급격하게 커지는 함수를 이용한다.
- 신경망에서는 전달받은 데이터를 가중치를 고려해서 합산하고 그값을 활성화함수f(σ)를 적용해 다음층에 전달한다. 
            weight w
- input x ----------------> σ|f(σ) ------------> output y
                
                             ^
                             |
                            bias
σ = w*x + b
f(σ) = f(w*x + b) #활성화 함수안에는 affine sum의 값이 들어가 있어야 한다. 

■ 은닉층 함수
□ 계단함수(Binary step function)
- 임계값을 경계로 출력이 바뀌는 함수
- 입력이 0을 넘으면 1을 출력하고 그외에는 0을 출력하는 함수 
- (activaiton function을 통해서 다음 출력값을 0, 1으로 출력하게 한다)

#그냥 집어넣을 때는 문제가 되지 않지만, array형식으로 x값을 넣을 경우 문제가 된다. 오류가 생긴다.! 
def step_function(x):
    if x > 0:
        return 1
    else:
        return 0
    
import numpy as np
step_function(1)
#Out[66]: 1
step_function(-1)
#Out[67]: 0

#array형식에 x입력값을 넣었을 때 -> 오류 발생 
step_function(np.array([1,2]))
x = np.array([-1.0,1.0,2.0])
y = x > 0
#Out[73]: array([False,  True,  True])

★ astype: 자료형변화 (bool -> int)
                    #True: 1, False: 0
y.astype(np.int)
#Out[74]: array([0, 1, 1])

#방법1) array형식으로 x입력값을 넣었을 때 -> 함수가 올바르게 수행하기 위해 astype을 사용한다. 
def step_function(x):
    y = x > 0
    return y.astype(np.int)

step_function(np.array([-1.0,1.0,2.0]))
#Out[78]: array([0, 1, 1])

#방법2) array형식으로 x입력값을 넣었을 때 -> 함수가 올바르게 수행하기 위해 
def step_function(x):
    return np.array(x> 0, dtype=np.int) #boolean 형식을 integer값으로 바꿔 array로 전달해줌
step_function(np.array([-1.0,1.0,2.0]))
#Out[80]: array([0, 1, 1])

#step_function을 plot으로 보기
import matplotlib.pylab as plt
x = np.arange(-5.0,5.0,0.1)
y = step_function(x)
plt.plot(x,y)
plt.ylim(-0.1,1.1)
plt.show

□ Sigmoid(시그모이드)
신경망에서는 활성화 함수로 시그모이드 함수를 이용하여 함수를 변환하고 그 변환된 신호를 다음 뉴런에 전달하는 함수이다. 
e-x (x승): e는 자연상수 2.7182.....
np.exp(-x)

def sigmoid(x):
    return 1/(1+np.exp(-x))

-> affine sum 값을 x에 넣는다. 
sigmoid함수는 0에 근사한 값을/ 1에 근사한 값을 출력한다. 

sigmoid(1)  #Out[87]: 0.7310585786300049
sigmoid(-1) 
sigmoid(100)  #Out[89]: 1.0
sigmoid(-100) #Out[91]: 3.7200759760208356e-44 
sigmoid(1000) #Out[98]: 1.0
sigmoid(-10000) #Out[95]: 0.0

x = np.arange(-5.0, 5.0, 0.1)  #-5.0, 5.0, 0.1: affine sum의 결과
y= sigmoid(x)
plt.plot(x,y)
plt.ylim(-0.1,1.1)
plt.grid()
plt.show()

□ 계단함수와 시그모이드 함수의 비교
- 계단함수는 0과 1중 하나의 값만 전달 
- 시그모이드는 함수는 0과 1사이의 실수값을 전달 
- 시그모이드 함수는 곡선
- 계단 함수는 계단처럼 구부러진 직선 
- (신경망에서는 계단함수보다는 시그모이드함수가 좋다. 왜냐하면 비선형구조를 만들 수 있기 때문에)
- 선형함수는 직선 하나만 표현
- 신경망에서는 활성함수로 비선형함수를 사용해야한다.
- 비선형함수를 사용해야 은닉층을 표현할 수 있다. 


□ ReLU(Rectified Linear Unit)
- 입력이 0을 넘으면 그 입력값으로 그대로 출력하고 0이하면 0을 출력한다. 

x: x > 0  (x값이 0보다 크면 x를 return해 주고)
0: x <= 0 (x값이 0하고 같거나 작으면 0으로 return해 준다.)

def ReLU(x):
    if x > 0:
        return x
    else:
        return 0

ReLU(3.2)
ReLU(-2)
ReLU(np.array([3.2,2.5,-0.2])) #오류발생 

★ np.maximum() :두 입력중에 큰값을 선택해 변환하는 함수
np.maximum(0,1) :두 입력중에 큰값을 선택해 변환하는 함수
np.maximum(0,-1)

def ReLU(x):
    return np.maximum(0,x)

ReLU(3.2) #Out[128]: 3.2
ReLU(-2)  #Out[129]: 0
ReLU(np.array([3.2,2.5,-0.2]))  #Out[130]: array([3.2, 2.5, 0. ])

x = np.arange(-5.0,5.0,0.1)
y = ReLU(x)
plt.plot(x,y)
plt.ylim(-0.1,6)
plt.show()

# =============================================================================

import numpy as np
a = np.array([1,2,3,4])
a
#배열의 차수 
np.ndim(a)
#배열의 모양
a.shape 

#3행 2열
x = np.array([[1,2],[3,4],[5,6]])
np.ndim(x)
x.shape

# =============================================================================

x     y      z(행렬의 내적 계산)
1 2   5 6   1*5+2*6  1*6+2*8   5+14  6+16     19  22
3 4   7 8   3*5+4*7  3*6+4*8   15+28 18+32    43  50

x = np.array([[1,2],[3,4]])
y = np.array([[5,6],[7,8]])
x.shape  #Out[156]: (2, 2) 
y.shape  #Out[157]: (2, 2)

# 행렬의 내적계산이 가능한 행렬모형 고려하기 : x의 열 벡터 = y의 행 벡터
# shape = 행 벡터 x 열 벡터

#행렬의 내적계산
np.dot(x,y)


#x       y
1 2 3   1 2
4 5 6   3 4
        5 6 

x = np.array([[1,2,3],[4,5,6]])
y = np.array([[1,2],[3,4],[5,6]])
x.shape #Out[163]: (2, 3): 2행 x 3열 
y.shape #Out[164]: (3, 2): 3행 x 2열 
#2행 x 3열 - 3행 x 2열 -> 2행 2열 
np.dot(x,y)
#Out[165]: 
#array([[22, 28],
#       [49, 64]])

#x   y
1 2  7 8 
3 4
5 6 
#cf 입력값은 x처럼, wieght값은 y처럼 주기 때문에 [7,8] 

# =============================================================================

x = np.array([[1,2],[3,4],[5,6]]) 
y = np.array([7,8])  #1차원이기 때문에 (행렬을 반영하지 않고) 그대로 차수만 반영한다. 
x.shape  #Out[169]: (3, 2)
y.shape  #Out[170]: (2,) 
np.dot(x,y) #Out[171]: array([23, 53, 83])

#입력값을 1,2로  하고 weight을 [1,3,5],[2,4,6]으로 뒀을 때 
x = np.array([1,2])
w = np.array([[1,3,5],[2,4,6]])
x.shape
w.shape
y = np.dot(x,w) #Out[194]: array([ 5, 11, 17])

# =============================================================================

x = np.array([1.0,0.5]) #입력층
w1 = np.array([[0.1,0.3,0.5],[0.2,0.4,0.6]]) #wieght
b1 = np.array([0.1,0.2,0.3]) #bias
a1 = np.dot(x,w1) + b1 #affine sum

z1 = sigmoid(a1) #activation function

w2 = np.array([[0.1,0.4],[0.2,0.5],[0.3,0.6]])
b2 = np.array([0.1,0.2])
a2 = np.dot(z1, w2) +b2 #Out[226]: array([0.58597175, 1.37965826])
z2 = sigmoid(a2) #Out[220]: array([0.64244035, 0.79893611])

w3 = np.array([[0.1,0.3],[0.2,0.4]])
b3 = np.array([0.1,0.2])
a3 = np.dot(z2,w3) +b3

■ 출력층 함수
□ 항등함수: 입력을 그대로 출력한다. 입력 = 출력
def indentify_function(x):
    return x

y = indentify_function(a3) #Out[239]: array([0.32403126, 0.71230655])

□ softmax function: 지수값으로 출력한다. 
a = np.array([0.3, 2.9, 4.0])  #마지막 최종결과라고 a라고 가정할 때
exp_a = np.exp(a) #지수함수
sum_exp_a = np.sum(exp_a)
exp_a / sum_exp_a #비율값으로 계산하면 좋다. #Out[244]: array([0.01821127, 0.24519181, 0.73659691])
#cf. 분류를 할 때는 항등함수보다 softmax function을 사용하는 것이 좋다. 
#cf. 예측할 때는 항등함수를 사용하는 것이 좋다. 그대로 값을 사용하면 되면 된다. 

def softmax_function(x):
    exp_x = np.exp(x)
    sum_exp_x = np.sum(exp_x)
    return exp_x / sum_exp_x

#지금 softmax_function의 한계와 주의점: 지수로 값이 들어갈 경우의 문제 -> 숫자가 너무 커져 overhead(overflow)가 되어 1000,10000숫자까지는 계산이 안되어 infinite가 된다. / 지수계산을 하다보니 컴퓨터의 부하를 준다. 
a = np.array([100,1000,10000])
softmax_function(a)
#C:/Users/stu/Desktop/cogreen/note/1101_Thu.py:4: RuntimeWarning: invalid value encountered in true_divide
#  
#Out[248]: array([ 0., nan, nan])


#softmax function 수정: 지수의 문제를 해결하기 위해 가장 큰 값으로 빼주면 된다. 
def softmax_function(x):
    m = np.max(x)
    exp_x = np.exp(x-m)
    sum_exp_x = np.sum(exp_x)
    return exp_x / sum_exp_x

a = np.array([100,1000,10000])
softmax_function(a)

▣ 은닉층에서 사용하는 함수와 출력층에서 사용하는 함수는 다르다. 
■ 은닉층: step function/ sigmoid function/ ReLU function 
■ 출력층: 항등함수/ softmax function     



# -*- coding: utf-8 -*-
"""
Created on Fri Nov  2 09:52:59 2018

@author: stu
"""


# =============================================================================
# 복습
# =============================================================================


■ output layer 
활성화 함수 

- 회귀(regression): 항등함수(indentify function); 그대로 값을 return해줄 때 사용
- 분류(classification): softmax function
(만약에 개/고양이 분류라면 2개의 출력값이 필요, 0~9까지의 숫자 분류라면 10개의 출력값이 필요)
- 분류 문제에서 출력층의 node수는 분류하고 싶은 클래스 수로 설정하면 된다. 

■  softmax function
- 출력값으로 확률 벡터로 나온다. 
- 

#softmax function 수정: 지수의 문제를 해결하기 위해 가장 큰 값으로 빼주면 된다. 
def softmax_function(x):
    m = np.max(x)
    exp_x = np.exp(x-m)
    sum_exp_x = np.sum(exp_x)
    return exp_x / sum_exp_x


# =============================================================================
# 오늘 수업 (11.02) 
# =============================================================================

▣ TensorFlow
- 구글이 오픈소스로 공개한 머신러닝(machine learning)라이브러리
- 다차원행렬계산(tensor), 대규모 숫자계산 작업을 수행한다.
- 딥러닝을 비롯한 여러 머신러닝에 사용되는 라이브러리 제공
- C++로 만들어진 라이브러리 (cf. C계열 언어는 하드웨어를 제어할 수 있기 때문에 프로그램 개발자로서는 유용한 언어다. 나중에라도 공부해라 애들아!)
- PYTHON 지원한다. 

> Anaconda Prompt
pip install --upgrade tensorflow 
pip install --upgrade tensorflow-gpu

>spyder 
import tensorflow as tf
tf.__version__

#tensorflow의 상수값 지정(변할 수 없음)
tensor = tf.constant("tensorflow")  #tensorflow에서 사용하는 상수/ 변수
tensor #Out[6]: <tf.Tensor 'Const_1:0' shape=() dtype=string>  -> 객체모양으로 출력 
print(tensor) #Tensor("Const_1:0", shape=(), dtype=string) #Const_1: 상수의 약자 

cf.python의 변수와 tensorflow의 변수와는 다름
#tensor = "tnesorflow" #python의 변수임  /#주의 파이썬의 변수로 동작

#print(tensor) 를 해도 값이 나오지 않고 flow를 만들어야 함, #즉 변수를 조작하기 위해서는 세션을 시작해야한다. 
■ 세션시작 
- 클라이언트 프로그램이 텐서플로 런터임 시스템과 통신하기 위해서는 세션이 생성되어야 한다. 

#세션 시작
sess = tf.Session() #plsql에서 처럼 cursor를 열었던 것처럼 조작하기 위해 session을 열어야 한다.
sess.run(tensor)    #변수 안에 있는 내용을 실행시킴 -> 이때 화면에 출력함 
#세션 끝
sess.close()

#============================
#상수 선언
a = tf.constant(1234)
b = tf.constant(5678)

add_op = a+b
add_op      #Out[18]: <tf.Tensor 'add:0' shape=() dtype=int32> #tensor 객체정보

sess = tf.Session()
sess.run(add_op)        #Out[20]: 6912
sess.run([a,b,add_op])  #Out[21]: [1234, 5678, 6912]
sess.close()

#==============================
a = tf.constant(1)
b = tf.constant(2)
c = tf.constant(3)
x1 = a+b*c
x2 = (a+b)*c
sess = tf.Session()
z1 = sess.run(x1)
z2 = sess.run(x2)
z1
z2
sess.close()

#==============================
#assign을 사용해 v를 x1으로 치환하기 
a = tf.constant(120, name="a") #name="a" # bias값인지 weight값인지 알기 우해 name에 이름을 만들 수 있는 옵션이다.
b = tf.constant(130, name="b")
c = tf.constant(140, name="c")
#변수: Variable
v = tf.Variable(0, name="v")
x1 = a+b+c
assign_op = tf.assign(v,x1) #x1식을 v에 변수 복제함 
sess = tf.Session()
sess.run(assign_op)     #Out[47]: 390
#v변수에 들어가 있는 값 확인하기 
sess.run(v)             #Out[48]: 390
sess.run(x1)            #Out[49]: 390
sess.close()

#==============================
#assign을 사용하지 않고 치환해보기 
a = tf.constant(120, name="a") #name="a" # bias값인지 weight값인지 알기 우해 name에 이름을 만들 수 있는 옵션이다.
b = tf.constant(130, name="b")
c = tf.constant(140, name="c")
#변수: Variable
v = tf.Variable(0, name="v")
x1 = a+b+c
v = x1
#assign_op = tf.assign(v,x1) #x1식을 v에 변수 복제함 
sess = tf.Session()
#sess.run(assign_op)     #Out[47]: 390
#v변수에 들어가 있는 값 확인하기 
sess.run(v)             #Out[48]: 390
sess.run(x1)            #Out[49]: 390
sess.close()

#==============================
x = tf.Variable([[1,2,3],[4,5,6]])  #2x3
y = tf.Variable([[1,2],[3,4],[5,6]])    #3x2
z = tf.Variable(0)
z = tf.matmul(x,y)      #2x2
sess = tf.Session()
sess.run(z)  #에러 -> 상수가 아니라 변수이기 때문에 오류가 남
#상수와 변수의 차이 / 상수는 변하지 않은 값이니 메모리를 할당하지 않고 값을 바로 값을 넣음 
#그러나 변수는 초기화를 시켜야 값을 할당할 수 있다. 
sess.run(tf.global_variables_initializer()) #변수는 꼭 초기화 시켜야한다. (이때 메모리에 할당되는 듯 하다)
sess.run(z) 
#Out[89]: 
#array([[22, 28],
#       [49, 64]])
sess.close()

#==============================
p1 = tf.placeholder("int32")    #tf.placeholder: runtime시점에 값을 넣어 실행하겠다는 의미임 #값이 존재하지 않음 #초기화 시키지 않고 값이 나옴
p2 = tf.placeholder("int32")
y = tf.add(p1,p2)   #더하기 메소드
sess = tf.Session()
sess.run(y, feed_dict={p1:10, p2:20}) #runtime 시점에 값을 넣어 사용함 
#constant, variable, placeholder모두가 섞여 있을 수 있기 때문에 그럴 경우에는 sess.run(tf.global_variables_initializer()) 를 사용하여 초기화시켜놓고 run을 실행한다. 
sess.close()

■ 함수            설명
------------------------------- 
tf.add            덧셈
tf.subtract       뺄셈
tf.multiply       곱셈
tf.div            나눗셈의 몫
tf.truediv        나누셈의 몫, 소수점
tf.mod            나눗셈의 나머지
tf.abs            절대값
tf.negative       음수
tf.sign           부호(음수-1, 양수 1, 0)
tf.reciprocal     역수(3은 1/3)
tf.square         제곱
tf.round          반올림
tf.sqrt           제곱근
tf.pow            거듭제곱
tf.exp            지수값
tf.log            로그값
tf.maximum        최대값
tf.minimum        최소값
tf.cos            코사인
tf.sin            사인
tf.matmul         행렬의 곱


#====실습===============================
p1 = tf.placeholder("int32")    #tf.placeholder: runtime시점에 값을 넣어 실행하겠다는 의미임 #값이 존재하지 않음 #초기화 시키지 않고 값이 나옴
p2 = tf.placeholder("int32")
y = tf.div(p1,p2)   #더하기 메소드
sess = tf.Session()
y = tf.truediv(p1,p2)

sess.run(y, feed_dict={p1:9, p2:4}) 

y = tf.mod(p1,p2)
y = tf.abs(p1,p2)
y = tf.negative(p1,p2)
y = tf.sign(p1,p2)
y = tf.reciprocal(p1,p2)
y = tf.square(p1,p2)
y = tf.round(p1,p2)
y = tf.sqrt(p1,p2)
y = tf.pow(p1,p2)
y = tf.exp(p1,p2)
y = tf.log(p1,p2)
y = tf.maximum(p1,p2)
y = tf.minimum(p1,p2)
y = tf.cos(p1,p2)
y = tf.sin(p1,p2)

#==============================
■ 세션 열고 닫기를 함께 하기
x = tf.Variable(0)
y = tf.assign(x,1)

with tf.Session() as sess:
    sess.run(tf.global_variables_initializer())  #변수는 꼭 초기화 시켜주기
    print(sess.run(x)) #0
    print(sess.run(y)) #1
    print(sess.run(x)) #1


# =============================================================================
# [문제200] tensorflow 상수를 이용해서 아래와 같이 결과를 출력하는 프로그램을 만드세요.
# a + b = 6
# a * b = 8
# =============================================================================
a = tf.constant(2)
b = tf.constant(4)
c = a + b
d = a * b
sess = tf.Session()
print("a + b = {}".format(sess.run(c)))
print("a * b = {}".format(sess.run(d)))
sess.close()

with tf.Session() as sess:
    print("a + b = {}".format(sess.run(a+b)))
    print("a * b = {}".format(sess.run(a*b)))
    
# =============================================================================
# [문제201] tensorflow 상수를 이용해서 아래와 같이 결과를 출력하는 프로그램을 만드세요.
# 단 두 변수의 입력값을 실행시 넣도록하는 변수를 이용하세요.  
# Add = 6
# Multiply = 8
# =============================================================================

a = tf.placeholder(tf.int32)
b = tf.placeholder(tf.int32)
add = tf.add(a,b)
mul = tf.multiply(a,b)
sess = tf.Session()
print("Add: %d"%sess.run(add,feed_dict={a:2, b:4}))
print("Multiply: %d"%sess.run(mul,feed_dict={a:2, b:4}))
sess.close()


#a = tf.placeholder(tf.int32) 
#b = tf.placeholder(tf.int32)
a = tf.placeholder("int32")
b = tf.placeholder("int32")
y = tf.add(a, b)
z = tf.multiply(a,b)
with tf.Session () as sess:
    print("Add = {}".format(sess.run(y, feed_dict={a:2, b:4})))
    print("Multiply = {}".format(sess.run(z, feed_dict={a:2, b:4})))


# =============================================================================
■ 텐서 자료 구조
- 텐서는 텐서플로의 기본 자료 구조
- 텐서는 다차원배열, 리스트로 구성
- 텐서는 학습데이터가 저장되는 다차원 배열

□ 1차원 tensor
#tensor에서는 바로 값을 출력할 수 없지만 numpy의 값은 바로 출력할 수 있다. 
import numpy as np
arr_1 = np.array([1.5, 1.5, 0, 10])
arr_1
arr_1[0]      #Out[237]: 1.5
arr_1.ndim    #Out[238]: 1
arr_1.shape   #Out[239]: (4,)
arr_1.dtype   #Out[240]: dtype('float64')

#numpy에서 만든 자료를 tensor자료로 converting 해주기
arr_tf = tf.convert_to_tensor(arr_1, dtype=tf.float64)
#세션을 열어 tensor값 확인하기
with tf.Session() as sess:
    print(sess.run(arr_tf))
    print(sess.run(arr_tf[0]))

arr_tf.shape    #Out[244]: TensorShape([Dimension(4)])
arr_tf.dtype    #Out[246]: tf.float64
arr_tf.ndim     #AttributeError: 'Tensor' object has no attribute 'ndim'


□ 2차원 tensor
arr_1 = np.array([[1,2,3],[4,5,6],[7,8,9]])
arr_2 = np.array([[1,1,1],[2,2,2],[3,3,3]])
type(arr_1)    #Out[254]: numpy.ndarray
type(arr_2)    #Out[255]: numpy.ndarray

#numpy의 array를 상수값으로 그대로 넣으면 conversion없이 사용할 수 있음 
tm1 = tf.constant(arr_1)
tm2 = tf.constant(arr_2)

tm_product = tf.matmul(tm1, tm2)
tm_add = tf.add(tm1, tm2)
with tf.Session() as sess:
    print(sess.run(tm_product))
    print(sess.run(tm_add))
#[[14 14 14]
# [32 32 32]
# [50 50 50]]
#[[ 2  3  4]
# [ 6  7  8]
# [10 11 12]]


□ 3차원 tensor
arr_3 = np.array([[[1,2],[3,4]],[[5,6],[7,8]]])
arr_3.ndim     #Out[266]: 3
arr_3.shape    #Out[267]: (2, 2, 2) (plane면, row행, column렬) 면이 2개인 3차원이 만들어짐
tm_3 = tf.constant(arr_3)
with tf.Session() as sess:
    print(sess.run(tm_3))
#[[[1 2]
#  [3 4]]
#
# [[5 6]
#  [7 8]]]

# =========================================
x = tf.placeholder(tf.float32)
y = tf.placeholder(tf.float32)
z = tf.matmul(x,y)  #행렬의 곱 
with tf.Session() as sess:
    print(sess.run(z, feed_dict={x:[[3.,3.],[3.,3.]],y:[[5.,5.],[5.,5.]]}))
    
    
x = tf.placeholder(tf.float32, shape=(2,2))  #shape을 지정해줄 수도 있다. 
y = tf.placeholder(tf.float32, shape=(2,2))
z = tf.multiply(x,y)
with tf.Session() as sess:
    print(sess.run(z, feed_dict={x:[[3.,3.],[3.,3.]],y:[[5.,5.],[5.,5.]]}))
    
# =============================================================================
# [문제202] x변수는 1행3열 모양의 1,2,3
# w변수는 3행 1열 모양의 2,2,2
# y변수는 x와 w를 행렬의 곱을 이용한 결과를 수행하는 프로그램을 작성하세요. 
# =============================================================================
x = tf.placeholder(tf.float32)
w = tf.placeholder(tf.float32)
y = tf.matmul(x,w)
with tf.Session() as sess:
    print(sess.run(y, feed_dict={x:[[1,2,3]], w:[[2],[2],[2]]}))


x = np.array([[1,2,3]])
w = np.array([[2],[2],[2]])
tm1 = tf.constant(x)
tm2 = tf.constant(w)
tm_product = tf.matmul(tm1, tm2)
with tf.Session() as sess:
    print(sess.run(tm_product))

#get_shape: 행과 열을 같이 보이게 하도록 하기
x = tf.constant([[1.0,2.0,3.0]])
print(x.get_shape())
w = tf.constant([[2.0],[2.0],[2.0]])
print(w.get_shape())
y = tf.matmul(x,w)
sess = tf.Session()
print(sess.run(x))
print(sess.run(w))
print(sess.run(y))

#변수를 사용할 때는 꼭 초기화를 시켜줘야 한다.  init_op = tf.global_variables_initializer()
x = tf.Variable([[1.0,2.0,3.0]])
w = tf.Variable([[2.0],[2.0],[2.0]])
y = tf.matmul(x,w)
init_op = tf.global_variables_initializer()
with tf.Session() as sess:
    sess.run(init_op)
    print(sess.run(y))


# -*- coding: utf-8 -*-
"""
Created on Mon Nov  5 09:49:23 2018

@author: stu
"""


■ feed forward

- 입력   ->   출력
         |
        bias

y = w * x + b      
w = 2
b = 1

x   y
---------- 
0   1
1   3
2   5


- 목표 
( 입력: 1 -> 목표: 4 ) 가정하자. (입력은 고정이고, weight, bias를 조정하여 4가 나오도록 해보자)
즉, y = w * 1 + b = 4          

#cf. 기존에는 입력값, weight, bias값을 주었으나, 이제는 하나씩 값을 돌리면서 목표값이 나오도록 맞춰나가는 작업을 할 것임

#1. 다음과 같이 가정해 보자. 입력값과 bias가 고정되어 있다고 가정해보자. => weight를 수정하면서 목표를 찾는다. 
입력 = 1
bias = 1

w     출력 (목표)  
----------------- 
1     2
2     3
2.5   3.5
3     4

즉, y = w * 1 + b = 4 가 되기 위해서는 
    y = 3 *1 + 1 = 4가 되었다. 
=> weight 수정하면서 목표를 찾는다. 

#2. 다음과 같이 가정해 보자. 입력값과 weight가 고정되어 있다고 가정해보자. => bias를 수정하면서 목표를 찾는다. 
입력 = 1
weight = 2
목표 4

bias     출력(목표)
----------------------
1        2*1 + 1 = 3
1.5      2*1 + 1.5 = 3.4
2        2*1 + 2 = 4
=> bias를 수정하면서 목표를 찾는다. 


#1.#2를 위해서 => 미분(순간변화율)을 생각해보면서 오차율을 줄일 수 있도록 함 
#즉, 오차를 줄이기 위해서는 weight(기울기)를 줄여줘야함 -> 미분을 통해서 가능함 "경사하강법"
f = wx + b 
g = wx    (#g값에 영향을 주는 것은 w와 x)
f = g + b

# g = wx 
# w를 기준으로 해서 미분하면 x가 남음 (미분의 값과 x는 같다)
∂ g
----   = x 
∂ w 

# x를 기준으로 해서 미분하면 x가 남음 (미분의 값과 w는 같다)
∂ g
----   = w
∂ x 

# f = g + b
# f를 기준으로 해서 미분하면 1이 남음 (어짜피 상수는 미분하면 1; 버리는 것이기 때문에 1이 남음 )
∂ f   
----  =  1
∂ w
# g를 기준으로 해서 미분하면 1이 남음 
∂ g  
----  =  1
∂ b


#∂ F  
#----  =  1
#∂ g


■ chain rule

∂ f       ∂ f      ∂ g
----  =  -----   ------
∂ w       ∂ g      ∂ w

      =    1         x
      
∂ f       ∂ f      ∂ g
----  =  -----   ------
∂ x       ∂ g      ∂ x    (g는 f에 영향을 주고)(g는 x에 영향을 줌)
      =     1      w


■ backpropagation 역전파  (역으로 가기 위해서는 weight, bias를 조정해야 한다. -> 무엇으로? 미분으로 조정한다. ; 이를 통해 오차를 줄일 수 있다.)

- cost function
신경망 학습에서 학습데이터에 대한 오차를 측정하는 척도 

    - 평균제곱오차(mean squared error, MSE): 1/m Σ(ytarget- y)²  #tensorflow의 method: tf.reduce_mean
        :일반적으로 많이 사용한다. 
        
    - 오차 = 1/2 Σ(ytarget- y)²
        - ytarget: 목표값 
        - y: 예측값
        - minus를 하면 음수가 나올 수 있기 때문에 제곱이 필요하다. 
        - 오차를 만드는 원인: weight, bias 

import numpy as np

t = np.array([0,0,0,0,1,0,0,0,0,0])
y = np.array([0.1,0.03,0.05,0.2,0.9,0.0,0.1,0.2,0.12,0.03])

sum((t-y)**2)/2

def mse(t,y):
    return 0.5*np.sum((t-y)**2)
print("오차는",mse(t,y))

    
    
■ gradient descendent method(경사하강법); 어떻게 하면 오차를 줄일 수 있을까? (tf.train.GradientDescentOptimizer는 편미분을 자동적으로 해준다.)
 ∂E  (Error rate)
---- 
 ∂w  
 
w(weight)수정 = w - ∂E/ ∂w
    - E: Error rate
=> 기존의 weight - weight값의 미분한 값을 계속 빼면서 기울기를 내려가게 하는 방법

=> 기울기 조정은 : learning rate(α)을 주면서 weight 값을 조정해야 한다. 
w(weight)수정 = w - α *∂E/ ∂w (α: learning rate)
    - α: 미세하게 움직일지, 큼직하게 움직일지(다른쪽으로 넘어가버릴 수도 있다.) 
    

■ linear regression
입력(x)     출력(y)
------     -------
1           2
2           4
3           6
4           8
5           10
6           12

7를 입력하면 출력값은? 

y = w*x + b

2 = w + b
4 = 2w + b

import tensorflow as tf

x_data = [1,2,3,4,5,6]      #입력값
y_data = [2,4,6,8,10,12]    #실제 target 
y = w*x + b                 #여기서 y는 예측값 

x = tf.placeholder(tf.float32)
y = tf.placeholder(tf.float32)
w = tf.Variable(tf.random_normal([1], seed=0), name="weihgt")  #tf.random_normal: 한자리 난수를 가져옴, #seed=0 난수값을 고정시킴
b = tf.Variable(tf.random_normal([1], seed=0), name="bias")

hypothesis = w*x + b

cost = tf.reduce_mean(tf.square(hypothesis-y)) 
#tf.square :tensor에서 제공하는 제곱 
#tf.reduce_mean: 평균의 합 

# cost값을 조정하기 위해서는 weight, bias를 조정해야 한다. => 미분이 들어가야 한다. (미분을 통해 로직 구현을 하면 된다.)
# 경사하강법을 사용: cost를 줄이기 위해서, cost값을 조정함 
optimizer = tf.train.GradientDescentOptimizer(learning_rate = 0.001) #learning_rate는 조정해줘야 함  #GradientDescentOptimizer: 이 method를 통해 미분을 사용한다. (일반적으로 편미분을 말한다.)
#cost를 최소화 시켜줘야한다.  
train = optimizer.minimize(cost)

#즉, 위의 과정이 연쇄화처럼 돌아가게 된다. 

#session을 열어 시작 
sess = tf.Session()
sess.run(tf.global_variables_initializer())  #variable은 초기화 시켜아한다.
#for 문을 사용하여 
for step in range(2001):
    cost_v, w_v, b_v, _ = sess.run([cost, w, b, train], feed_dict={x:x_data, y:y_data}) # _:underscope는 위치자임; train에 대해 들어 갈 것이 없기 때문에  
    if step % 20 == 0:
        print(step, cost_v, w_v, b_v)

#(step, cost_v, w_v, b_v)
#0 94.1615 [-0.32358906] [-0.38156518]
#20 25.674927 [0.76995075] [-0.12730911]
#40 7.0030427 [1.3410589] [0.00492619]
#60 1.9123893 [1.639381] [0.07345283]
#80 0.5244544 [1.7952688] [0.10871811]
#.................................
#1920 0.001107541 [1.9822853] [0.0758381]
#1940 0.001091486 [1.982414] [0.07528657]
#1960 0.0010756744 [1.9825425] [0.074739]
#1980 0.0010600793 [1.9826689] [0.07419543]
#2000 0.0010447168 [1.9827952] [0.07365584]

#예측하기
print(sess.run(hypothesis, feed_dict = {x:7}))
print(sess.run(hypothesis, feed_dict = {x:10}))


# =============================================================================
# 자율학습

#learhing 숫자바꿔보기 
x_data = [1,2,3,4,5,6]      #입력값
y_data = [2,4,6,8,10,12]    #실제 target 
              #여기서 y는 예측값 
x = tf.placeholder(tf.float32)
y = tf.placeholder(tf.float32)
w = tf.Variable(tf.random_normal([1], seed=0), name="weihgt")  #tf.random_normal: 한자리 난수를 가져옴, #seed=0 난수값을 고정시킴
b = tf.Variable(tf.random_normal([1], seed=0), name="bias")

hypothesis = w*x + b

cost = tf.reduce_mean(tf.square(hypothesis-y)) 

optimizer = tf.train.GradientDescentOptimizer(learning_rate = 0.05)  #
train = optimizer.minimize(cost)
sess = tf.Session()
sess.run(tf.global_variables_initializer()) 
for step in range(2001):
    cost_v, w_v, b_v, _ = sess.run([cost, w, b, train], feed_dict={x:x_data, y:y_data}) # _:underscope는 위치자임; train에 대해 들어 갈 것이 없기 때문에  
    if step % 20 == 0:
        print(step, cost_v, w_v, b_v)
print(sess.run(hypothesis, feed_dict = {x:150}))
print(sess.run(hypothesis, feed_dict = {x:58}))
sess.close()

#dataset 바꿔보기, step 수도 바꿔보기, 등등등
x_data = [1,3,4,7,15,58]      #입력값
y_data = [2,14,26,58,89,190]  


x = tf.placeholder(tf.float32)
y = tf.placeholder(tf.float32)
w = tf.Variable(tf.random_normal([1], seed=0), name="weihgt")  #tf.random_normal: 한자리 난수를 가져옴, #seed=0 난수값을 고정시킴
b = tf.Variable(tf.random_normal([1], seed=0), name="bias")

hypothesis = w*x + b

cost = tf.reduce_mean(tf.square(hypothesis-y)) 

optimizer = tf.train.GradientDescentOptimizer(learning_rate = 0.0015)  #
train = optimizer.minimize(cost)
sess = tf.Session()
sess.run(tf.global_variables_initializer()) 
for step in range(10000):
    cost_v, w_v, b_v, _ = sess.run([cost, w, b, train], feed_dict={x:x_data, y:y_data}) # _:underscope는 위치자임; train에 대해 들어 갈 것이 없기 때문에  
    if step % 20 == 0:
        print(step, cost_v, w_v, b_v)
print(sess.run(hypothesis, feed_dict = {x:150}))
print(sess.run(hypothesis, feed_dict = {x:58}))


# =============================================================================

기울기 = 4.3
절편 = 64

공부시간     점수
-----------------
2           71
4           83
6           91
8           97

ab = [4.3, 64]      #미리 기울기와 절편값을 알고 있음 -> 따라서 predict를 할 수 있음 
data = [[2,71],[4,83],[6,91],[8,97]]

#리스트 내장객체 사용
x = [i[0] for i in data]
y = [i[1] for i in data]

#예측된 값 ab를 return값에 넣어 주기: 기울기와 절편값
def predict(x):
    return ab[0]*x + ab[1]

predict(2)  #Out[222]: 72.6

#오차 함수 만들기
RMSE(Root Mean Squared Error) 평균제곱근오차
def rmse(p,a):
    return np.sqrt(((p-a)**2).mean())

def rmse_val(predict_result, y):
    return rmse(np.array(predict_result), np.array(y))

predict_result = []
for i in range(len(x)):
    predict_result.append(predict(x[i]))
    print("공부시간 : %.f, 실제점수 : %.f, 예측점수 : %.f"%(x[i],y[i],predict(x[i])))
    
#공부시간 : 2, 실제점수 : 71, 예측점수 : 73
#공부시간 : 4, 실제점수 : 83, 예측점수 : 81
#공부시간 : 6, 실제점수 : 91, 예측점수 : 90
#공부시간 : 8, 실제점수 : 97, 예측점수 : 98    
    
print("오차 : ",rmse_val(predict_result, y))
#오차 :  1.5165750888103096


▣ 선형회귀
- 임의의 직선을 그어 이에 대한 평균제곱근오차를 구하고 이값을 가장 작게 만들어 주는 기울기와 절편을 찾아가는 작업 
- 기울기와 절편이 이미 만들어져 있을 때 
- 기울기와 절편이 없을 때 (Gradient Descent): 임의의 선을 어디에 그어야 최적인지(오차를 최소로 줄일 수 있는지)의 작업 -> 이에 알맞는 기울기와 절편을 구하기

# =============================================================================
# 기울기와 절편이 없을 때 wieght, bias 구하기: 평균제곱오차 적용시(편차제곱 합의 평균) 
# 스스로 해 보기 
data = [[2,71],[4,83],[6,91],[8,97]]
x_data = [i[0] for i in data]
y_data = [i[1] for i in data]

x = tf.placeholder(tf.float32)
y = tf.placeholder(tf.float32)
w = tf.Variable(tf.random_normal([1], seed=0), name="weihgt")  #tf.random_normal: 한자리 난수를 가져옴, #seed=0 난수값을 고정시킴
b = tf.Variable(tf.random_normal([1], seed=0), name="bias")

hypothesis = w*x + b

cost = tf.reduce_mean(tf.square(hypothesis-y)) 

optimizer = tf.train.GradientDescentOptimizer(learning_rate = 0.001)  #
train = optimizer.minimize(cost)
sess = tf.Session()
sess.run(tf.global_variables_initializer()) 
for step in range(20001):
    cost_v, w_v, b_v, _ = sess.run([cost, w, b, train], feed_dict={x:x_data, y:y_data}) # _:underscope는 위치자임; train에 대해 들어 갈 것이 없기 때문에  
    if step % 20 == 0:
        print("Step: %.f, Cost = %.f, 기울기 w = %.f, 절편 b = %.f"%(step, cost_v, w_v, b_v))

#Step: 20000, Cost = 2, 기울기 w = 4, 절편 b = 64

print(sess.run(w))  #[4.3158374]
print(sess.run(b))  #[63.905476]
print(sess.run(hypothesis, feed_dict = {x:2}))  #[81.16882]
print(sess.run(hypothesis, feed_dict = {x:4}))  #[81.16882]
print(sess.run(hypothesis, feed_dict = {x:6}))  #[89.8005]
print(sess.run(hypothesis, feed_dict = {x:8}))  #[98.432175]

sess.close()

# =============================================================================
# 기울기와 절편이 없을 때 wieght, bias 구하기: 평균제곱근오차를 사용하여 
# 스스로 해 보기 
data = [[2,71],[4,83],[6,91],[8,97]]
x_data = [i[0] for i in data]
y_data = [i[1] for i in data]

#x = tf.placeholder(tf.float32)
#y = tf.placeholder(tf.float32)
w = tf.Variable(tf.random_normal([1], seed=0), name="weihgt")  #tf.random_normal: 한자리 난수를 가져옴, #seed=0 난수값을 고정시킴
b = tf.Variable(tf.random_normal([1], seed=0), name="bias")

predict = w*x_data + b

#오차 함수 만들기
#RMSE(Root Mean Squared Error) 평균제곱근오차
rmse = tf.sqrt(tf.reduce_mean(tf.square(predict-y_data)))


optimizer = tf.train.GradientDescentOptimizer(learning_rate = 0.01)
train = optimizer.minimize(rmse)  #rmse = cost 


# learning_rate = 0.1
#gradeint_decent = tf.train.GradientDescentOptimizer(learning_rate).minimize(rmse)

with tf.Session() as Sess:
    sess.run(tf.global_variables_initializer())
    for step in range(20001):
        sess.run(train)
        if step%20 ==0:
            print("Step: %f, RSME = %.f, 기울기 w = %.f, 절편 b = %.f"%(step, sess.run(rmse), sess.run(w), sess.run(b)))
 
#learning_rate = 0.001일때            
#Step: 20000.000000, RSME = 22, 기울기 w = 13, 절편 b = 10

#learning_rate = 0.01일때   
#Step: 20000.000000, RSME = 2, 기울기 w = 4, 절편 b = 64



# =============================================================================
# 기울기와 절편이 없을 때 wieght, bias 구하기: 평균제곱오차 적용시(편차제곱 합의 평균) 
            
# 선생님 버전 : learning_rate -> 0.1 / learning_rate -> 0.001 등 learning_rate의 튜닝과  (제곱근이 안되어있기 때문에 값이 크기 때문에 작은 값으로 곱해야한다. learning_rate를 작게 해보자!)
#            range(10001)로 수정해 보자
data = [[2,71],[4,83],[6,91],[8,97]]
x_data = [i[0] for i in data]
y_data = [i[1] for i in data]

x = tf.placeholder(tf.float32)
y = tf.placeholder(tf.float32)
w = tf.Variable(tf.random_normal([1], seed=0), name="weihgt")  #tf.random_normal: 한자리 난수를 가져옴, #seed=0 난수값을 고정시킴
b = tf.Variable(tf.random_normal([1], seed=0), name="bias")

hypothesis = w*x + b

cost = tf.reduce_mean(tf.square(hypothesis-y)) 

# learning_rate =0.1 , range(2001) 로 했을 때 
optimizer = tf.train.GradientDescentOptimizer(learning_rate = 0.1)  #
train = optimizer.minimize(cost)
sess = tf.Session()
sess.run(tf.global_variables_initializer()) 
for step in range(2001):
    cost_val, w_val, b_val, _ = sess.run([cost, w, b, train], feed_dict={x:x_data, y:y_data}) # _:underscope는 위치자임; train에 대해 들어 갈 것이 없기 때문에  
    if step % 20 == 0:
        print("Step: %.f, Cost = %.f, 기울기 w = %.f, 절편 b = %.f"%(step, cost_val, w_val, b_val))
#Step: 2000, Cost = nan, 기울기 w = nan, 절편 b = nan
    

# learning_rate =0.001 , range(10001) 로 했을 때 
optimizer = tf.train.GradientDescentOptimizer(learning_rate = 0.001)  #
train = optimizer.minimize(cost)
sess = tf.Session()
sess.run(tf.global_variables_initializer()) 
for step in range(10001):
    cost_val, w_val, b_val, _ = sess.run([cost, w, b, train], feed_dict={x:x_data, y:y_data}) # _:underscope는 위치자임; train에 대해 들어 갈 것이 없기 때문에  
    if step % 1000 == 0:
        print(step, cost_val, w_val, b_val)
#10000 3.272409 [4.7046027] [61.585506]

print(sess.run(hypothesis, feed_dict= {x:7}))
#[94.51773]

# =============================================================================
# 기울기와 절편이 없을 때 wieght, bias 구하기: 평균제곱근오차를 사용하여 
#선생님 버전: learning_rate -> 0.1
data = [[2,71],[4,83],[6,91],[8,97]]
x_data = [i[0] for i in data]
y_data = [i[1] for i in data]

x = tf.placeholder(tf.float32)
y = tf.placeholder(tf.float32)
w = tf.Variable(tf.random_normal([1], seed=0), name="weihgt")  #tf.random_normal: 한자리 난수를 가져옴, #seed=0 난수값을 고정시킴
b = tf.Variable(tf.random_normal([1], seed=0), name="bias")

hypothesis = w*x_data + b
rmse = tf.sqrt(tf.reduce_mean(tf.square(hypothesis-y)))

optimizer = tf.train.GradientDescentOptimizer(learning_rate = 0.1)
train = optimizer.minimize(rmse)

sess = tf.Session()
sess.run(tf.global_variables_initializer())
for step in range(2001):
    rmse_val, w_val, b_val, _ = sess.run([rmse, w, b, train], feed_dict={x:x_data, y:y_data})
    if step%100 == 0:
        print(step, rmse_val, w_val, b_val)
# 2000 1.517429 [4.2952394] [63.972393]
        
print(sess.run(hypothesis, feed_dict= {x:7}))
#[72.562874 81.15335  89.74383  98.334305]

#learning_rate  -> 0.001로 넣을 때 (제곱근을 해버리니깐 값이 엄청 작아져, learning_rate을 작은값으로 곱할 경우 값이 나오지 않게 된다.)
optimizer = tf.train.GradientDescentOptimizer(learning_rate = 0.0001)
train = optimizer.minimize(rmse)

sess = tf.Session()
sess.run(tf.global_variables_initializer())
for step in range(2001):
    rmse_val, w_val, b_val, _ = sess.run([rmse, w, b, train], feed_dict={x:x_data, y:y_data})
    if step%100 == 0:
        print(step, rmse_val, w_val, b_val)
# 2000 38.879887 [9.352289] [1.5858985]
        
print(sess.run(hypothesis, feed_dict= {x:7}))
#[20.290478 38.995056 57.699635 76.40421 ]


# =============================================================================
# 문제 linear regression 학습을 통해서 입력값에 대한 예측값을 출력하세요. 
# 
# x1 x2 x3   y
# --------------
# 73 80 75  152
# 93 88 93  185
# 89 92 90  180
# 96 98 100 196
# 73 66 70  142
#
#print("당신의 점수는 ", sess.run(hypothesis, feed_dict = {x1: 100, x2: 70, x3: 60}))
#
#힌트: y = w1 * x1 + w2 * x2 + w3 * x3 + b 
# x1,x2,x3는 확정된 값
# w1, w2, w3, b는 정해야 하는 값 
# =============================================================================

x1_data = [73, 93, 89, 96, 73]
x2_data = [80, 88, 92, 98, 66]
x3_data = [75, 93, 90, 100 , 70]
y_data = [152, 185, 180, 196, 142]


x1 = tf.placeholder(tf.float32)     # data를 run 시점에 넣을 것임
x2 = tf.placeholder(tf.float32)
x3 = tf.placeholder(tf.float32)

y = tf.placeholder(tf.float32)

w1 = tf.Variable(tf.random_normal([1], seed=0), name="weihgt1")  #tf.random_normal: 한자리 난수를 가져옴, #seed=0 난수값을 고정시킴
w2 = tf.Variable(tf.random_normal([1], seed=0), name="weihgt2") 
w3 = tf.Variable(tf.random_normal([1], seed=0), name="weihgt3") 
b = tf.Variable(tf.random_normal([1], seed=0), name="bias")
    

hypothesis = w1 * x1 + w2 * x2 + w3 * x3 + b 

cost = tf.reduce_mean(tf.square(hypothesis-y))
#rmse = tf.sqrt(tf.reduce_mean(tf.square(hypothesis-y)))

# ====================learning_rate = 0.00001
optimizer = tf.train.GradientDescentOptimizer(learning_rate = 0.00001)
train = optimizer.minimize(cost)

sess = tf.Session()
sess.run(tf.global_variables_initializer())
for step in range(100001):
    cost_val, hy_val, _ = sess.run([cost, hypothesis, train], feed_dict={x1:x1_data, x2:x2_data, x3:x3_data, y:y_data})
    if step%10000 == 0:
        print(step, cost_val, hy_val)    
#값이 nan 나오면 큼직하게 내려가다가 그래프 선상에서 바깥으로 나오기 때문에 학습률을 줄이는 작업을 해야한다.

#0 75768.92 [ -91.40709  -109.76834  -108.57087  -117.751495  -83.8231  ]
#10000 0.44027776 [151.09657 184.69226 180.8661  196.54204 141.50345]
#20000 0.40287417 [151.0501  184.73642 180.86674 196.42232 141.66388]
#30000 0.38355592 [151.08208 184.72041 180.89647 196.3423  141.72395]
#40000 0.37186092 [151.11092 184.70503 180.92105 196.2812  141.76672]
#50000 0.36473194 [151.13353 184.69293 180.94005 196.23404 141.79967]
#60000 0.3603143 [151.15121 184.68349 180.95462 196.19768 141.82513]
#70000 0.3575406 [151.16498 184.67606 180.96576 196.16953 141.84485]
#80000 0.3557214 [151.17549 184.67049 180.97414 196.14772 141.86053]
#90000 0.35449666 [151.18388 184.666   180.98055 196.13098 141.8725 ]
#100000 0.35361928 [151.19038 184.66255 180.98532 196.11807 141.8819 ]    

print("당신의 점수는 ", sess.run(hypothesis, feed_dict = {x1: 100, x2: 70, x3: 60}))
#당신의 점수는  [166.4719]


# ====================learning_rate = 0.000001
optimizer = tf.train.GradientDescentOptimizer(learning_rate = 0.000001)
train = optimizer.minimize(cost)

sess = tf.Session()
sess.run(tf.global_variables_initializer())
for step in range(100001):
    cost_val, hy_val, _ = sess.run([cost, hypothesis, train], feed_dict={x1:x1_data, x2:x2_data, x3:x3_data, y:y_data})
    if step%10000 == 0:
        print(step, cost_val, hy_val)    
        
print("당신의 점수는 ", sess.run(hypothesis, feed_dict = {x1: 100, x2: 70, x3: 60}))
#당신의 점수는  [160.70312]


# =============================================================================

#확인하기: weight 값을 출력하면 왜 이렇게 나오나요?
#for step in range(100001):
#    cost_val, hy_val, w1_val, w2_val, w3_val, _ = sess.run([cost, hypothesis, w1, w2, w3, train], feed_dict={x1:x1_data, x2:x2_data, x3:x3_data, y:y_data})
#    if step%10000 == 0:
#        print(step, cost_val, hy_val, w1_val, w2_val, w3_val)    
#60000 0.41393796 [151.04512 184.73627 180.85684 196.46237 141.62534] [0.92375475] [0.44092336] [0.64937156]
#70000 0.41083837 [151.04492 184.73756 180.85886 196.4515  141.63716] [0.92733103] [0.44155437] [0.64519924]
#80000 0.40793252 [151.04628 184.73743 180.86139 196.44104 141.64697] [0.93061006] [0.4424184] [0.6410882]
#90000 0.40531117 [151.04822 184.73692 180.86409 196.43153 141.65564] [0.9335903] [0.44331247] [0.6372439]
#100000 0.40274936 [151.05019 184.73643 180.86679 196.42203 141.66429] [0.9365705] [0.44420654] [0.63340026]

# =============================================================================
#hypothesis = w1 * x1 + w2 * x2 + w3 * x3 + b 를 행렬의 곱으로 개선시키려고 함
# x의 열과[None, 3], w[3, 1]의 행의 값을 맞추도록 한다.  -> 따라서 y는 [None, 1] 이 됨

x_data = [[73,80,75],[93,88,93],[89,91,90],[96,98,100],[73,66,70]]
y_data = [[152],[185],[180],[196],[142]]

x = tf.placeholder(tf.float32, shape=[None,3]) #shape의 None이 되어있을 경우는, 몇행이 들어올지 모르는 상황일 때/ 열은 3열로 고정됨  #모든 행의 3열
y = tf.placeholder(tf.float32, shape=[None,1]) #모든 행의 1열

#[3,1] 3:x의(열값) 들어오는 값 / 1: y로 나가는 값 
w = tf.Variable(tf.random_normal([3,1], seed=0), name='weight') #weight값은 난수값, x의 shape의 열에 맞춰 weight값을 맞춘다. [3,1] 
#[1] 1: y로 나가는값 
b = tf.Variable(tf.random_normal([1], seed=0), name= 'bias')

hypothesis = tf.matmul(x,w)+b

cost = tf.reduce_mean(tf.square(hypothesis-y))
optimizer = tf.train.GradientDescentOptimizer(learning_rate = 0.000001)
train = optimizer.minimize(cost)

sess = tf.Session()
sess.run(tf.global_variables_initializer())
for step in range(100001):
    cost_val, hy_val, _ = sess.run([cost, hypothesis, train], feed_dict={x:x_data, y:y_data})
    if step%10000 == 0:
        print(step, cost_val, hy_val)    
        
print("당신의 점수는 ", sess.run(hypothesis, feed_dict = {x: [[100,70,60]]}))

# =============================================================================
data는 file자체로 있기 때문에 파일에 있는 데이터를 불러들이도록 해야한다. 

#파일유형 = 모든 텍스트 / 파일명 = 1105ex.csv 로 저장한 다음
73,80,75, 152
93,88,93, 185
89,91,90, 180
96,98,100, 196
73,66,70, 142

import tensorflow as tf
import numpy as np

#numpy로 data불러들이기: np.loadtxt()
xy = np.loadtxt("c:/data/1105ex.csv", delimiter=",", dtype=np.float32) #delimiter="," 구분자/ dtype=np.float32 불러들일 데이터 형식
xy
#array([[ 73.,  80.,  75., 152.],
#       [ 93.,  88.,  93., 185.],
#       [ 89.,  91.,  90., 180.],
#       [ 96.,  98., 100., 196.],
#       [ 73.,  66.,  70., 142.]], dtype=float32)

#slicing하기  (슬라이싱 할 때 주의할 점) -> 목표변수 만들기
x_data = xy[:,0:-1]
#Out[473]: 
#array([[ 73.,  80.,  75.],
#       [ 93.,  88.,  93.],
#       [ 89.,  91.,  90.],
#       [ 96.,  98., 100.],
#       [ 73.,  66.,  70.]], dtype=float32)
y_data = xy[:,[-1]]
#Out[477]: 
#array([[152.],
#       [185.],
#       [180.],
#       [196.],
#       [142.]], dtype=float32)
x_data.shape     #Out[478]: (5, 3)
y_data.shape     #Out[479]: (5, 1)

# *** 슬라이싱 주의사항 *****  ######
#y_data = xy[:,-1] 로 하게 되면 1행의 5열로 만들어짐  (1행 5열)  Out[475]: array([152., 185., 180., 196., 142.], dtype=float32)
#y_data = xy[:,[-1]] 로 하게 되면 5행 1열로 만들어짐 (5행 1열)

# run time 시점에 x, y 데이터를 넣기 위해 placeholder를 만듦 
x = tf.placeholder(tf.float32, shape=[None,3])
y = tf.placeholder(tf.float32, shape=[None,1])

#weight값, bias값 
w = tf.Variable(tf.random_normal([3,1], seed=0), name='weight')
b = tf.Variable(tf.random_normal([1], seed=0), name='bias')

hypothesis = tf.matmul(x,w)+b

cost = tf.reduce_mean(tf.square(hypothesis-y))
optimizer = tf.train.GradientDescentOptimizer(learning_rate = 0.000001)
train = optimizer.minimize(cost)

sess = tf.Session()
sess.run(tf.global_variables_initializer())
for step in range(100001):
    cost_val, hy_val, _ = sess.run([cost, hypothesis, train], feed_dict={x:x_data, y:y_data})
    if step%10000 == 0:
        print(step, cost_val, hy_val)    
#90000 0.18888655 [[151.4298 ]
# [184.67465]
# [180.66763]
# [196.22499]
# [141.86926]]
#100000 0.18839629 [[151.43077]
# [184.67445]
# [180.66846]
# [196.22124]
# [141.87273]]        

print("당신의 점수는", sess.run(hypothesis, feed_dict ={x:[[100,70,60]]}))
#여러 명의 값을 구하고자 할 때 
print("당신의 점수는", sess.run(hypothesis, feed_dict ={x:[[100,70,60], [90,100,80]]}))



# -*- coding: utf-8 -*-
"""
Created on Tue Nov  6 09:54:24 2018

@author: stu
"""

▣ linear regression - 예측 

# =============================================================================


▣ binary classfication (0아니면 1로 분류)

#입력값: 데이터가 문자가 아닌 숫자여야 한다. 
#출력값(목표값): 데이터가 문자가 아닌 숫자여야 한다.   -> One-hot encoding 필요 

import tensorflow as tf
x_data = [[1,2],[2,3],[3,1],[4,3],[5,3],[6,2]]  #[1,2] 공부시간 1시간, 게임시간 2시간 
y_data = [[0],[0],[0],[1],[1],[1]]  #[0] 불합격 [1]합격 

#tensor 모양으로 바꾸기
x = tf.placeholder(tf.float32, shape=[None, 2])
y = tf.placeholder(tf.float32, shape=[None, 1])

w = tf.Variable(tf.random_normal([2,1]), name='weight')
b = tf.Variable(tf.random_normal([1]), name='bias')

#기존 hypothesis
#hypothesis = tf.matmul(x,w) + b 

#affine sum을 하면 숫자가 크게 된다. 그러나 숫자는 0과 1사이에서 나와야 하기 때문에 activation function(sigmoid, step function)을 통해서 출력값을 출력하도록 한다. 
hypothesis = tf.sigmoid(tf.matmul(x,w) + b)
#0과 1사이, 실수이기 때문에 sigmoid 값도 미분을 해야한다. (즉, w, b를 조정하여 미분해야 하는데, sigmoid도 미분해야하기 때문에, 골격 생긴 그래프가 만들어진다.)
#sigmoid를 gradient descent를 쓰면서 골격이 생기기 때문에 수평을 바로 마주하기 때문에 바로 에러율이 없다고 나올 경우가 많다. 사실 최소 에러율이 도달하지 않았는데도 에러율이 없다고 출력하게 되는 문제가 생긴다.  -> 잘못된 예측 
#sigmoid를 하는 순간 오차함수가 문제가 될 수 있다. 
#log0 = 1 / log1 = ∞  (무한이면 우리가 원하는 예측이 아님) -> 따라서 log를 사용하면 에러율을 잘못 예측한 것을 막을 수 있다. 

■ cost function: 1과 0으로 return 하게 됨 
#cf. 기존의 cost function: 편차제곱의 합의 평균 
logisctic cost function은 두가지를 만들어서 사용하도록 한다.  -> 두가지를 만들어서 사용하기 때문에 조건제어문이 필요하다. 

y = 1      -y*log(h(x))
y = 0      (1-y)*log(1-h(x))
 
위의 두 식을 붙여서 만들면 (로그값을 통해 계산함) 

cost = -tf.reduce_mean(y*tf.log(hypothesis)+(1-y)*tf.log(1-hypothesis))
#y=1이면 (1-y)*tf.log(1-hypothesis)가 없어지고 y*tf.log(hypothesis만 계산
#y=0이면 y*tf.log(hypothesis)가 없어지고 (1-y)*tf.log(1-hypothesis)만 계산

train = tf.train.GradientDescentOptimizer(learning_rate=0.01).minimize(cost)

predict = tf.cast(hypothesis > 0.5, dtype=tf.float32)
## tf.cast(hypothesis > 0.5 : 이부분이 조건제어문과 같다. 0.5보다 크면 True, 0.5와 같거나 작으면 False
# 밑의 조건제어문 처럼 작용한다. ##
if hypothesis > 0.5 then 
    True(1.0)
else: 
    False(0.0)
##################################

accuracy = tf.reduce_mean(tf.cast(tf.equal(predict, y), dtype=tf.float32))
#(tf.cast(tf.equal(predict, y), dtype=tf.float32))에 대한 평균을 내어 정확도를 예측 

with tf.Session() as sess:
    sess.run(tf.global_variables_initializer())
    for step in range(10001):
        cost_val, _ = sess.run([cost, train], feed_dict={x:x_data, y:y_data})
        if step %200 == 0:
            print(step, cost_val)
    h, c, a  = sess.run([hypothesis, predict, accuracy], feed_dict={x: x_data, y:y_data})
    print ("hypothesis : ",h)
    print ("predict : ",c)
    print ("accuracy: ",a)

#hypothesis :  [[0.03072654]
# [0.15882765]
# [0.3048026 ]
# [0.7814115 ]
# [0.9395937 ]
# [0.9801752 ]]
#predict :  [[0.]
# [0.]
# [0.]
# [1.]
# [1.]
# [1.]]
#accuracy:  1.0


# =============================================================================
# 다층퍼셉트론(and+nand -> xor) 으로 구분한 XOR 분류의 문제를 신경망을 통해 해결해보기 
# 단층퍼셉트론에서 되지 않았던 것처럼, 신경망에서도 층에 대해서 생각해봐야한다.
# logistic regression classifier : 0아니면 1의 값
# 
# [문제] XOR 를 logistic regression classifier를 이용해서 프로그램을 생성하세요.
# 
# 입력값  출력값 
# ------------
# 0 0    0
# 0 1    1
# 1 0    1 
# 1 1    0
# =============================================================================
#은닉층을 만들어야 한다. 
    
x_data = [[0,0],[0,1],[1,0],[1,1]]
y_data = [[0],[1],[1],[0]]

x = tf.placeholder(tf.float32, shape=[None, 2])
y = tf.placeholder(tf.float32, shape=[None, 1])

w1 = tf.Variable(tf.random_normal([2,2], seed=0),  name='weight1')
b1 = tf.Variable(tf.random_normal([2], seed=0), name='bias1')
layer1 = tf.sigmoid(tf.matmul(x,w1) + b1)

w2 = tf.Variable(tf.random_normal([2,1], seed=0),  name='weight2')
b2 = tf.Variable(tf.random_normal([1], seed=0), name='bias2')
hypothesis = tf.sigmoid(tf.matmul(layer1,w2) + b2)

cost = -tf.reduce_mean(y*tf.log(hypothesis)+(1-y)*tf.log(1-hypothesis))

train = tf.train.GradientDescentOptimizer(learning_rate=0.01).minimize(cost)

predict = tf.cast(hypothesis > 0.5, dtype=tf.float32)

accuracy = tf.reduce_mean(tf.cast(tf.equal(predict, y), dtype=tf.float32))


with tf.Session() as sess:
    sess.run(tf.global_variables_initializer())
    for step in range(10001):
        cost_val, _ = sess.run([cost, train], feed_dict={x:x_data, y:y_data})
        if step %200 == 0:
            print(step, cost_val)
    h, c, a  = sess.run([hypothesis, predict, accuracy], feed_dict={x: x_data, y:y_data})
    print ("hypothesis : ",h)
    print ("predict : ",c)
    print ("accuracy: ",a)
    


########################
#쌤답안 
import tensorflow as tf
import numpy as np

x_data = [[0,0],[0,1],[1,0],[1,1]]
y_data = [[0],[1],[1],[0]]
x_data = np.array(x_data, dtype=np.float32)
y_data = np.array(y_data, dtype=np.float32)

x = tf.placeholder(tf.float32, [None, 2])
y = tf.placeholder(tf.float32, [None, 1])

#input layer층 
w1 = tf.Variable(tf.random_normal([2,5], seed=0),  name='weight1')  #두개가 나가니 b1에 2개의 bias가 생긴다. 
b1 = tf.Variable(tf.random_normal([5], seed=0), name='bias1')  
layer1 = tf.sigmoid(tf.matmul(x,w1) + b1)

#hidden layer2 층 
w2 = tf.Variable(tf.random_normal([5,4], seed=0),  name='weight2')  
b2 = tf.Variable(tf.random_normal([4], seed=0), name='bias2')  
layer2 = tf.sigmoid(tf.matmul(layer1,w2) + b2)

#hidden layer3 만들기
w3 = tf.Variable(tf.random_normal([4,4], seed=0),  name='weight3')  
b3 = tf.Variable(tf.random_normal([4], seed=0), name='bias3')  
layer3 = tf.sigmoid(tf.matmul(layer2,w3) + b3)

#output layer
w4 = tf.Variable(tf.random_normal([4,1], seed=0),  name='weight4')  
b4 = tf.Variable(tf.random_normal([1], seed=0), name='bias4')  
hypothesis = tf.sigmoid(tf.matmul(layer3,w4) + b4)

#cross entropy cost function 
cost = -tf.reduce_mean(y*tf.log(hypothesis)+(1-y)*tf.log(1-hypothesis))

#학습률 조절하기 0.1 -> 0.5 ->
train = tf.train.GradientDescentOptimizer(learning_rate=0.5).minimize(cost)


predict = tf.cast(hypothesis > 0.5, dtype=tf.float32)

accuracy = tf.reduce_mean(tf.cast(tf.equal(predict, y), dtype=tf.float32))


sess = tf.Session()
sess.run(tf.global_variables_initializer())
for step in range(10001):
    sess.run(train, feed_dict={x:x_data, y:y_data})
    if step%1000 == 0:
        print(step, sess.run(cost, feed_dict={x:x_data, y:y_data}))
        h = sess.run(hypothesis, feed_dict={x:x_data, y:y_data})
        print(h)

a = sess.run(hypothesis, feed_dict = {x:[[0,0],[0,1],[1,0],[1,1]]})
print(sess.run(tf.cast(a>0.5, dtype=tf.int32))) #0.5보다 크면 1, 0.5같거나 작으면 0으로 출력 [0],[0],[0],[1]으로 출력해야 함 

#코스트가 작았어도 값이 잘 안나왔을 경우, 은닉층을 더 둬야한다. 
#학습율 조절 

▣ multi classification (softmax classifier)
# 종속변수를 one-hot encoding  -> y값이 3개로 분류 된다면, y1, y2, y3로 만들어 one-hot encoding이 되도록 하자. 
# softmax 이용 -> 확률을 기반으로 큰쪽으로 분류하자  
# 기존의 cost function을 cross_entroy function 이라고 하는데, 이를 기반으로 하여 softmax를 사용할 수 있도록 tensor에서 제공한다. 
# -> cost = tf.reduce_mean(tf.nn.softmax_cross_entropy_with_logits(logits=logits, labels=y_one_hot))
# argmax를 통해서 보여주는 값은 고객들에게 [0],[1],[2]라고 나타날 때, 해석해줄 줄 알아야 한다. 예를 들어, [0] 인덱스를 a로 , [1]인덱스를 b로, [2]인덱스를 c로  

''' 
train.txt 파일로 저장 

#x0,x1,x2,y
1,2,1,0
1,3,2,0
1,3,4,0
1,5,5,1
1,7,5,1
1,2,5,1
1,6,6,2
1,7,7,2

'''

import numpy as np

xy = np.loadtxt("c:/data/train.txt", delimiter=",", dtype=np.float32)

x_data = xy[:,0:-1]
y_data = xy[:,[-1]]

x = tf.placeholder(tf.float32, [None,3])
y = tf.placeholder(tf.int32, [None,1]) #one-hot encoding은 0아니면 1이기 때문에 integer형으로 해야함 
# y를 tf.float32로 할 경우 밑의 error가 뜬다.
# TypeError: Value passed to parameter 'indices' has DataType float32 not in list of allowed values: uint8, int32, int64


#None을 한 이유는 y 데이터는 0,1,2인데 logistic regression처럼 0과 1로 표현이 되어있어야한다. -> one-hot encoding을 해야한다. 
#tensor에서 제공하는 one-hot encoding: y:목표값 ,3: 범주는 3개
y_one_hot = tf.one_hot(y,3)    #Out[360]: <tf.Tensor 'one_hot_3:0' shape=(?, 1, 3) dtype=float32>

#3차원 배열로 만들지 않을 것이기 때문에 reshape을 해준다.
#[-1,3] : -1은 None이라고 생각하면 된다.
y_one_hot = tf.reshape(y_one_hot, [-1,3])   #Out[363]: <tf.Tensor 'Reshape:0' shape=(?, 3) dtype=float32>

w = tf.Variable(tf.random_normal([3,3]), name='weight')
b = tf.Variable(tf.random_normal([3]), name='bias')


logits = tf.matmul(x,w)+b
#나온 값을 확률로 만들기 위해 softmax를 사용한다. 
hypothesis = tf.nn.softmax(logits)

#cross entropy / logits = (logits = tf.matmul(x,w)+b)
#1안 : 짧게 끊어서 코딩하기
cost_i = tf.nn.softmax_cross_entropy_with_logits(logits=logits, labels=y_one_hot)
cost = tf.reduce_mean(cost_i)

#2안: 한번에 길게 코딩하기
cost = tf.reduce_mean(tf.nn.softmax_cross_entropy_with_logits(logits=logits, labels=y_one_hot))

#traininig 
train = tf.train.GradientDescentOptimizer(learning_rate = 0.1).minimize(cost)

#(hypothesis, 1) :1은 1차원을 의미함 (기본값은 1차원, 2일땐 2차원, 3일땐 3차원을 의미한다.)
#argmax를 이용하는 이유: 인덱스가 가장 큰 값을 return해주기 때문에 
prediction = tf.argmax(hypothesis, 1)

''' argmax를 test해보기
a1 = tf.Variable([0.1,0.3,0.5])
sess = tf.Session()
sess.run(tf.global_variables_initializer())
print(sess.run(tf.argmax(a1)))  #a1의 argmax, 즉 인덱스가 가장 큰 값을 return해줌 
print(sess.run(tf.argmin(a1)))  #a1의 argmin, 즉 인덱스가 가장 작은 값을 return해줌 
sess.close()
'''

correct_prediction = tf.equal(prediction, tf.argmax(y_one_hot, 1))

#corredction_prediction을 tf.float32로 dtype 설정하여 reduce_mean을 해줌 
accuracy = tf.reduce_mean(tf.cast(correct_prediction, tf.float32))

sess = tf.Session()
sess.run(tf.global_variables_initializer())
for step in range(2001):
    sess.run(train, feed_dict={x:x_data, y:y_data})
    if step % 100 ==0:
        loss, acc = sess.run([cost, accuracy], feed_dict={x:x_data, y:y_data})
        print("Step: ", step, " Loss: ", loss," Accuracy : ",acc)

#Step:  200  Loss:  0.61006963  Accuracy :  0.625
#Step:  300  Loss:  0.5493963  Accuracy :  0.75
#Step:  400  Loss:  0.50647  Accuracy :  1.0
#Step:  500  Loss:  0.4729592  Accuracy :  1.0
#Step:  600  Loss:  0.445494  Accuracy :  1.0
#Step:  700  Loss:  0.4223158  Accuracy :  1.0
#Step:  800  Loss:  0.40235963  Accuracy :  1.0

#test1
a = sess.run(hypothesis, feed_dict={x:[[1,2,1]]})
#Out[403]: array([[9.9798632e-01, 2.0132938e-03, 3.5136199e-07]], dtype=float32)
print(a,sess.run(tf.argmax(a,1))) # [0]번 인덱스가 가장 큼   # argmax(a,1) -> argmax에서 반환되는 값은 index이다. 여기서 1은 1차원을 의미한다. 
#[[9.9798632e-01 2.0132938e-03 3.5136199e-07]] [0] 

#test2
b = sess.run(hypothesis, feed_dict={x:[[1,7,7]]})
print(b,sess.run(tf.argmax(b,1))) #[2]번 인덱스가 가장 큼 
#[[1.7023287e-04 8.4930271e-02 9.1489947e-01]] [2]

#test3
c = sess.run(hypothesis, feed_dict={x:[[1,4,5]]})
print(c,sess.run(tf.argmax(c,1))) #[1]번 인덱스가 가장 큼   
#[[0.12192319 0.7085265  0.16955036]] [1]

#train data(train.txt)에서 test1, test2는 있음 -> 알맞게 분류 / test3는 없는 데이터를 넣어 분류를 받음


# =============================================================================



# -*- coding: utf-8 -*-
"""
Created on Wed Nov  7 09:55:38 2018

@author: stu
"""

# =============================================================================
# [문제] zoo data set을 이용해서 분류프로그램을 만드세요.
# =============================================================================

import tensorflow as tf
import numpy as np
import pandas as pd

#zoo = np.loadtxt("c:/data/zoo_data.txt", delimiter=",", dtype=np.float32)
#zoo = np.array(")

zoo = pd.read_csv("c:/data/zoo_data.csv")

zoo = pd.read_csv("c:/data/zoo_data.csv")



#zoo = tf.data.Dataset("c:data/zoo_data.txt")

#x_data = zoo[:,1:16]

x_data = zoo.ix[:,1:-1]

y_data = zoo.ix[:,[-1]]

x = tf.placeholder(tf.float32, [None,16])
y = tf.placeholder(tf.int32, [None,1])

#one-hot encoding : 7개 범주
y_one_hot = tf.one_hot(y,7) 

#3차원 배열로 만들지 않을 것이기 때문에 reshape을 해준다.
#[-1,3] : -1은 None이라고 생각하면 된다.
y_one_hot = tf.reshape(y_one_hot, [-1,7])

w = tf.Variable(tf.random_normal([16,7]), name='weight')
b = tf.Variable(tf.random_normal([7]), name='bias')

logits = tf.matmul(x,w)+b

#나온 값을 확률로 만들기 위해 softmax를 사용한다. 
hypothesis = tf.nn.softmax(logits)

#cross entropy / logits = (logits = tf.matmul(x,w)+b)
cost = tf.reduce_mean(tf.nn.softmax_cross_entropy_with_logits(logits=logits, labels=y_one_hot))

#training시키기
train = tf.train.GradientDescentOptimizer(learning_rate = 0.1).minimize(cost)

#prediction하기 ->(hypothesis, 1) :1은 1차원을 의미함 
prediction = tf.argmax(hypothesis, 1)

correct_prediction = tf.equal(prediction, tf.argmax(y_one_hot, 1))

accuracy = tf.reduce_mean(tf.cast(correct_prediction, tf.float32))

sess = tf.Session()
sess.run(tf.global_variables_initializer())
for step in range(2001):
    sess.run(train, feed_dict={x:x_data, y:y_data})
    if step % 100 ==0:
        loss, acc = sess.run([cost, accuracy], feed_dict={x:x_data, y:y_data})
        print("Step: ", step, " Loss: ", loss," Accuracy : ",acc)


#0 : 포유류, 1 : 조류, 2 : 파충류, 3 : 어류, 4 : 양서류, 5 : 곤충/거미류, 6 : 무척추동물
#test: aardvark : 0
a = sess.run(hypothesis, feed_dict={x:[[1,0,0,1,0,0,1,1,1,1,0,0,4,0,0,1]]})
print(a,sess.run(tf.argmax(a,1)))

# test: dove : 1
b = sess.run(hypothesis, feed_dict={x:[[0,1,1,0,1,0,0,0,1,1,0,0,2,1,1,0]]})
print(c,sess.run(tf.argmax(b,1)))

# test: dove : 6
c = sess.run(hypothesis, feed_dict={x:[[0,0,1,0,0,1,1,0,0,0,0,0,6,0,0,0]]})
print(c,sess.run(tf.argmax(c,1)))

# =============================================================================
# 쌤답안; 코드 확인 필요 ㅠㅠㅠㅠㅠㅠ
# 신경망안에는 숫자만 들어가야함 

import tensorflow as tf
import numpy as np

#usecols: 특정한 열만 사용할 경우 컬럼 인덱스를 표시하면 된다.
xy = np.loadtxt("c:/data/zoo_data.txt", delimiter=",", usecols = (1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17), dtype=np.float32)
x_data = xy[:,0:-1]
y_data = xy[:,[-1]]

# 1 : 포유류, 2 : 조류, 3 : 파충류, 4 : 어류, 5 : 양서류, 6 : 곤충/거미류, 7 : 무척추동물 
# 위의 분류의 값을 0~6번으로 바꾸기 (왜냐하면 python은 0번부터 시작하기때문에 나중에 분류할 때 헷갈리지 않게 y_data에서 1을 빼줌 )
# 결과 0 : 포유류, 1 : 조류, 2 : 파충류, 3 : 어류, 4 : 양서류, 5 : 곤충/거미류, 6 : 무척추동물 
y_data = y_data -1 

#데이터 모형 확인하기 
print(x_data.shape, y_data.shape)

# 7개로 분류함 ;미리 선언하기
nb_classes = 7

x = tf.placeholder(tf.float32, [None,16])
y = tf.placeholder(tf.int32, [None, 1])

# one-hot encoding
y_one_hot = tf.one_hot(y, nb_classes)

#reshape -> 별도의 7개 열을 생성함 
y_one_hot = tf.reshape(y_one_hot, [-1, nb_classes])

# weight, bias
w = tf.Variable(tf.random_normal([16, nb_classes], seed=0), name="weight")
b = tf.Variable(tf.random_normal([nb_classes], seed=0), name="bias") 

# 분류를 이용하기 위해 softmax를 사용해야 함
# tf.matmul: tensor에서 제공하는 행렬의 곱 - affine sum
logits = tf.matmul(x,w)+b

# activation function을 softmax로 이용
hypothesis = tf.nn.softmax(logits)

#
cost = tf.reduce_mean(tf.nn.sigmoid_cross_entropy_with_logits(logits=logits, labels=y_one_hot))

optimizer = tf.train.GradientDescentOptimizer(learning_rate = 0.1).minimize(cost)

predicton = tf.argmax(hypothesis,1)
correct_prediction  = tf.equal(prediction, tf.arg_max(y_one_hot,1))
accuracy = tf.reduce_mean(tf.cast(correct_prediction, tf.float32))

sess = tf.Session()
sess.run(tf.global_variables_initializer())
for step in range(2001):
    sess.run(optimizer, feed_dict={x:x_data, y:y_data})
    if step%100 == 0:
        loss, acc = sess.run([cost, accuracy], feed_dict = {x: x_data, y: y_data})
        print("Step: {:5}\tLoss:{:.3f} )\tAcc:{:.2%}".format(step, loss, acc))
    
     #{:5}: 다섯칸을 만들어서 오른쪽을 기준으로 하여 왼쪽에 공백이 나오도록 하기 / 이 모양으로 
     # {:.3f} :  소수점 3자리까지만 표현하겠음 
     # {:.2%} : 소수점 2자리까지 쓰고 %를 사용 
     #\t : tab키가 들어가서 가지런한 정렬을 함 



#비교하기
pred = sess.run(prediction, feed_dict = {x:x_data})
for p, y in zip(pred, y_data.flatten()):
    print("[{}] Prediction: {} True Y:{}".format(p==int(y),p,int(y)))

# =============================================================================
# 쌤답안; 서옥이 
import tensorflow as tf
import numpy as np

xy = np.loadtxt("c:/data/zoo_data.txt",delimiter=",",usecols=(1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17),dtype=np.float32)

x_data = xy[:,0:-1]
y_data = xy[:,[-1]]
y_data=y_data-1 # 인덱스를 0번 부터 시작하는걸로 맞추려고  지금은 1번부터 7번까지 

print(x_data.shape,y_data.shape)

x= tf.placeholder(tf.float32,[None,16])
y= tf.placeholder(tf.int32,[None,1])

y_one_hot = tf.one_hot(y,7)
y_one_hot = tf.reshape(y_one_hot,[-1,7])  ## -1 = None

w=tf.Variable(tf.random_normal([16,7],seed =0), name ="weight")
b=tf.Variable(tf.random_normal([7],seed =0), name ="bias")

logits = tf.matmul(x,w)+b
hypothesis = tf.nn.softmax(logits)

cost = tf.reduce_mean(tf.nn.softmax_cross_entropy_with_logits(logits=logits,labels=y_one_hot))

optimizer= tf.train.GradientDescentOptimizer(learning_rate=0.9).minimize(cost)

prediction = tf.argmax(hypothesis,1)
correct_prediction = tf.equal(prediction,tf.argmax(y_one_hot,1))

accuracy = tf.reduce_mean(tf.cast(correct_prediction,tf.float32))

sess=tf.Session()
sess.run(tf.global_variables_initializer())
for step in range(2001):
    sess.run(optimizer,feed_dict={x:x_data,y:y_data})
    if step % 100 == 0:
        loss,acc =sess.run([cost,accuracy],feed_dict={x:x_data,y:y_data})
        print("Step:{:5}\tLoss:{:3f}\tACC:{:.2%}".format(step,loss,acc))
        

#비교하기 ;  y_data.flatte(): 데이터를 펼처 보기
pred = sess.run(prediction, feed_dict = {x:x_data})
for p, y in zip(pred, y_data.flatten()):
    print("[{}] Prediction: {} True Y:{}".format(p==int(y),p,int(y)))


#worm,0,0,1,0,0,0,0,0,0,1,0,0,0,0,0,0,7
zoo_hypothesis = sess.run(hypothesis, feed_dict={x:[[0,0,1,0,0,0,0,0,0,1,0,0,0,0,0,0]]})
#출력된 확률중 가장 큰 확률을 뽑아주기 arg_max 
print(zoo_hypothesis, sess.run(tf.arg_max(zoo_hypothesis,1)))

#wren,0,1,1,0,1,0,0,0,1,1,0,0,2,1,0,0,2
zoo_hypothesis = sess.run(hypothesis, feed_dict={x:[[0,1,1,0,1,0,0,0,1,1,0,0,2,1,0,0]]})
print(zoo_hypothesis, sess.run(tf.arg_max(zoo_hypothesis,1)))


# =============================================================================

#만약 문자로 제공되었다면  numpy의 one-hot encoding을 사용해야한다. 

#cf. 
a = np.arange(12)
a
#3x4로 만들기
b = a.reshape(3,4)
#한쪽이 상수값이 들어 갔을 경우 숫자가 고정되기 때문에, -1로 하면 4열이 자동으로 들어가나.
b = a.reshape(3,-1)
a.reshape(2,2,-1)
a.reshape(2,-1,2)
#.flatten(): array를 풀어버리는 기능(array를 펼치는 기능)
a.flatten()
 
# =============================================================================

# =============================================================================
# [문제] bmi.csv 내용을 신경망을 이용해서 분류해 보세요.
#
#BMI
# BMI = 몸무게 / (키(m)*키(m))
# 18.5 이상 25미만이면 표준
#label : thin(저체중), normal(정상), fat(비만)
#
# =============================================================================

#학습을 했을 때 잘 나오지 않으면 -> 1. data작업에서 scale작업을 하거나(max, 표준편차 등을 이용) 2. activation function을 다르게 사용하거나 해야한다. 
import pandas as pd

xy = pd.read_csv("c:/data/bmi.csv")

cols = ['height', 'weight']

# label data 이름 -> 숫자로 변경
xy['label']= xy['label'].replace('thin', 0)
xy['label'] = xy['label'].replace('normal', 1)
xy['label'] = xy['label'].replace('fat', 2)

# pandas를 이용한 one-hot encoding 
dummy_label = pd.get_dummies(xy['label'], prefix='label')

# x, y data만들기
    #x_data = xy[:,0:-1]
    #y_data = xy[:,[-1]]

x_data = xy[cols]
y_data = xy['label']

#x_data, y_data array형식으로 만들기
x_data = np.array(x_data)

y_data2 = []
for i in y_data:
    y_data2.append([i])

y_data = y_data2    

y_one_hot = dummy_label

# 3안 성능향상시키기 scale해주기 (3안 적용후 1안 또는 2안해보기 )
    from sklearn.preprocessing import StandardScaler
    scaler = StandardScaler()
    X_scaled = scaler.fit_transform(x_data)


x = tf.placeholder(tf.float32, [None,2])
y = tf.placeholder(tf.int32, [None, 1])

#1안 
    w = tf.Variable(tf.random_normal([2,3], seed=0), name = 'weight')
    b1 = tf.Variable(tf.random_normal([3], seed=0), name= 'bias')
    
    logits = tf.matmul(x,w)+b
    
    #softmax 이용
    hypothesis = tf.nn.softmax(logits)

    #relu 이용
    #hypothesis = tf.nn.(logits)


#2안
    w1 = tf.Variable(tf.random_normal([2,5], seed=0), name = 'weight')
    b1 = tf.Variable(tf.random_normal([5], seed=0), name= 'bias')
    
    layer1 = tf.sigmoid(tf.matmul(x,w1))+b1
        
    w2 = tf.Variable(tf.random_normal([5,3], seed=0),  name='weight2')
    b2 = tf.Variable(tf.random_normal([3], seed=0), name='bias2')
    
    logits = tf.matmul(layer1,w2) + b2
    
    hypothesis = tf.nn.softmax(logits)

cost = tf.reduce_mean(tf.nn.softmax_cross_entropy_with_logits(logits=logits,labels=y_one_hot))

optimizer= tf.train.GradientDescentOptimizer(learning_rate=0.01).minimize(cost)

prediction = tf.argmax(hypothesis,1)
correct_prediction = tf.equal(prediction,tf.argmax(y_data,1))

accuracy = tf.reduce_mean(tf.cast(correct_prediction,tf.float32))

sess=tf.Session()
sess.run(tf.global_variables_initializer())
for step in range(10001):
    ss.run(train,feed_dict = {x:x_data,y:y_data})
    if step % 1000 == 0:
        loss ,acc =ss.run([cost,accuracy],feed_dict  = {x:x_data,y:y_data})
        print("setp{:5}\tLoss:{:.3f}\tAcc:{:.1%}".format(step,loss,acc))
        
pred = ss.run(prediction,feed_dict ={x:X_scaled})
for p ,y in zip(pred,yda['label']):
    print("[{}] prediction : {} True Y : {}" .format(p==int(y),p,int(y)))     
    
        

# =============================================================================
#영은이
        # [문제] bmi.csv 내용을 신경망을 이용해서 분류해 보세요.

#BMI
# BMI = 몸무게 / (키(m)*키(m))
# 18.5 이상 25미만이면 표준
#label : thin(저체중), normal(정상), fat(비만)

bmi = pd.read_csv("c:/data/bmi.csv")
xda = bmi.ix[:,0:2]
yda = bmi.ix[:,[2]]
set(yda['label'])
yda[yda == 'thin' ] = 0
yda[yda == 'normal' ] = 1
yda[yda == 'fat' ] = 2
np.array(xda)
np.array(yda)

# pd.get_dummies(yda)

import tensorflow as f
x = f.placeholder( f.float32,[None,2])
y = f.placeholder( f.int32 ,[None,1])

y_one_hot = f.one_hot(y,3)
y_one_hot = f.reshape(y_one_hot,[-1,3])
w = f.Variable(f.random_normal([2,3],seed=0),name ='weight')
b = f.Variable(f.random_normal([3],seed=0),name ='bias')

logits = f.matmul(x,w)+b

hypothesis = f.nn.softmax(logits)

cost = f.reduce_mean(f.nn.softmax_cross_entropy_with_logits(logits = logits,labels =y_one_hot))
train = f.train.GradientDescentOptimizer(learning_rate = 0.01 ).minimize(cost)

prediction =f.argmax(hypothesis,1)
correct_prediction = f.equal(prediction,f.argmax(y_one_hot,1))
accuracy = f.reduce_mean(f.cast(correct_prediction,f.float32))


scaler = StandardScaler()
X_scaled = scaler.fit_transform(xda)


ss = f.Session()
ss.run(f.global_variables_initializer())


for step in range(10001):
    ss.run(train,feed_dict = {x:X_scaled,y:yda})
    if step % 1000 == 0:
        loss ,acc =ss.run([cost,accuracy],feed_dict  = {x:X_scaled,y:yda})
        print("setp{:5}\tLoss:{:.3f}\tAcc:{:.1%}".format(step,loss,acc))
        
pred = ss.run(prediction,feed_dict ={x:X_scaled})
for p ,y in zip(pred,yda['label']):
    print("[{}] prediction : {} True Y : {}" .format(p==int(y),p,int(y)))     
    
    
    
    


# -*- coding: utf-8 -*-
"""
Created on Thu Nov  8 09:56:04 2018

@author: stu
"""
CNN(Convolution Neural Network)
image ---(pixel값으로 변경)------(convolutions: 필터링작업: 가장특징이 될만한 부분은 부각시키고 의미없는 부분은 흐릿하게 만드는 작업)-----> feature maps(특징맵: 은닉층처럼 이용) --> subsampling(부각시켜지는 부분을 작게 샘플링) --> convolution --> subsampling --> fully connected 


'''
tensorflow MINIST 
https://tensorflowkorea.gitbooks.io/tensorflow-kr/content/g3doc/tutorials/mnist/beginners/

'''

image: 입력값
filter: weight값 
convolution: 합성곱 -> 필터기준으로 옮겨가며 합성곱을 만드는 작업을 함 


# =============================================================================

▣ CNN(Convolution Neural Network)
- 합성곱 신경망
- convolution 층과 pooling층을 포함하는 신경망 

■ 기존신경망과의 CNN 차이?
- 기존방법 : affine -> ReLU
- CNN : Conv -> ReLU -> Pooling  (특징이 될만한 부분은 뽑아낸다.)

■ 합성곱 계층
- feature map을 만들고 그 feature map을 선명하게 해주는 층
- 합성곱 연산: 이미지 3차원(세로, 가로, 색상) data의 형상을 유지하면서 연산하는 작업

ex)
1 2 3 0           2 0 1
0 1 2 3     Θ     0 1 2            15 16
3 0 1 2           1 0 2             6 15
2 3 0 1 

입력              필터              
(4,4)            (3,3)             (2,2)

- stride: 한칸씩 움직여 합성곱을 하는 작업
- 출력 구하기 
입력 - 필터             4 - 3 
-----------   +  1 =  --------- + 1 = 2
  stride                 1

ex) 7x7 입력, 3x3 필터, stride: 1, 5x5 출력
7-3    
----  + 1 =  5
1

ex)  7x7 입력, 3x3 필터, stride: 2,  3x3 출력
7-3    
----  + 1 =  3
2

■ tensor에서 구현해보기

import numpy as np
import tensorflow as tf
import matplotlib.pyplot as plt

#cf. tensor에서 선언한 것은 session.run을 해야함-> 그러나 
#대화형 처리
sess = tf.InteractiveSession()

image = np.array([[[[1],[2],[3]], [[4],[5],[6]],[[7],[8],[9]]]], dtype=np.float32)
print(image.shape)     
#(1, 3, 3, 1) 1: 이미지 n개, 3:행(높이), 3:열(너비), 1:색(채널)

plt.imshow(image.reshape(3,3), cmap="Greys")
#plt.imshow(image.reshape(3,3), cmap="Reds")
#plt.imshow(image.reshape(3,3), cmap="Greens")
#plt.imshow(image.reshape(3,3), cmap="Blues")

weight = tf.constant([[[[1.]],[[1]]],[[[1]],[[1]]]])
print(weight.shape)
# (2,2,1,1): 행, 열, 색, 필터 
# 이미지: (1, 3, 3, 1)에서의  1:색(채널)과 weight에서의 (2,2,1,1) 1:색의 수가 같아야 한다. 

□ 합성곱을 만들어서 feature map을 만듦 
conv2d = tf.nn.conv2d(image,weight,strides=[1,1,1,1], padding='VALID')
#strides=[1,1,1,1] 하나씩 이동하겠음

#sess.run과 같은 기능 
conv2d_img = conv2d.eval()
conv2d_img
#Out[827]: 
#array([[[[12.],
#         [16.]],
#
#        [[24.],
#         [28.]]]], dtype=float32)
print(conv2d_img.shape) #(1, 2, 2, 1)

image
weight

#np.swapaxes: 전체 행렬의 축을 바꾸는 method 
conv2d_img = np.swapaxes(conv2d_img,0,3)
conv2d_img.shape
for i, one_img in enumerate(conv2d_img):
    print(one_img.reshape(2,2))
    plt.subplot(1,2,i+1),plt.imshow(one_img.reshape(2,2), cmap="Greys")

#filter를 거치다보니 합성곱에 걸쳐 나온 결과가 이미지가 축소가 됨 
# -> 입력과 동일한 크기의 이미지를 나오게 하려면 원래의 이미지의 테두리를 주면 된다. 

# 입력과 동일한 크기의 이미지를 나오게 하기  :padding='SAME' / one_img.reshape(3,3))
# padding='SAME' : 합성곱의 출력이 원본 이미지 크기와 같게하는 option 
    #단 stride가 한칸씩 이동할 경우 원본 이미지와 같은 크기의 이미지가 만들어진다.
    #만약 stride를 2로 할 경우 어쩔 수 없이 축소 될수 밖에 없다.      
conv2d = tf.nn.conv2d(image,weight,strides=[1,1,1,1], padding='SAME')
conv2d_img = conv2d.eval()
conv2d_img
#Out[827]: 
#array([[[[12.],
#         [16.]],
#
#        [[24.],
#         [28.]]]], dtype=float32)
print(conv2d_img.shape) #(1, 2, 2, 1)

image
weight

#np.swapaxes: 전체 행렬의 축을 바꾸는 method 
conv2d_img = np.swapaxes(conv2d_img,0,3)
conv2d_img.shape
for i, one_img in enumerate(conv2d_img):
    print(one_img.reshape(3,3))
    plt.subplot(1,2,i+1),plt.imshow(one_img.reshape(3,3), cmap="Greys")


□ sampling 작업 -subsampling 
- subsampling 에서는 actvation fucntion을 둘 수 있다. ReLU만 가능 (sigmoid가 안되는 경우는 원래의 이미지의 색을 반환하지 못하고 망가뜨리기 때문) 
- 이미지를 잘게 잘라 놓음 

□ 그리고 계속 반복되는 작업

image= np.array([[[[4],[3]],[[2],[1]]]],dtype=np.float32)

#max_pool: 가장 큰 수만 뽑아내는 작업  (2x2이 하나라 뽑혀 축소가 됨)
pool = tf.nn.max_pool(image, ksize=[1,2,2,1], strides=[1,1,1,1], padding="VALID")
pool.eval()  #Out[108]: array([[[[4.]]]], dtype=float32)

# =============================================================================
# MNIST 
# Check out https://www.tensorflow.org/get_started/mnist/beginners for
# =============================================================================
import tensorflow as tf
import random
import matplotlib.pyplot as plt

from tensorflow.examples.tutorials.mnist import input_data

tf.set_random_seed(777)  # reproducibility

mnist = input_data.read_data_sets("MNIST_data/", one_hot=True)
# Check out https://www.tensorflow.org/get_started/mnist/beginners for
# more information about the mnist dataset
#img = mnist.train.images[0].reshape(28,28)
#plt.imshow(img,cmap="gray")
# hyper parameters
learning_rate = 0.001
training_epochs = 15        #학습을 15번 반복 (epoch: full로 학습을 한번 하는 것)
batch_size = 100            #데이터 양이 많을 경우에는 100개씩 가져와 부분적으로 수행함 

# input place holders
X = tf.placeholder(tf.float32, [None, 784])  #784개의 열로 되어 있음 
X_img = tf.reshape(X, [-1, 28, 28, 1])   # img 28x28x1 (black/white) 세로(높이)x가로(너비)  # [-1, 28, 28, 1]: -1은 여러개이때문에 무한으로, 채널은 1로
Y = tf.placeholder(tf.float32, [None, 10]) #0~9여서 : 10개이기 때문에 나가는 값이 10개로 씀

# L1 ImgIn shape=(?, 28, 28, 1) (n개 , 28,28, 색은1)
W1 = tf.Variable(tf.random_normal([3, 3, 1, 32], stddev=0.01)) #필터크기(3,3,색, 필터수)   #[3, 3, 1, 32] 3행3열짜리 1색, 32개의 필터-> feature maps

#    Conv     -> (?, 28, 28, 32)
#    Pool     -> (?, 14, 14, 32)
L1 = tf.nn.conv2d(X_img, W1, strides=[1, 1, 1, 1], padding='SAME')
L1 = tf.nn.relu(L1)   #convolution 결과를 relu에 넣음
L1 = tf.nn.max_pool(L1, ksize=[1, 2, 2, 1],strides=[1, 2, 2, 1], padding='SAME') #maxpooling통해서 sampling 작업 #stride를 strides=[1, 2, 2, 1] 두칸씩 이동 -> 따라서 14x14로 만들어짐
'''
Tensor("Conv2D:0", shape=(?, 28, 28, 32), dtype=float32)
Tensor("Relu:0", shape=(?, 28, 28, 32), dtype=float32)
Tensor("MaxPool:0", shape=(?, 14, 14, 32), dtype=float32)
'''

# 위를 다시 한 번 돌림 Tensor("MaxPool:0", shape=(?, 14, 14, 32), dtype=float32) 에서 32개의 채널을 맞춰져야 함 
# L2 ImgIn shape=(?, 14, 14, 32)
W2 = tf.Variable(tf.random_normal([3, 3, 32, 64], stddev=0.01)) # 3,3,32,64(필터수,이미지수) #[3, 3, 32, 64] 64필터수
#    Conv      ->(?, 14, 14, 64)
#    Pool      ->(?, 7, 7, 64)
L2 = tf.nn.conv2d(L1, W2, strides=[1, 1, 1, 1], padding='SAME')
L2 = tf.nn.relu(L2)
L2 = tf.nn.max_pool(L2, ksize=[1, 2, 2, 1],strides=[1, 2, 2, 1], padding='SAME') #strides=[1, 2, 2, 1] 이기 때문에 7x7로 만들어짐 
L2_flat = tf.reshape(L2, [-1, 7 * 7 * 64])
'''
Tensor("Conv2D_1:0", shape=(?, 14, 14, 64), dtype=float32)
Tensor("Relu_1:0", shape=(?, 14, 14, 64), dtype=float32)
Tensor("MaxPool_1:0", shape=(?, 7, 7, 64), dtype=float32)
Tensor("Reshape_1:0", shape=(?, 3136), dtype=float32)
'''
# fully connected layer
# Final FC 7x7x64 inputs -> 10 outputs
W3 = tf.get_variable("W3", shape=[7 * 7 * 64, 10], initializer=tf.contrib.layers.xavier_initializer())  #get_variable: variable대신 사용 가능  #shape=[7 * 7 * 64, 10]: 크기 # initializer=tf.contrib.layers.xavier_initializer(): 변수를 초기화 하는 알고리즘 
b = tf.Variable(tf.random_normal([10])) #b= bias
logits = tf.matmul(L2_flat, W3) + b  #행렬의 곱: 펼쳐놓은 것과  

# define cost/loss & optimizer
cost = tf.reduce_mean(tf.nn.softmax_cross_entropy_with_logits(
    logits=logits, labels=Y))
optimizer = tf.train.AdamOptimizer(learning_rate=learning_rate).minimize(cost)  #AdamOptimizer(learning_rate=learning_rate) : optimizer중에 기존의 gradient descent optimizer대신 Adam optimizer를 사용  (일반적으로 Adam이 더 좋은 성능을 보이지만 그러나 dataset마다 조금씩 다를 수 있으니 optimizer도 비교를 하자)

# initialize
sess = tf.Session()
sess.run(tf.global_variables_initializer())

# train my model
print('Learning started. It takes sometime.')
for epoch in range(training_epochs):
    avg_cost = 0
    total_batch = int(mnist.train.num_examples / batch_size)

    for i in range(total_batch):
        batch_xs, batch_ys = mnist.train.next_batch(batch_size)  #데이터 양이 많을 경우에는 batch size: 100개씩 가져와 부분적으로 수행함 -> RAM이 작을 경우 batch size도 바꿔가면서 해야함  
        feed_dict = {X: batch_xs, Y: batch_ys}
        c, _ = sess.run([cost, optimizer], feed_dict=feed_dict)
        avg_cost += c / total_batch

    print('Epoch:', '%04d' % (epoch + 1), 'cost =', '{:.9f}'.format(avg_cost))

print('Learning Finished!')

# Test model and check accuracy
correct_prediction = tf.equal(tf.argmax(logits, 1), tf.argmax(Y, 1))
accuracy = tf.reduce_mean(tf.cast(correct_prediction, tf.float32))
print('Accuracy:', sess.run(accuracy, feed_dict={
      X: mnist.test.images, Y: mnist.test.labels}))

# Get one and predict
r = random.randint(0, mnist.test.num_examples - 1)
print("Label: ", sess.run(tf.argmax(mnist.test.labels[r:r + 1], 1)))
print("Prediction: ", sess.run(
    tf.argmax(logits, 1), feed_dict={X: mnist.test.images[r:r + 1]}))

plt.imshow(mnist.test.images[r:r + 1].reshape(28, 28), cmap='Greys', interpolation='nearest')
plt.show()



#이미지 학습시, 각각의 폴더를 만들고, 별도의 lable을 만들어야 함 


# =============================================================================
## np.swapaxes 확인하기
#2차원행렬 
a = np.arange(15).reshape(3,5)
a
#.T: 축을 바꿈
a.T
#np.transpose(): 축을 바꿈
np.transpose(a)
#np.swapaxes: 축을 바꿈
a
np.swapaxes(a,0,1)
#np.dot()numpy에서 제공하는 행렬의 곱
np.dot(a.T,a)
np.dot(np.transpose(a),a)
np.dot(np.swapaxes(a,0,1),a)

#3차원행렬
b = np.arange(24).reshape(2,3,4)
#Out[58]: 
#array([[[ 0,  1,  2,  3],
#        [ 4,  5,  6,  7],
#        [ 8,  9, 10, 11]],
#
#       [[12, 13, 14, 15],
#        [16, 17, 18, 19],
#        [20, 21, 22, 23]]])
b.shape
#Out[59]: (2, 3, 4)
b.T
b
np.transpose(b) #면이 4개가 됨 
#Out[62]: 
#array([[[ 0, 12],
#        [ 4, 16],
#        [ 8, 20]],
#
#       [[ 1, 13],
#        [ 5, 17],
#        [ 9, 21]],
#
#       [[ 2, 14],
#        [ 6, 18],
#        [10, 22]],
#
#       [[ 3, 15],
#        [ 7, 19],
#        [11, 23]]])
np.swapaxes(b,0,2)
#Out[63]: 
#array([[[ 0, 12],
#        [ 4, 16],
#        [ 8, 20]],
#
#       [[ 1, 13],
#        [ 5, 17],
#        [ 9, 21]],
#
#       [[ 2, 14],
#        [ 6, 18],
#        [10, 22]],
#
#       [[ 3, 15],
#        [ 7, 19],
#        [11, 23]]])



# =============================================================================
# [문제] 0부터 143까지의 원소로 이루어진 12*12 행렬을 만들고 4*4필터(단위행렬)를
#    이용해 합성곱을 수행하시오. 단, 스트라이드는 1이다.
#
# *합성곱 계층
# -feature map을 만들고 그 feature map을 선명하게 해주는 층
# *합성곱 연산
# -이미지 3차원(세로,가로,색상)데이터의 형상을 유지하며 연산하는 작업
# *합성곱
# -입력 데이터에 필터를 적용한 것이 합성곱 연산이다.
# *np.eye()=numpy에서 단위행렬을 만드는 함수
# 
# =============================================================================

# 합성곱 연산 짜기 
import numpy as np
a=np.arange(144).reshape(12,12)
print(a.shape)
filter=np.eye(4,4)

result=[]
for r in range(len(a)-3):       #r: row  #몇행 몇열로 나오는지를 고민해서 돌려야 한다.
    for c in range(len(a)-3):   #c: col  
        result.append(np.sum(a[r:r+4, c:c+4]*filter))

result = np.array(result).reshape(9,9)

#중요한 부분이 테두리 쪽에 있을 겨웅 padding을 둬야한다. 
#stride의 값에 따라 합성곱의 결과물이 어떤 모양이 되는지 결과를 생각해야 한다. 

□ padding(패딩): 합성곱 연산을 수행하기 전에 입력 데이터 주변을 특정값으로 채워 늘리는 것을 말한다. 
- 이유? 패딩을 하지 않을 경우 데이터의 공간 크기는 합성곱 계층을 지날 때 마다 작아지게 되므로 가장자리 정보들이 사라지게 되는 문제가 발생하기 때문에 패딩을 사용한다. 
- np.pad() numpy에서의 padding method

a = np.arange(16).reshape(4,4)
#패딩을 모두 할 경우
a_pad = np.pad(a, pad_width=1, mode='constant', constant_values=0)

#[(top,bottom),(left,right)] #기본은 [(1,1),(1,1)]
np.pad(a, [(1,1),(1,1)], mode='constant', constant_values=0)

#패딩을 오른쪽과 아랫쪽만 할 경우 (채울 곳은:1 , 채우지 않는 곳은: 0)
np.pad(a, [(0,1),(0,1)], mode='constant', constant_values=0)

#패딩을 오른쪽 2개과 아랫쪽 2개만 할 경우 
np.pad(a, [(0,2),(0,2)], mode='constant', constant_values=0)


# =============================================================================
# [문제] 0부터 15까지 원소로 이루어진 4x4행렬을 만들고 0부터 8까지 원소로 이루어진 3x3필터를 이용해서 합성곱하는데 제로 패딩을 이용해서 출력결과를 4x4로 출력하세요.
# (단 스트라이드는 1로 수행) 
# =============================================================================

x = np.arange(16).reshape(4,4)
filter = np.arange(9).reshape(3,3)

x_pad = np.pad(x, pad_width=1, mode='constant', constant_values=0)
x_pad.shape  #Out[195]: (6, 6)
 
result=[]
for r in range(len(x_pad)-2):
    for c in range(len(x_pad)-2):   
        result.append(np.sum(x_pad[r:r+3, c:c+3]*filter))

result = np.array(result).reshape(4,4)
print(result)

# =============================================================================

입력(H,W), 필터크기(FH,FW), 출력크기(OH,OW)
스트라이드: S, 패딩: P
       H + 2P - FH
OH = ----------------  +  1
           S

#패딩구하기            
S*(OH-1) = H+2P-FH
S*(OH-1)-H+FH = 2P

    (OH-1)*S-H+FH        
P = --------------   
          2
P = ((4-1)*1-4+3)/2   #Out[286]: 1.0 그럼 패딩값이 1로 하면된다. 

# =============================================================================

from PIL import Image
import numpy as np
import matplotlib.pyplot as plt
import matplotlib.image as mpimg

#이미지 불러들이기 (이미지 파일이 숫자일 경우는 오류가 날 수도 있음. 그러면 c:\\ 역슬래쉬를 두번쓰도록 한다.) 
img = Image.open("c:\\data\hcs.png") 
plt.imshow(img)

#RGB: 3차원 배열로 array하도록  0~255로 변환됨  #이미지 픽셀값 뽑기
img_pixel = np.array(img)
img_pixel

#특정 색상에 대한(rgb중) 가중치를 줘서 값을 return함
def rgb_gray(image):  #image는 형식매개변수
    r, g, b = image[:,:,0], image[:,:,1], image[:,:,2]
    gray = 0.2989 *r + 0.5870*g + 0.1140*b              #가중치 주기 
    return gray


plt.imshow(rgb_gray(img_pixel), cmap='gray') #cmap은 imshow의 옵션
plt.imshow(rgb_gray(img_pixel)) 

#저장하기
img_pixel_gray = rgb_gray(img_pixel)
plt.imsave("c:\\data\\gray.png", img_pixel_gray)


# =============================================================================


def convolution(image, filter, stride, bias):
    col = int((len(image[0])-len(filter[0])) / stride +1)
    row = int((len(image)-len(filter)) / stride +1)
    filter_col = len(filter[0])
    filter_row = len(filter)
    
    convolution_list = []
    for i in range(row):
        for j in range(col):
            convolution_list.append(np.sum(image[i:i+filter_row, j:j+filter_col] * filter))
    return np.array(convolution_list).reshape(row,col)
        
filter = np.array([[[255,255,255],[0,0,0],[255,255,255]],
                   [[0,0,0],[0,0,0],[0,0,0]],
                   [[255,255,255],[0,0,0],[255,255,255]]])
filter.shape

filter_gray = rgb_gray(filter)
plt.imshow(filter_gray, cmap="gray")

result = convolusion(img_pixel,filter_gray,1,0)      
result

plt.imshow(result, cmap="gray")
plt.imsave("c:/python/result.png", result, cmap="gray")




    